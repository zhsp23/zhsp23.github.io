<?xml version="1.0" encoding="utf-8"?>
<feed xmlns="http://www.w3.org/2005/Atom">
  <title>zhsp&#39;s blog</title>
  
  
  <link href="/atom.xml" rel="self"/>
  
  <link href="http://yoursite.com/"/>
  <updated>2017-04-01T06:08:20.000Z</updated>
  <id>http://yoursite.com/</id>
  
  <author>
    <name>zhsp23</name>
    
  </author>
  
  <generator uri="http://hexo.io/">Hexo</generator>
  
  <entry>
    <title>一步一步深入理解CoordinatorLayout</title>
    <link href="http://yoursite.com/2017/03/31/%E4%B8%80%E6%AD%A5%E4%B8%80%E6%AD%A5%E6%B7%B1%E5%85%A5%E7%90%86%E8%A7%A3CoordinatorLayout/"/>
    <id>http://yoursite.com/2017/03/31/一步一步深入理解CoordinatorLayout/</id>
    <published>2017-03-31T01:30:00.000Z</published>
    <updated>2017-04-01T06:08:20.000Z</updated>
    
    <content type="html"><![CDATA[<h1 id="一步一步深入理解CoordinatorLayout"><a href="#一步一步深入理解CoordinatorLayout" class="headerlink" title="一步一步深入理解CoordinatorLayout"></a>一步一步深入理解CoordinatorLayout</h1><h2 id="初步了解"><a href="#初步了解" class="headerlink" title="初步了解"></a>初步了解</h2><p>学习最好的习惯就是看官方文档，来看看Col的定义以及官网的介绍：</p><figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">public</span> <span class="class"><span class="keyword">class</span> <span class="title">CoordinatorLayout</span></span></span><br><span class="line"><span class="class"><span class="keyword">extends</span> <span class="title">ViewGroup</span> <span class="keyword">implements</span> <span class="title">NestedScrollingParent</span></span></span><br></pre></td></tr></table></figure><blockquote><p>CoordinatorLayout is a super-powered FrameLayout.<br>CoordinatorLayout is intended for two primary use cases:</p><ol><li>As a top-level application decor or chrome layout</li><li>As a container for a specific interaction with one or more child views</li></ol></blockquote><p>从定义可以看到Col继承自<code>ViewGroup</code>，并且它被设计成一个<code>top-level</code>的根布局，它本身只是一个ViewGroup，实现了<code>NestedScrollingParent</code>接口，看似非常普通，<br>但是说<code>CoordinatorLayout</code>是Design库<strong>最为重要的控件</strong>也不为过。</p><a id="more"></a><p>这里额外需要注意的是:</p><ol><li><strong>由于Col只实现了NestedScrollingParent，所以当Col嵌套（作为一个子View）的时候会得不到你想要的效果，需要自己写一个Col去实现NestedScrollingChild接口！</strong></li><li>没有实现<code>NestedScrollingChild</code>接口的子View如：<code>ListView</code>，<code>ScrollView</code>在5.0以下版本跟Col是配合不了的需要使用<code>RecyclerView</code>，<code>NestedScrollView</code>才行</li></ol><p>Col最为重要的作用是：<strong>提供给子View实现各种交互的极大便利</strong><br>直观的表现是我们可以使用Col非常方便地实现很多交互效果,具体效果可以看<a href="https://github.com/chrisbanes/cheesesquare" target="_blank" rel="noopener">cheesesquare</a>这个项目。</p><h2 id="拦截一切的Behavior"><a href="#拦截一切的Behavior" class="headerlink" title="拦截一切的Behavior"></a>拦截一切的<a href="https://developer.android.com/reference/android/support/design/widget/CoordinatorLayout.Behavior.html" target="_blank" rel="noopener">Behavior</a></h2><p>Behavior是什么，有什么作用？</p><figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br></pre></td><td class="code"><pre><span class="line">Interaction behavior plugin for child views of CoordinatorLayout.</span><br><span class="line"></span><br><span class="line">A Behavior implements one or more interactions that a user can take on a child view. These interactions may include drags, swipes, flings, or any other gestures.</span><br></pre></td></tr></table></figure><p>简单说，Behavior可以负责所有的交互甚至测量以及布局。</p><h3 id="深入了解"><a href="#深入了解" class="headerlink" title="深入了解"></a>深入了解</h3><h4 id="如何实例化指定Behavior"><a href="#如何实例化指定Behavior" class="headerlink" title="如何实例化指定Behavior"></a>如何实例化指定Behavior</h4><ol><li>通过构造方法实例,并在代码中设置到LayoutParamas里</li><li>Xml里指定，比如<code>app:app:layout_behavior=&quot;me.yifeiyuan.demo.HeaderBehavior&quot;</code></li><li>通过<code>DefaultBehavior</code>注解指定，比如<a href="mailto:`@CoordinatorLayout.DefaultBehavior" target="_blank" rel="noopener">`@CoordinatorLayout.DefaultBehavior</a>(AppBarLayout.Behavior.class)`</li></ol><p>第一种方式很简单，不多说，这里针对其他两种方式讲解一下，有一些注意点我们需要知道：</p><h6 id="Xml方式"><a href="#Xml方式" class="headerlink" title="Xml方式"></a>Xml方式</h6><p>先撇一下<code>Behavior</code>的定义以及其构造方法如下：</p><figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br></pre></td><td class="code"><pre><span class="line"><span class="comment">//定义 V 为泛型，可指定针对哪种类型的View</span></span><br><span class="line"><span class="keyword">public</span> <span class="keyword">static</span> <span class="keyword">abstract</span> <span class="class"><span class="keyword">class</span> <span class="title">Behavior</span>&lt;<span class="title">V</span> <span class="keyword">extends</span> <span class="title">View</span>&gt;</span></span><br><span class="line"><span class="class">//默认的构造方法</span></span><br><span class="line"><span class="class"><span class="title">public</span> <span class="title">Behavior</span>() </span>&#123;&#125;</span><br><span class="line"><span class="comment">// xml里使用</span></span><br><span class="line"><span class="function"><span class="keyword">public</span> <span class="title">Behavior</span><span class="params">(Context context, AttributeSet attrs)</span> </span>&#123;&#125;</span><br></pre></td></tr></table></figure><p>当我们在Xml里指定的时候，在<code>LayoutParams</code>的构造方法里会去调用<code>parseBehavior</code>这个方法，<code>parseBehavior</code>关键代码如下(不贴代码不行了，已尽量精简):</p><figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br></pre></td><td class="code"><pre><span class="line"><span class="function"><span class="keyword">static</span> Behavior <span class="title">parseBehavior</span><span class="params">(Context context, AttributeSet attrs, String name)</span> </span>&#123;</span><br><span class="line">    <span class="comment">//...省略了很多代码，只留下关键的部分</span></span><br><span class="line">    <span class="keyword">try</span> &#123;</span><br><span class="line">        <span class="comment">//获取构造方法</span></span><br><span class="line">        Map&lt;String, Constructor&lt;Behavior&gt;&gt; constructors = sConstructors.get(); </span><br><span class="line">        <span class="comment">//...</span></span><br><span class="line">        <span class="keyword">return</span> c.newInstance(context, attrs); <span class="comment">// 注意这一行，这里传递了attrs，所以我们必须要有第二个构造方法！！！</span></span><br><span class="line">    &#125; <span class="keyword">catch</span> (Exception e) &#123;</span><br><span class="line">        <span class="keyword">throw</span> <span class="keyword">new</span> RuntimeException(<span class="string">"Could not inflate Behavior subclass "</span> + fullName, e);<span class="comment">//否则会报错 crash</span></span><br><span class="line">    &#125;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure><p>这里我们需要注意的是: <strong>如果要在xml里使用Behavior 那么第二个构造方法必不可少，所以我们自定义Behavior的时候需要注意;另外你在xml定义的属性会传递到第二个构造方法里去，可以获取你在xml里配置的属性，非常方便，可以说考虑还是非常周到的</strong></p><h6 id="注解方式"><a href="#注解方式" class="headerlink" title="注解方式"></a>注解方式</h6><p>第三种通过注解的方式，又是在什么时候，怎么去实例化的呢？</p><p>在Col中的<code>onMeasure</code>中会去调用<code>prepareChildren</code>方法，而<code>prepareChildren</code>方法又调用了一个叫<code>getResolvedLayoutParams</code>的方法如下:</p><figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br></pre></td><td class="code"><pre><span class="line"><span class="function">LayoutParams <span class="title">getResolvedLayoutParams</span><span class="params">(View child)</span> </span>&#123;</span><br><span class="line">    <span class="keyword">final</span> LayoutParams result = (LayoutParams) child.getLayoutParams();</span><br><span class="line">    <span class="keyword">if</span> (!result.mBehaviorResolved) &#123;<span class="comment">//如果没有解析过 则去解析</span></span><br><span class="line">        Class&lt;?&gt; childClass = child.getClass();</span><br><span class="line">        DefaultBehavior defaultBehavior = <span class="keyword">null</span>;</span><br><span class="line">        <span class="keyword">while</span> (childClass != <span class="keyword">null</span> &amp;&amp;</span><br><span class="line">                (defaultBehavior = childClass.getAnnotation(DefaultBehavior.class)) == <span class="keyword">null</span>) &#123;<span class="comment">//如果 有DefaultBehavior这个注解</span></span><br><span class="line">            childClass = childClass.getSuperclass();</span><br><span class="line">        &#125;</span><br><span class="line">        <span class="keyword">if</span> (defaultBehavior != <span class="keyword">null</span>) &#123;</span><br><span class="line">            <span class="keyword">try</span> &#123;</span><br><span class="line">                result.setBehavior(defaultBehavior.value().newInstance());<span class="comment">//实例化Behavior并把这个Behavior赋值给result</span></span><br><span class="line">            &#125; <span class="keyword">catch</span> (Exception e) &#123;</span><br><span class="line">                Log.e(TAG, <span class="string">"Default behavior class "</span> + defaultBehavior.value().getName() +</span><br><span class="line">                        <span class="string">" could not be instantiated. Did you forget a default constructor?"</span>, e);</span><br><span class="line">            &#125;</span><br><span class="line">        &#125;</span><br><span class="line">        result.mBehaviorResolved = <span class="keyword">true</span>;<span class="comment">//标记已经解析过  </span></span><br><span class="line">    &#125;</span><br><span class="line">    <span class="keyword">return</span> result;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure><p>所以注解方式是在<code>onMeasure</code>中通过<code>getResolvedLayoutParams</code>去实例化的。</p><p>另外还需要知道的是，<code>Behavior</code>是Col.LayoutParams的成员变量，那么也就是说只有当你的<code>Behavior</code>设置给Col的 <strong>直接子View</strong> 才会有效果，这点要记住，不然徒劳无功。(Col的子View的子View就不要给它设置Behavior啦，没效果的)</p><p>重要的事情说三遍 ：<strong>Behavior要设置给Col的直接子view</strong></p><p>重要的事情说三遍 ：<strong>Behavior要设置给Col的直接子view</strong></p><p>重要的事情说三遍 ：<strong>Behavior要设置给Col的直接子view</strong></p><p>以上需要牢记，不过仅仅知道这些显然是不够的！</p><p>接下去继续深入阅读Behavior的源码一探究竟（一言不合就看源码）</p><p>在阅读了<code>Behavior</code>的源码后，觉得非常有必要先搞清楚几个非常重要的概念。</p><h4 id="child与dependency"><a href="#child与dependency" class="headerlink" title="child与dependency"></a>child与dependency</h4><ol><li><strong>child</strong>，<em>the child view associated with this Behavior</em><br>它是一个View，<strong>是该Behavior的关联对象，也即Behavior所要操作的对象</strong></li><li><strong>dependency</strong>，也是个View，是 <strong>child的依赖对象，同时也是Behavior对child进行操作的根据</strong></li></ol><p>弄清楚这些个概念后看源码会比较简单了，<code>Behavior</code>除了构造方法外，有23个方法，限于篇幅与精力，我挑选几个最重要的方法来讲解，当然我不会死板的一个一个毫无逻辑地解释过去。</p><h4 id="那些不能不懂的方法"><a href="#那些不能不懂的方法" class="headerlink" title="那些不能不懂的方法"></a>那些不能不懂的方法</h4><h5 id="layoutDependsOn"><a href="#layoutDependsOn" class="headerlink" title="layoutDependsOn"></a>layoutDependsOn</h5><p>之前提到了child与dependency有着依赖关系，那么问题来了： <strong>这个依赖关系是如何建立的？</strong></p><p>在Behavior类中有个方法：</p><figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><span class="line"><span class="function"><span class="keyword">public</span> <span class="keyword">boolean</span> <span class="title">layoutDependsOn</span><span class="params">(CoordinatorLayout parent, V child, View dependency)</span></span></span><br></pre></td></tr></table></figure><p>它会被<code>Behavior</code>的LayoutParamas的<code>dependsOn</code>方法调用：</p><figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br></pre></td><td class="code"><pre><span class="line"><span class="function"><span class="keyword">boolean</span> <span class="title">dependsOn</span><span class="params">(CoordinatorLayout parent, View child, View dependency)</span> </span>&#123;</span><br><span class="line">    <span class="keyword">return</span> dependency == mAnchorDirectChild</span><br><span class="line">            || (mBehavior != <span class="keyword">null</span> &amp;&amp; mBehavior.layoutDependsOn(parent, child, dependency));</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure><p>而LayoutParamas的<code>dependsOn</code>方法会被Col调用，<code>dependsOn</code>方法就是用来确定依赖关系的。</p><p>所以，最简单的确定依赖关系的方法是重写<code>layoutDependsOn</code>方法，并在一定条件下返回<code>true</code>即可确立依赖关系。</p><p>那为什么说一定条件呢？</p><p>比如FAB依赖于<code>SnackBar</code>，是因为它在<code>SnackBar</code>出现以及消失的时候需要改变自身的位置，所以FAB的<code>layoutDependsOn</code>方法中对<code>Snackbar.SnackbarLayout</code>返回了true，而没有依赖其他的控件：</p><figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br></pre></td><td class="code"><pre><span class="line"><span class="meta">@Override</span></span><br><span class="line"><span class="function"><span class="keyword">public</span> <span class="keyword">boolean</span> <span class="title">layoutDependsOn</span><span class="params">(CoordinatorLayout parent,FloatingActionButton child, View dependency)</span> </span>&#123;</span><br><span class="line">    <span class="comment">// We're dependent on all SnackbarLayouts (if enabled)</span></span><br><span class="line">    <span class="keyword">return</span> SNACKBAR_BEHAVIOR_ENABLED &amp;&amp; dependency <span class="keyword">instanceof</span> Snackbar.SnackbarLayout;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure><p>另外需要注意的是：<strong>当确定依赖关系后，当dependency被布局（或测量）后child会紧接着被布局（或测量）</strong>，Col会<strong>无视子view的顺序</strong>(原因是Col内有个Comparator<code>mLayoutDependencyComparator</code>会按照依赖关系对所有的子View进行排序),这会影响它们的测量以及布局顺序</p><p>可以说<code>layoutDependsOn</code>方法是自定义<code>Behavior</code>最为重要的方法</p><h5 id="onDependentViewChanged"><a href="#onDependentViewChanged" class="headerlink" title="onDependentViewChanged"></a>onDependentViewChanged</h5><p>建立起依赖关系之后呢？</p><p>想要做交互，似乎还缺点什么，我想在dependency发生变化的时候改变一下child，我该如何知道这个改变的时机呢？</p><p>其实不需要我们去主动获取去判断，其实Col跟Behavior已经帮我们做好了这一切，<code>onDependentViewChanged</code>登场。</p><p><code>onDependentViewChanged</code>方法的定义：</p><figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br></pre></td><td class="code"><pre><span class="line"><span class="comment">/**</span></span><br><span class="line"><span class="comment"> * Respond to a change in a child's dependent view</span></span><br><span class="line"><span class="comment"> * This method is called whenever a dependent view changes in size or position outside</span></span><br><span class="line"><span class="comment"> * of the standard layout flow. A Behavior may use this method to appropriately update</span></span><br><span class="line"><span class="comment"> * the child view in response.</span></span><br><span class="line"><span class="comment"> */</span></span><br><span class="line"><span class="function"><span class="keyword">public</span> <span class="keyword">boolean</span> <span class="title">onDependentViewChanged</span><span class="params">(CoordinatorLayout parent, V child, View dependency)</span> </span>&#123;</span><br><span class="line">    <span class="keyword">return</span> <span class="keyword">false</span>;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure><p>简单来说就是，当我们的<code>dependency</code>发生改变的时候，这个方法会调用，而我们在<code>onDependentViewChanged</code>方法里做出相应的改变，就能做出我们想要的交互效果了！</p><p>可能你也注意到了<code>onDependentViewChanged</code>方法是有返回值的</p><p>当我们改变了child的<code>size</code>或者<code>position</code>的时候我们需要返回true，差不多可以理解为 当我们的<code>dependency</code>发生了改变，同样的，child也需要发生改变，这个时候我们需要返回<code>true</code></p><p>提一下：<code>onDependentViewChanged</code>方法是在Col的<code>dispatchOnDependentViewChanged</code>里调用的</p><h5 id="其他"><a href="#其他" class="headerlink" title="其他"></a>其他</h5><p>除了以上两个特别重要的方法外，Nested系列方法也非常重要,如<code>onStartNestedScroll</code>和<code>onStopNestedScroll</code>来监听嵌套滚动的开始和结束，不过限于篇幅，想再另外开篇去写，这里就不写了</p><p>另外还有<code>onMeasureChild</code>，<code>onLayoutChild</code>这个后面会讲。</p><h2 id="为什么Behavior可以拦截一切？"><a href="#为什么Behavior可以拦截一切？" class="headerlink" title="为什么Behavior可以拦截一切？"></a>为什么Behavior可以拦截一切？</h2><p>我们知道，ViewGroup的测量，布局，事件分发都是需要自己处理的，那么Col究竟给了<code>Behavior</code>什么特权，让它能够让它拦截一切？</p><p>让我们挨个一点一点看下去</p><h3 id="onMeasure"><a href="#onMeasure" class="headerlink" title="onMeasure"></a>onMeasure</h3><p>直接备注在源码里了，不多说啦！~</p><figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br><span class="line">28</span><br><span class="line">29</span><br><span class="line">30</span><br><span class="line">31</span><br></pre></td><td class="code"><pre><span class="line"><span class="meta">@Override</span></span><br><span class="line"><span class="function"><span class="keyword">protected</span> <span class="keyword">void</span> <span class="title">onMeasure</span><span class="params">(<span class="keyword">int</span> widthMeasureSpec, <span class="keyword">int</span> heightMeasureSpec)</span> </span>&#123;</span><br><span class="line">    <span class="comment">//之前已经提到过了 解析Behavior，并按依赖顺序重排子View顺序 </span></span><br><span class="line">    prepareChildren();</span><br><span class="line">    <span class="comment">//用于addPreDrawListener，OnPreDrawListener里会调用 dispatchOnDependentViewChanged(false)</span></span><br><span class="line">    ensurePreDrawListener();</span><br><span class="line">    <span class="comment">//...</span></span><br><span class="line">    <span class="comment">// 计算 padding width height 处理 fitSystemWindow等</span></span><br><span class="line">    <span class="comment">//...</span></span><br><span class="line">    <span class="keyword">final</span> <span class="keyword">int</span> childCount = mDependencySortedChildren.size();</span><br><span class="line">    <span class="keyword">for</span> (<span class="keyword">int</span> i = <span class="number">0</span>; i &lt; childCount; i++) &#123;</span><br><span class="line">        <span class="keyword">final</span> View child = mDependencySortedChildren.get(i);</span><br><span class="line">        <span class="keyword">final</span> LayoutParams lp = (LayoutParams) child.getLayoutParams();</span><br><span class="line">        <span class="keyword">int</span> keylineWidthUsed = <span class="number">0</span>;</span><br><span class="line">        <span class="comment">//...处理keyline childWidthMeasureSpec等</span></span><br><span class="line">        <span class="keyword">final</span> Behavior b = lp.getBehavior();</span><br><span class="line">        <span class="comment">// 跟onMeasure相同，当behavior的onMeasureChild方法返回true的时候，我们就可以拦截Col默认的measure</span></span><br><span class="line">        <span class="keyword">if</span> (b == <span class="keyword">null</span> || !b.onMeasureChild(<span class="keyword">this</span>, child, childWidthMeasureSpec, keylineWidthUsed,</span><br><span class="line">                childHeightMeasureSpec, <span class="number">0</span>)) &#123;</span><br><span class="line">            onMeasureChild(child, childWidthMeasureSpec, keylineWidthUsed,</span><br><span class="line">                    childHeightMeasureSpec, <span class="number">0</span>);</span><br><span class="line">        &#125;</span><br><span class="line">        <span class="comment">//...</span></span><br><span class="line">    &#125;</span><br><span class="line">    <span class="comment">//...</span></span><br><span class="line">    <span class="keyword">final</span> <span class="keyword">int</span> width = ViewCompat.resolveSizeAndState(widthUsed, widthMeasureSpec,</span><br><span class="line">            childState &amp; ViewCompat.MEASURED_STATE_MASK);</span><br><span class="line">    <span class="keyword">final</span> <span class="keyword">int</span> height = ViewCompat.resolveSizeAndState(heightUsed, heightMeasureSpec,</span><br><span class="line">            childState &lt;&lt; ViewCompat.MEASURED_HEIGHT_STATE_SHIFT);</span><br><span class="line">    setMeasuredDimension(width, height);</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure><h3 id="onLayout"><a href="#onLayout" class="headerlink" title="onLayout"></a>onLayout</h3><figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br></pre></td><td class="code"><pre><span class="line"><span class="meta">@Override</span></span><br><span class="line"><span class="function"><span class="keyword">protected</span> <span class="keyword">void</span> <span class="title">onLayout</span><span class="params">(<span class="keyword">boolean</span> changed, <span class="keyword">int</span> l, <span class="keyword">int</span> t, <span class="keyword">int</span> r, <span class="keyword">int</span> b)</span> </span>&#123;</span><br><span class="line">    <span class="keyword">final</span> <span class="keyword">int</span> layoutDirection = ViewCompat.getLayoutDirection(<span class="keyword">this</span>);</span><br><span class="line">    <span class="comment">//mDependencySortedChildren 在 onMeasure里已经排过序了</span></span><br><span class="line">    <span class="keyword">final</span> <span class="keyword">int</span> childCount = mDependencySortedChildren.size();</span><br><span class="line">    <span class="keyword">for</span> (<span class="keyword">int</span> i = <span class="number">0</span>; i &lt; childCount; i++) &#123;</span><br><span class="line">        <span class="keyword">final</span> View child = mDependencySortedChildren.get(i);</span><br><span class="line">        <span class="keyword">final</span> LayoutParams lp = (LayoutParams) child.getLayoutParams();</span><br><span class="line">        <span class="keyword">final</span> Behavior behavior = lp.getBehavior();</span><br><span class="line">        <span class="comment">//可以看到，当behavior.onLayoutChild()返回true的时候，就可以拦截掉Col的默认Layout操作！    </span></span><br><span class="line">        <span class="keyword">if</span> (behavior == <span class="keyword">null</span> || !behavior.onLayoutChild(<span class="keyword">this</span>, child, layoutDirection)) &#123;</span><br><span class="line">            onLayoutChild(child, layoutDirection);</span><br><span class="line">        &#125;</span><br><span class="line">    &#125;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure><p>原理其实跟<code>onMeasure</code>方法一样的。</p><h3 id="onInterceptTouchEvent-amp-onTouchEvent"><a href="#onInterceptTouchEvent-amp-onTouchEvent" class="headerlink" title="onInterceptTouchEvent &amp; onTouchEvent"></a>onInterceptTouchEvent &amp; onTouchEvent</h3><p>在处理touch事件中，Col重写了<code>onInterceptTouchEvent</code>和<code>onTouchEvent</code>，另外，它们都调用了Col里定义的一个处理拦截的方法，<code>performIntercept</code>（关键代码都在这方法之中），就看一下它们的实现吧：</p><p><code>onInterceptTouchEvent</code>的实现：</p><figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br></pre></td><td class="code"><pre><span class="line"><span class="meta">@Override</span></span><br><span class="line"><span class="function"><span class="keyword">public</span> <span class="keyword">boolean</span> <span class="title">onInterceptTouchEvent</span><span class="params">(MotionEvent ev)</span> </span>&#123;</span><br><span class="line">    MotionEvent cancelEvent = <span class="keyword">null</span>;</span><br><span class="line">    <span class="keyword">final</span> <span class="keyword">int</span> action = MotionEventCompat.getActionMasked(ev);</span><br><span class="line">    <span class="comment">// Make sure we reset in case we had missed a previous important event.</span></span><br><span class="line">    <span class="keyword">if</span> (action == MotionEvent.ACTION_DOWN) &#123;</span><br><span class="line">        <span class="comment">//down的时候，跟大部分ViewGroup一样，需要重置一些状态以及变量，比如 mBehaviorTouchView</span></span><br><span class="line">        resetTouchBehaviors();</span><br><span class="line">    &#125;</span><br><span class="line">    <span class="comment">//这里看performIntercept TYPE_ON_INTERCEPT标记是 onInterceptTouchEvent</span></span><br><span class="line">    <span class="keyword">final</span> <span class="keyword">boolean</span> intercepted = performIntercept(ev, TYPE_ON_INTERCEPT);</span><br><span class="line">    <span class="keyword">if</span> (cancelEvent != <span class="keyword">null</span>) &#123;</span><br><span class="line">        cancelEvent.recycle();</span><br><span class="line">    &#125;</span><br><span class="line">    <span class="comment">//当事件为UP和Cancel的时候去重置（同down）</span></span><br><span class="line">    <span class="keyword">if</span> (action == MotionEvent.ACTION_UP || action == MotionEvent.ACTION_CANCEL) &#123;</span><br><span class="line">        resetTouchBehaviors();</span><br><span class="line">    &#125;</span><br><span class="line">    <span class="keyword">return</span> intercepted;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure><p><code>onTouchEvent</code>的实现：</p><figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br></pre></td><td class="code"><pre><span class="line"><span class="meta">@Override</span></span><br><span class="line"><span class="function"><span class="keyword">public</span> <span class="keyword">boolean</span> <span class="title">onTouchEvent</span><span class="params">(MotionEvent ev)</span> </span>&#123;</span><br><span class="line">    <span class="keyword">boolean</span> handled = <span class="keyword">false</span>;</span><br><span class="line">    <span class="keyword">boolean</span> cancelSuper = <span class="keyword">false</span>;</span><br><span class="line">    MotionEvent cancelEvent = <span class="keyword">null</span>;</span><br><span class="line">    <span class="keyword">final</span> <span class="keyword">int</span> action = MotionEventCompat.getActionMasked(ev);</span><br><span class="line">    <span class="comment">// mBehaviorTouchView不为null（代表之前有behavior处理了down事件） 或者 performIntercept返回true 那么事件就交给mBehaviorTouchView</span></span><br><span class="line">    <span class="keyword">if</span> (mBehaviorTouchView != <span class="keyword">null</span> || (cancelSuper = performIntercept(ev, TYPE_ON_TOUCH))) &#123;</span><br><span class="line">        <span class="comment">// Safe since performIntercept guarantees that</span></span><br><span class="line">        <span class="comment">// mBehaviorTouchView != null if it returns true</span></span><br><span class="line">        <span class="keyword">final</span> LayoutParams lp = (LayoutParams) mBehaviorTouchView.getLayoutParams();</span><br><span class="line">        <span class="keyword">final</span> Behavior b = lp.getBehavior();</span><br><span class="line">        <span class="keyword">if</span> (b != <span class="keyword">null</span>) &#123;</span><br><span class="line">            <span class="comment">// 交给 behavior去处理事件  </span></span><br><span class="line">            handled = b.onTouchEvent(<span class="keyword">this</span>, mBehaviorTouchView, ev);</span><br><span class="line">        &#125;</span><br><span class="line">    &#125;</span><br><span class="line">    <span class="comment">// Keep the super implementation correct</span></span><br><span class="line">    <span class="comment">// 省略调用默认实现 up&amp;cancel的时候重置状态</span></span><br><span class="line">    <span class="comment">//...</span></span><br><span class="line">    <span class="keyword">return</span> handled;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure><p>可以看到，其实这两个方法做的事情并不多，其实都交给<code>performIntercept</code>方法去做处理了！</p><p><code>performIntercept</code>的实现如下：</p><figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br><span class="line">28</span><br><span class="line">29</span><br><span class="line">30</span><br><span class="line">31</span><br><span class="line">32</span><br><span class="line">33</span><br><span class="line">34</span><br><span class="line">35</span><br><span class="line">36</span><br><span class="line">37</span><br><span class="line">38</span><br><span class="line">39</span><br><span class="line">40</span><br><span class="line">41</span><br><span class="line">42</span><br><span class="line">43</span><br><span class="line">44</span><br><span class="line">45</span><br><span class="line">46</span><br><span class="line">47</span><br><span class="line">48</span><br><span class="line">49</span><br><span class="line">50</span><br><span class="line">51</span><br><span class="line">52</span><br><span class="line">53</span><br><span class="line">54</span><br><span class="line">55</span><br><span class="line">56</span><br><span class="line">57</span><br><span class="line">58</span><br><span class="line">59</span><br><span class="line">60</span><br><span class="line">61</span><br><span class="line">62</span><br><span class="line">63</span><br><span class="line">64</span><br><span class="line">65</span><br><span class="line">66</span><br></pre></td><td class="code"><pre><span class="line"><span class="comment">// type 标记是intercept还是touch</span></span><br><span class="line"><span class="function"><span class="keyword">private</span> <span class="keyword">boolean</span> <span class="title">performIntercept</span><span class="params">(MotionEvent ev, <span class="keyword">final</span> <span class="keyword">int</span> type)</span> </span>&#123;</span><br><span class="line">    <span class="keyword">boolean</span> intercepted = <span class="keyword">false</span>;</span><br><span class="line">    <span class="keyword">boolean</span> newBlock = <span class="keyword">false</span>;</span><br><span class="line">    MotionEvent cancelEvent = <span class="keyword">null</span>;</span><br><span class="line">    <span class="keyword">final</span> <span class="keyword">int</span> action = MotionEventCompat.getActionMasked(ev);</span><br><span class="line">    <span class="keyword">final</span> List&lt;View&gt; topmostChildList = mTempList1;</span><br><span class="line">    <span class="comment">//按Z轴排序 原因很简单 让最上面的View先处理事件  </span></span><br><span class="line">    getTopSortedChildren(topmostChildList);</span><br><span class="line">    <span class="comment">// Let topmost child views inspect first </span></span><br><span class="line">    <span class="keyword">final</span> <span class="keyword">int</span> childCount = topmostChildList.size();</span><br><span class="line">    <span class="keyword">for</span> (<span class="keyword">int</span> i = <span class="number">0</span>; i &lt; childCount; i++) &#123;</span><br><span class="line">        <span class="keyword">final</span> View child = topmostChildList.get(i);</span><br><span class="line">        <span class="keyword">final</span> LayoutParams lp = (LayoutParams) child.getLayoutParams();</span><br><span class="line">        <span class="keyword">final</span> Behavior b = lp.getBehavior();</span><br><span class="line">        <span class="comment">//当前事件已经被某个behavior拦截了（or newBlock），并且事件不为down，那么就发送一个 取消事件 给所有在拦截的behavior之后的behavior</span></span><br><span class="line">        <span class="keyword">if</span> ((intercepted || newBlock) &amp;&amp; action != MotionEvent.ACTION_DOWN) &#123;</span><br><span class="line">            <span class="comment">// Cancel all behaviors beneath the one that intercepted.</span></span><br><span class="line">            <span class="comment">// If the event is "down" then we don't have anything to cancel yet.</span></span><br><span class="line">            <span class="keyword">if</span> (b != <span class="keyword">null</span>) &#123;</span><br><span class="line">                <span class="keyword">if</span> (cancelEvent == <span class="keyword">null</span>) &#123;</span><br><span class="line">                    <span class="keyword">final</span> <span class="keyword">long</span> now = SystemClock.uptimeMillis();</span><br><span class="line">                    cancelEvent = MotionEvent.obtain(now, now,</span><br><span class="line">                            MotionEvent.ACTION_CANCEL, <span class="number">0.0f</span>, <span class="number">0.0f</span>, <span class="number">0</span>);</span><br><span class="line">                &#125;</span><br><span class="line">                <span class="keyword">switch</span> (type) &#123;</span><br><span class="line">                    <span class="keyword">case</span> TYPE_ON_INTERCEPT:</span><br><span class="line">                        b.onInterceptTouchEvent(<span class="keyword">this</span>, child, cancelEvent);</span><br><span class="line">                        <span class="keyword">break</span>;</span><br><span class="line">                    <span class="keyword">case</span> TYPE_ON_TOUCH:</span><br><span class="line">                        b.onTouchEvent(<span class="keyword">this</span>, child, cancelEvent);</span><br><span class="line">                        <span class="keyword">break</span>;</span><br><span class="line">                &#125;</span><br><span class="line">            &#125;</span><br><span class="line">            <span class="keyword">continue</span>;</span><br><span class="line">        &#125;</span><br><span class="line">        <span class="comment">// 如果还没有被拦截，那么继续询问每个Behavior 是否要处理该事件</span></span><br><span class="line">        <span class="keyword">if</span> (!intercepted &amp;&amp; b != <span class="keyword">null</span>) &#123;</span><br><span class="line">            <span class="keyword">switch</span> (type) &#123;</span><br><span class="line">                <span class="keyword">case</span> TYPE_ON_INTERCEPT:</span><br><span class="line">                    intercepted = b.onInterceptTouchEvent(<span class="keyword">this</span>, child, ev);</span><br><span class="line">                    <span class="keyword">break</span>;</span><br><span class="line">                <span class="keyword">case</span> TYPE_ON_TOUCH:</span><br><span class="line">                    intercepted = b.onTouchEvent(<span class="keyword">this</span>, child, ev);</span><br><span class="line">                    <span class="keyword">break</span>;</span><br><span class="line">            &#125;</span><br><span class="line">            <span class="comment">//如果有behavior处理了当前的事件，那么把它赋值给mBehaviorTouchView,它其实跟ViewGroup源码中的mFirstTouchTarget作用是一样的</span></span><br><span class="line">            <span class="keyword">if</span> (intercepted) &#123;</span><br><span class="line">                mBehaviorTouchView = child;</span><br><span class="line">            &#125;</span><br><span class="line">        &#125;</span><br><span class="line">        <span class="comment">// Don't keep going if we're not allowing interaction below this.</span></span><br><span class="line">        <span class="comment">// Setting newBlock will make sure we cancel the rest of the behaviors.</span></span><br><span class="line">        <span class="comment">// 是否拦截一切在它之后的交互 好暴力-0-</span></span><br><span class="line">        <span class="keyword">final</span> <span class="keyword">boolean</span> wasBlocking = lp.didBlockInteraction();</span><br><span class="line">        <span class="keyword">final</span> <span class="keyword">boolean</span> isBlocking = lp.isBlockingInteractionBelow(<span class="keyword">this</span>, child);</span><br><span class="line">        newBlock = isBlocking &amp;&amp; !wasBlocking;</span><br><span class="line">        <span class="keyword">if</span> (isBlocking &amp;&amp; !newBlock) &#123;</span><br><span class="line">            <span class="comment">// Stop here since we don't have anything more to cancel - we already did</span></span><br><span class="line">            <span class="comment">// when the behavior first started blocking things below this point.</span></span><br><span class="line">            <span class="keyword">break</span>;</span><br><span class="line">        &#125;</span><br><span class="line">    &#125;</span><br><span class="line">    topmostChildList.clear();</span><br><span class="line">    <span class="keyword">return</span> intercepted;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure><p>通过分析源码，可以知道，Col在关键的方法里把处理权优先交给了Behavior，所以才让Behavior拥有了拦截一切的能力，所以，原来是Col放任了Behavior！！~</p>]]></content>
    
    <summary type="html">
    
      &lt;h1 id=&quot;一步一步深入理解CoordinatorLayout&quot;&gt;&lt;a href=&quot;#一步一步深入理解CoordinatorLayout&quot; class=&quot;headerlink&quot; title=&quot;一步一步深入理解CoordinatorLayout&quot;&gt;&lt;/a&gt;一步一步深入理解CoordinatorLayout&lt;/h1&gt;&lt;h2 id=&quot;初步了解&quot;&gt;&lt;a href=&quot;#初步了解&quot; class=&quot;headerlink&quot; title=&quot;初步了解&quot;&gt;&lt;/a&gt;初步了解&lt;/h2&gt;&lt;p&gt;学习最好的习惯就是看官方文档，来看看Col的定义以及官网的介绍：&lt;/p&gt;
&lt;figure class=&quot;highlight java&quot;&gt;&lt;table&gt;&lt;tr&gt;&lt;td class=&quot;gutter&quot;&gt;&lt;pre&gt;&lt;span class=&quot;line&quot;&gt;1&lt;/span&gt;&lt;br&gt;&lt;span class=&quot;line&quot;&gt;2&lt;/span&gt;&lt;br&gt;&lt;/pre&gt;&lt;/td&gt;&lt;td class=&quot;code&quot;&gt;&lt;pre&gt;&lt;span class=&quot;line&quot;&gt;&lt;span class=&quot;keyword&quot;&gt;public&lt;/span&gt; &lt;span class=&quot;class&quot;&gt;&lt;span class=&quot;keyword&quot;&gt;class&lt;/span&gt; &lt;span class=&quot;title&quot;&gt;CoordinatorLayout&lt;/span&gt;&lt;/span&gt;&lt;/span&gt;&lt;br&gt;&lt;span class=&quot;line&quot;&gt;&lt;span class=&quot;class&quot;&gt;&lt;span class=&quot;keyword&quot;&gt;extends&lt;/span&gt; &lt;span class=&quot;title&quot;&gt;ViewGroup&lt;/span&gt; &lt;span class=&quot;keyword&quot;&gt;implements&lt;/span&gt; &lt;span class=&quot;title&quot;&gt;NestedScrollingParent&lt;/span&gt;&lt;/span&gt;&lt;/span&gt;&lt;br&gt;&lt;/pre&gt;&lt;/td&gt;&lt;/tr&gt;&lt;/table&gt;&lt;/figure&gt;
&lt;blockquote&gt;
&lt;p&gt;CoordinatorLayout is a super-powered FrameLayout.&lt;br&gt;CoordinatorLayout is intended for two primary use cases:&lt;/p&gt;
&lt;ol&gt;
&lt;li&gt;As a top-level application decor or chrome layout&lt;/li&gt;
&lt;li&gt;As a container for a specific interaction with one or more child views&lt;/li&gt;
&lt;/ol&gt;
&lt;/blockquote&gt;
&lt;p&gt;从定义可以看到Col继承自&lt;code&gt;ViewGroup&lt;/code&gt;，并且它被设计成一个&lt;code&gt;top-level&lt;/code&gt;的根布局，它本身只是一个ViewGroup，实现了&lt;code&gt;NestedScrollingParent&lt;/code&gt;接口，看似非常普通，&lt;br&gt;但是说&lt;code&gt;CoordinatorLayout&lt;/code&gt;是Design库&lt;strong&gt;最为重要的控件&lt;/strong&gt;也不为过。&lt;/p&gt;
    
    </summary>
    
      <category term="android" scheme="http://yoursite.com/categories/android/"/>
    
    
      <category term="CoordinatorLayout" scheme="http://yoursite.com/tags/CoordinatorLayout/"/>
    
  </entry>
  
  <entry>
    <title>构建 Android App 的30条宝贵经验</title>
    <link href="http://yoursite.com/2017/03/23/%E3%80%90%E8%AF%91%E3%80%91%E6%9E%84%E5%BB%BA%20Android%20App%20%E7%9A%8430%E6%9D%A1%E5%AE%9D%E8%B4%B5%E7%BB%8F%E9%AA%8C/"/>
    <id>http://yoursite.com/2017/03/23/【译】构建 Android App 的30条宝贵经验/</id>
    <published>2017-03-23T01:30:00.000Z</published>
    <updated>2017-03-24T03:19:22.000Z</updated>
    
    <content type="html"><![CDATA[<h1 id="【译】构建-Android-App-的30条宝贵经验"><a href="#【译】构建-Android-App-的30条宝贵经验" class="headerlink" title="【译】构建 Android App 的30条宝贵经验"></a>【译】构建 Android App 的30条宝贵经验</h1><p>做任何事都有两种人，一种是自己很努力去做的，还一种是听从他人意见建议做的。这里有我一些总结的经验，希望能帮到你们：</p><ul><li><p>导入任何第三方包的时候都要再三思考，因为这个动作<strong>责任</strong>重大。</p></li><li><p><a href="http://riggaroo.co.za/optimizing-layouts-in-android-reducing-overdraw/" target="_blank" rel="noopener">不要去绘制用户看不见的地方</a>。</p></li><li><p><strong>再三考虑</strong>数据库的使用对业务是不是必要的。</p></li><li><p><code>65535</code>问题很快就会遇到，<a href="https://medium.com/@rotxed/dex-skys-the-limit-no-65k-methods-is-28e6cb40cf71#.ook785i7j" target="_blank" rel="noopener">这里</a>可以助你渡劫。</p></li><li><p>替代<a href="https://medium.com/swlh/party-tricks-with-rxjava-rxandroid-retrolambda-1b06ed7cd29c#.cw2c751gf" target="_blank" rel="noopener">异步任务</a>最好的东西是<code>RxJava</code>，没有之一。</p><a id="more"></a></li><li><p><a href="http://square.github.io/retrofit/" target="_blank" rel="noopener">Retrofit</a>是目前最好的网络请求框架。</p></li><li><p>可以使用<a href="https://android.jlelse.eu/retrolambda-on-android-191cc8151f85#.27omjkgum" target="_blank" rel="noopener">Retrolambda</a>来简化你的代码。</p></li><li><p><a href="https://medium.com/swlh/party-tricks-with-rxjava-rxandroid-retrolambda-1b06ed7cd29c#.w97b058pe" target="_blank" rel="noopener">RxJava+Retrofit+Retrolambda</a>组合起来使用简直不能更爽。</p></li><li><p><a href="https://github.com/greenrobot/EventBus" target="_blank" rel="noopener">EventBus</a>是个很好的消息总线库，我也用它，但是我<strong>不会过于依赖</strong>，因为大量使用这货会导致你的代码<strong>艰涩难懂，逻辑凌乱不堪</strong>，请<strong>慎用</strong>这货，包括<code>RxBus</code>。</p></li><li><p><a href="https://medium.com/@cesarmcferreira/package-by-features-not-layers-2d076df1964d#.phormee79" target="_blank" rel="noopener">分包按功能特点分，不要按业务层分</a>。</p></li><li><p>主线程不要做耗时操作。</p></li><li><p>使用<a href="https://developer.android.com/studio/write/lint.html" target="_blank" rel="noopener">lint</a>可以帮助你优化布局和布局层次，减少一些无必要的布局or控件。</p></li><li><p>如果你使用<code>Gradle</code>，那么尽可能去<a href="https://android.jlelse.eu/speeding-up-gradle-builds-619c442113cb#.svga2houv" target="_blank" rel="noopener">加速编译</a>。</p></li><li><p>开启<a href="https://android.jlelse.eu/speeding-up-gradle-builds-619c442113cb#.n4jpczxpq" target="_blank" rel="noopener">编译报告</a>，看看编译过程中的耗时统计。</p></li><li><p>在架构上尽量采用<a href="https://fernandocejas.com/2015/07/18/architecting-android-the-evolution/" target="_blank" rel="noopener">大众化</a>的。</p></li><li><p><a href="http://stackoverflow.com/questions/67299/is-unit-testing-worth-the-effort/67500#67500" target="_blank" rel="noopener">测试是虽然费事费时，但是相比不要测试而言，你解决Bug的时候会更快，代码也更具健壮性。</a></p></li><li><p>使用<a href="https://fernandocejas.com/2015/04/11/tasting-dagger-2-on-android/" target="_blank" rel="noopener">依赖注入</a>能让你的app更模块化更好测试。</p></li><li><p>订阅<a href="http://fragmentedpodcast.com/" target="_blank" rel="noopener">这个网站</a>的内容对你大有裨益。</p></li><li><p><a href="https://www.reddit.com/r/Android/comments/2hywu9/google_play_only_one_strike_is_needed_to_ruin_you/" target="_blank" rel="noopener">坚决不要使用个人邮箱作为应用商店平台的账户，当然也包括一些第三方服务提供商。</a></p></li><li><p>在使用<code>EditText</code>时，使用<a href="https://developer.android.com/training/keyboard-input/style.html" target="_blank" rel="noopener">合适的</a>输入类型。</p></li><li><p>使用 <code>Android Studio -&gt; Analyze</code> 去分析和定位bug。</p></li><li><p>经常关注一些比较新的技术和<a href="https://android-arsenal.com/" target="_blank" rel="noopener">库</a>。例如<a href="https://github.com/cesarferreira/dryrun" target="_blank" rel="noopener">dryrun</a>这个库可以帮你减少构建远程仓库项目的时间。PS：我自己就在用，简直不能更爽。</p></li><li><p><code>Service</code>只做它应该做的，并且在需要它销毁的时候尽快能销毁。</p></li><li><p>使用<a href="https://developer.android.com/reference/android/accounts/AccountManager.html" target="_blank" rel="noopener">AccountManager</a>针对用户名和邮箱啥的提供建议。</p></li><li><p>使用<code>CI (Continuous Integration)</code>来构建和描述自己的beta版以及正式版apk。</p></li><li><p>不要运行自己的<code>CI</code>服务器，维护服务器很耗时，因为将有<code>磁盘空间/安全问题/更新服务器以防止SSL攻击</code>等等各种柴犬二哈问题在等着你。使用<code>circleci</code>，<code>travis</code>或<code>shippable</code>，它们便宜并且让你少操心。</p></li><li><p><a href="https://github.com/Triple-T/gradle-play-publisher" target="_blank" rel="noopener">发布app的时候可以使用自动部署。</a></p></li><li><p>你需要导入某个库，但是这个库特别大，而你只需要其中一小部分功能，那么你应该去找个更小的，更符合自己的库（<a href="https://developer.android.com/studio/build/shrink-code.html" target="_blank" rel="noopener">proguard</a>可以压缩资源）。</p></li><li><p>不要依赖导入过多的<code>modules</code>除非你真的需要。因为过多的<code>modules</code>会导致构建变慢(CI就是个例子)，这比起直接使用二进制的<code>.jar/.aar</code>来说要慢4倍左右。</p></li><li><p>可以考虑将<code>.PNG</code>替换成<code>.SVG</code>了。</p></li><li><p>library中抽象类能比较便捷的控制和替换使用场景（例如：<code>AppLogger.d(“message”)</code> 中包括了 <code>Log.d(TAG, message)</code>并且还能优化成 <code>Timber.d(message)</code>）。</p></li><li><p>监控网络连接和连接的类型你会发现-&gt;<code>wifi</code>连接下可能刷新数据更频繁。</p></li><li><p>监控电量和电池你会发现-&gt;充电时候数据可能更新更频繁，低电量的时候数据更新很慢。</p></li><li><p><strong>用户交互界面就是个笑话，除非你能讲解出来，否则它绝对不够好。</strong></p></li><li><p><a href="https://twitter.com/danlew42/status/677151453476032512" target="_blank" rel="noopener">测试非常适合于性能上的调优：慢慢地（但正确）写一些实现，然后验证优化并且也不会破坏测试。</a></p></li></ul>]]></content>
    
    <summary type="html">
    
      &lt;h1 id=&quot;【译】构建-Android-App-的30条宝贵经验&quot;&gt;&lt;a href=&quot;#【译】构建-Android-App-的30条宝贵经验&quot; class=&quot;headerlink&quot; title=&quot;【译】构建 Android App 的30条宝贵经验&quot;&gt;&lt;/a&gt;【译】构建 Android App 的30条宝贵经验&lt;/h1&gt;&lt;p&gt;做任何事都有两种人，一种是自己很努力去做的，还一种是听从他人意见建议做的。这里有我一些总结的经验，希望能帮到你们：&lt;/p&gt;
&lt;ul&gt;
&lt;li&gt;&lt;p&gt;导入任何第三方包的时候都要再三思考，因为这个动作&lt;strong&gt;责任&lt;/strong&gt;重大。&lt;/p&gt;
&lt;/li&gt;
&lt;li&gt;&lt;p&gt;&lt;a href=&quot;http://riggaroo.co.za/optimizing-layouts-in-android-reducing-overdraw/&quot; target=&quot;_blank&quot; rel=&quot;noopener&quot;&gt;不要去绘制用户看不见的地方&lt;/a&gt;。&lt;/p&gt;
&lt;/li&gt;
&lt;li&gt;&lt;p&gt;&lt;strong&gt;再三考虑&lt;/strong&gt;数据库的使用对业务是不是必要的。&lt;/p&gt;
&lt;/li&gt;
&lt;li&gt;&lt;p&gt;&lt;code&gt;65535&lt;/code&gt;问题很快就会遇到，&lt;a href=&quot;https://medium.com/@rotxed/dex-skys-the-limit-no-65k-methods-is-28e6cb40cf71#.ook785i7j&quot; target=&quot;_blank&quot; rel=&quot;noopener&quot;&gt;这里&lt;/a&gt;可以助你渡劫。&lt;/p&gt;
&lt;/li&gt;
&lt;li&gt;&lt;p&gt;替代&lt;a href=&quot;https://medium.com/swlh/party-tricks-with-rxjava-rxandroid-retrolambda-1b06ed7cd29c#.cw2c751gf&quot; target=&quot;_blank&quot; rel=&quot;noopener&quot;&gt;异步任务&lt;/a&gt;最好的东西是&lt;code&gt;RxJava&lt;/code&gt;，没有之一。&lt;/p&gt;
    
    </summary>
    
      <category term="android" scheme="http://yoursite.com/categories/android/"/>
    
    
  </entry>
  
  <entry>
    <title>android5.0和6.0新特性</title>
    <link href="http://yoursite.com/2017/02/09/android5.0%E5%92%8C6.0%E6%96%B0%E7%89%B9%E6%80%A7/"/>
    <id>http://yoursite.com/2017/02/09/android5.0和6.0新特性/</id>
    <published>2017-02-09T01:30:00.000Z</published>
    <updated>2017-03-24T02:29:26.000Z</updated>
    
    <content type="html"><![CDATA[<h2 id="Android-5-0新特性"><a href="#Android-5-0新特性" class="headerlink" title="Android 5.0新特性"></a>Android 5.0新特性</h2><h3 id="1-了解Material-Design"><a href="#1-了解Material-Design" class="headerlink" title="1. 了解Material Design"></a>1. 了解Material Design</h3><ul><li><p>概念：融合卡片式，立体式的设计风格,强调层次感，动画，阴影等元素</p></li><li><p>国内翻译介绍：查看 <a href="http://design.1sters.com/" target="_blank" rel="noopener">http://design.1sters.com</a></p></li><li><p>官网介绍：<a href="http://developer.android.com/training/material" target="_blank" rel="noopener">http://developer.android.com/training/material</a></p></li><li><p>演示Android5.0 Demo</p></li><li><p>Android UI样式风格发展：2.3版本(黄色丑陋版)-&gt;4.0(Holo)-&gt;5.0(MaterialDesign)</p><a id="more"></a></li></ul><h3 id="2-动态替换Theme"><a href="#2-动态替换Theme" class="headerlink" title="2. 动态替换Theme"></a>2. 动态替换Theme</h3><ul><li><p>MaterialTheme配色方案：<a href="http://www.materialpalette.com/" target="_blank" rel="noopener">http://www.materialpalette.com</a></p></li><li><p>修改状态栏，ActionBar，界面背景，NavigationBar的颜色。让Activity使用自定义的Theme。</p><figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br></pre></td><td class="code"><pre><span class="line">&lt;style name=&quot;AppTheme&quot; parent=&quot;@android:style/Theme.Material&quot;&gt;</span><br><span class="line">    &lt;!--状态栏颜色--&gt;</span><br><span class="line">    &lt;item name=&quot;android:colorPrimaryDark&quot;&gt;#f00&lt;/item&gt;</span><br><span class="line">    &lt;!--ActionBar颜色--&gt;</span><br><span class="line">    &lt;item name=&quot;android:colorPrimary&quot;&gt;#ff0&lt;/item&gt;</span><br><span class="line">    &lt;!--界面背景颜色--&gt;</span><br><span class="line">    &lt;item name=&quot;android:windowBackground&quot;&gt;@color/colorWindowBackground&lt;/item&gt;</span><br><span class="line">    &lt;!--导航栏颜色--&gt;</span><br><span class="line">    &lt;item name=&quot;android:navigationBarColor&quot;&gt;#00f&lt;/item&gt;</span><br><span class="line">&lt;/style&gt;</span><br></pre></td></tr></table></figure></li><li><p>动态替换Theme的步骤：</p><ul><li><p>定义至少2套theme</p></li><li><p>调用setTheme方法设置当前的theme，但是该方法要在setContentView之前，如:</p><figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br></pre></td><td class="code"><pre><span class="line">setTheme(mTheme);</span><br><span class="line">setContentView(R.layout.activity_main);</span><br></pre></td></tr></table></figure></li><li><p>设置了Theme，需要finish当前Activity，然后重启当前Activity，让Theme生效</p><figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br></pre></td><td class="code"><pre><span class="line">Intent intent = getActivity().getIntent();</span><br><span class="line">getActivity().finish();//结束当前的Activity</span><br><span class="line">getActivity().overridePendingTransition(0,0);//不要动画</span><br><span class="line">startActivity(intent);</span><br></pre></td></tr></table></figure></li></ul></li></ul><h3 id="3-View的高度与阴影"><a href="#3-View的高度与阴影" class="headerlink" title="3. View的高度与阴影"></a>3. View的高度与阴影</h3><ul><li><p>官网介绍：<a href="https://developer.android.com/intl/zh-tw/training/material/shadows-clipping.html" target="_blank" rel="noopener">https://developer.android.com/intl/zh-tw/training/material/shadows-clipping.html</a></p></li><li><p>View新增属性z轴，用来体现Material Design中的层次，影响因素2个：elevation 和 translationZ</p><figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><span class="line">View高度 = elevation + translationZ</span><br></pre></td></tr></table></figure><ul><li><p>elevation表示view的高度，高度越大，阴影越大，可以在xml中直接使用属性， 也可以在代码中使用view.setEvelvation();</p><figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><span class="line">android:elevation=&quot;10dp&quot;</span><br></pre></td></tr></table></figure></li><li><p>transtionZ属性表示view在Z方向移动的距离，一般用于属性动画中</p><figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><span class="line">android:translationZ=&quot;10dp&quot;</span><br></pre></td></tr></table></figure></li></ul></li><li><p>高度影响View的绘制顺序，过去是按View添加顺序绘制，先添加的先绘制，现在高度小的先绘制，因为高度小的，层级低，在下面， 高度相同的，按添加顺序绘制</p></li><li><p>注意：</p><ul><li>如果View的背景色为透明，则不会显示出阴影效果</li><li>只有子View的大小比父View小时，阴影才能显示出来</li></ul></li></ul><h3 id="4-View的轮廓与裁剪-在Android5-1以及以上才有效果"><a href="#4-View的轮廓与裁剪-在Android5-1以及以上才有效果" class="headerlink" title="4. View的轮廓与裁剪(在Android5.1以及以上才有效果)"></a>4. View的轮廓与裁剪(在Android5.1以及以上才有效果)</h3><ul><li><p>官网介绍：<a href="https://developer.android.com/intl/zh-tw/training/material/shadows-clipping.html" target="_blank" rel="noopener">https://developer.android.com/intl/zh-tw/training/material/shadows-clipping.html</a></p></li><li><p>View增加了轮廓概念,轮廓用来表示怎么显示阴影,也就是说轮廓什么形状，阴影就显示什么形状。</p><ul><li><p>View的轮廓可以通过outlineProvider属性设置，默认是依据于background的，还有其他3个取值：bounds,none,paddingBounds</p><figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><span class="line">android:outlineProvider=&quot;bounds&quot;</span><br></pre></td></tr></table></figure><figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br></pre></td><td class="code"><pre><span class="line">none：即使设置了evaluation也不显示阴影</span><br><span class="line">background：按背景来显示轮廓，如果background是颜色值，则轮廓就是view的大小，如果是shape，则按shape指定的形状作为轮廓</span><br><span class="line">bounds: View的矩形大小作轮廓</span><br><span class="line">paddedBounds: View的矩形大小减去padding的值后的大小作轮廓。</span><br></pre></td></tr></table></figure></li><li><p>可以通过setOutlineProvider()方法自定义轮廓:</p><figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br></pre></td><td class="code"><pre><span class="line">tv_blue.setOutlineProvider(new ViewOutlineProvider() &#123;</span><br><span class="line">        @TargetApi(Build.VERSION_CODES.LOLLIPOP)</span><br><span class="line">        @Override</span><br><span class="line">        public void getOutline(View view, Outline outline) &#123;</span><br><span class="line">            outline.setOval(0,0,</span><br><span class="line">                    view.getWidth(),view.getHeight());</span><br><span class="line">        &#125;</span><br><span class="line">    &#125;);</span><br></pre></td></tr></table></figure></li><li><p>注意：如果background是图片，那只能通过代码setOutlineProvider()来指定轮廓</p></li></ul></li><li><p>View的裁剪是指将View按照轮廓裁剪，能改变View的形状，如圆形头像：</p><ul><li><p>先设置轮廓:</p></li><li><p>再设置根据轮廓裁剪View,目前只支持对矩形，圆形，圆角矩形的裁剪:</p><figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br></pre></td><td class="code"><pre><span class="line">//设置对View进行裁剪</span><br><span class="line">tv_clip.setClipToOutline(true);</span><br></pre></td></tr></table></figure></li></ul></li></ul><h3 id="5-Palette的使用"><a href="#5-Palette的使用" class="headerlink" title="5. Palette的使用"></a>5. Palette的使用</h3><ul><li><p>使用Palette可以让我们从一张图片中拾取颜色，将拾取到的颜色赋予ActionBar，StatusBar以及背景色可以让界面色调实现统一</p></li><li><p>使用Palette需要添加以下依赖：</p><figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><span class="line">compile &apos;com.android.support:palette-v7:23.0.0+&apos;</span><br></pre></td></tr></table></figure></li><li><p>Palette提供的API</p><ul><li><p>传入Bitmap即可获取Palette对象,以下是同步和异步使用方式:</p><figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br></pre></td><td class="code"><pre><span class="line">//同步获取，需要在子线程中使用</span><br><span class="line">Palette palette = Palette.from(drawable.getBitmap()).generate();</span><br><span class="line">//异步获取，可以在主线程中使用</span><br><span class="line">Palette.from(drawable.getBitmap()).generate(new Palette.PaletteAsyncListener() &#123;</span><br><span class="line">    @Override</span><br><span class="line">    public void onGenerated(Palette palette) &#123;</span><br><span class="line">        //...</span><br><span class="line">    &#125;</span><br><span class="line">&#125;);</span><br></pre></td></tr></table></figure></li><li><p>得到Palette对象后，获取其中的颜色，颜色对应如下：</p><figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br></pre></td><td class="code"><pre><span class="line">vibrant      -  有活力的颜色</span><br><span class="line">lightVibrant -  有活力的亮色</span><br><span class="line">darkVibrant  -  有活力的暗色</span><br><span class="line">muted        -  柔和暗淡的颜色</span><br><span class="line">lightMuted   -  柔和的亮色</span><br><span class="line">darkMuted    -  柔和的暗色</span><br></pre></td></tr></table></figure></li><li><p>获取指定颜色的采样对象，获取采样得到的颜色:</p><figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br></pre></td><td class="code"><pre><span class="line">//我们可以直接使用palette获取指定颜色：</span><br><span class="line">palette.getLightMutedColor(defaultColor);</span><br><span class="line"></span><br><span class="line">//一般也可以先获取采样对象Swatch,从Swatch中获取我们需要的颜色:</span><br><span class="line">//获取有活力颜色的采样对象</span><br><span class="line">Palette.Swatch vibrantSwatch = palette.getVibrantSwatch();</span><br></pre></td></tr></table></figure></li><li><p>采样对象Swatch提供了以下方法来获取颜色：</p><figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br></pre></td><td class="code"><pre><span class="line">//swatch.getPopulation(): the amount of pixels which this swatch represents.</span><br><span class="line">//swatch.getRgb(): the RGB value of this color.</span><br><span class="line">//swatch.getHsl(): the HSL value of this color，即色相，饱和度，明度.</span><br><span class="line">//swatch.getBodyTextColor(): the RGB value of a text color which can be displayed on top of this color.</span><br><span class="line">//swatch.getTitleTextColor(): the RGB value of a text color which can be displayed on top of this color</span><br><span class="line">//一般会将getRgb设置给控件背景色，getBodyTextColor()设置给文字颜色</span><br><span class="line">textView.setBackgroundColor(vibrantSwatch.getRgb());</span><br><span class="line">textView.setTextColor(vibrantSwatch.getBodyTextColor());</span><br></pre></td></tr></table></figure></li></ul></li></ul><h3 id="6-水波纹动画，自定义水波纹动画以及状态选择器动画"><a href="#6-水波纹动画，自定义水波纹动画以及状态选择器动画" class="headerlink" title="6. 水波纹动画，自定义水波纹动画以及状态选择器动画"></a>6. 水波纹动画，自定义水波纹动画以及状态选择器动画</h3><ul><li><p>首先，在Android5.0以上，点击效果默认自带水波纹效果，并且有2种选择：</p><figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br></pre></td><td class="code"><pre><span class="line">//矩形边框水波纹</span><br><span class="line">android:background=&quot;?android:attr/selectableItemBackground&quot;</span><br><span class="line">//无边框限制水波纹</span><br><span class="line">android:background=&quot;?android:attr/selectableItemBackgroundBorderless&quot;</span><br></pre></td></tr></table></figure></li><li><p>自定义水波纹动画</p><ul><li><p>使用ViewAnimationUtils创建圆形水波纹动画，注意该动画不能在Activity的onCreate方法中执行：</p><figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br></pre></td><td class="code"><pre><span class="line">Animator circularReveal = ViewAnimationUtils.createCircularReveal(text, 0, text.getHeight() , 1f, text.getWidth()*2);</span><br><span class="line">circularReveal.setDuration(1000);</span><br><span class="line">circularReveal.start();</span><br></pre></td></tr></table></figure></li><li><p>使用ripple标签或者RippleDrawable可以更改控件水波纹动画颜色：</p><figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br></pre></td><td class="code"><pre><span class="line">&lt;ripple xmlns:android=&quot;http://schemas.android.com/apk/res/android&quot; android:color=&quot;#00ff00&quot;&gt;</span><br><span class="line">&lt;item android:id=&quot;@android:id/mask&quot; &gt;&lt;color android:color=&quot;#0000ff&quot; /&gt;</span><br></pre></td></tr></table></figure></li></ul><p>​</p></li><li><p>定义带有属性动画的状态选择器</p><ul><li><p>通过stateListAnimator属性指定状态选择器的动画：</p><figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><span class="line">android:stateListAnimator=&quot;@drawable/selector_anim&quot;</span><br></pre></td></tr></table></figure></li><li><p>状态选择器文件中需要加入objectAnimator标签：</p><figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br></pre></td><td class="code"><pre><span class="line">&lt;selector  xmlns:android = &quot;http://schemas.android.com/apk/res/android&quot; &gt;</span><br><span class="line">&lt;item  android:statepressed = &quot;true&quot; &gt;</span><br><span class="line">&lt;objectAnimator  android:propertyName = &quot;scaleX&quot;</span><br><span class="line">        android:duration = &quot;@android:integer/configshortAnimTime&quot;</span><br><span class="line">        android:valueTo = &quot;0.2&quot;</span><br><span class="line">        android:valueFrom = &quot;1&quot;</span><br><span class="line">        android:valueType = &quot;floatType&quot; &gt;</span><br><span class="line">//...</span><br></pre></td></tr></table></figure></li><li><p>同样，状态选择器动画可以用代码方式加载</p><figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br></pre></td><td class="code"><pre><span class="line">//加载动画</span><br><span class="line">AnimatorInflater.loadStateListAnimator();</span><br><span class="line">//设置动画</span><br><span class="line">View.setStateListAnimator();</span><br></pre></td></tr></table></figure></li></ul></li><li><p>定义带有帧动画的状态选择器，需要设置给background属性，不是stateListAnimator，如下所示:</p><figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br></pre></td><td class="code"><pre><span class="line">&lt;animated-selector  xmlns:android = &quot;http://schemas.android.com/apk/res/android&quot; &gt; </span><br><span class="line">&lt;item  android:id = &quot;@+id/pressed&quot;  android:drawable = &quot;@drawable/drawableP&quot; </span><br><span class="line">    android:state_pressed = &quot;true&quot; /&gt; </span><br><span class="line">&lt;item  android:id = &quot;@id/default&quot; </span><br><span class="line">    android:drawable = &quot;@drawable/drawableD&quot; /&gt; </span><br><span class="line">&lt;!-- 指定帧动画 - -&gt; </span><br><span class="line">&lt;transition  android:fromId = &quot;@+id/default&quot;  android:toId = &quot;@+id/pressed&quot; &gt; </span><br><span class="line">    &lt;animation-list&gt; </span><br><span class="line">        &lt;item  android:duration = &quot;15&quot;  android:drawable = &quot;@drawable/dt1 &quot; /&gt; </span><br><span class="line">        &lt;item  android:duration = &quot;15&quot;  android:drawable = &quot;@drawable/dt2&quot; /&gt; </span><br><span class="line">        ... </span><br><span class="line">    &lt;/animation-list&gt; </span><br><span class="line"> &lt;/animated-selector&gt;</span><br></pre></td></tr></table></figure></li></ul><h3 id="7-CardView的使用"><a href="#7-CardView的使用" class="headerlink" title="7. CardView的使用"></a>7. CardView的使用</h3><ul><li><p>CardLayout拥有高度和阴影，以及轮廓裁剪，圆角等功能</p></li><li><p>各属性说明:</p><figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br></pre></td><td class="code"><pre><span class="line">1.设置圆角：card_view:cardCornerRadius=&quot;10dp&quot;</span><br><span class="line">2.设置高度：card_view:cardElevation=&quot;10dp&quot;</span><br><span class="line">3.设置内边距：card_view:contentPadding=&quot;10dp&quot;</span><br><span class="line">4.设置背景色：card_view:cardBackgroundColor=&quot;?android:attr/colorPrimary&quot;</span><br></pre></td></tr></table></figure></li></ul><h3 id="8-RecyclerView的使用"><a href="#8-RecyclerView的使用" class="headerlink" title="8. RecyclerView的使用"></a>8. RecyclerView的使用</h3><ul><li><a href="https://developer.android.com/intl/zh-tw/training/material/lists-cards.html" target="_blank" rel="noopener">https://developer.android.com/intl/zh-tw/training/material/lists-cards.html</a></li><li>先添加依赖 compile ‘com.android.support:recyclerview-v7:23.1.1’</li><li>设置LayoutManager：控制RecyclerView如何显示布局,系统提供3个布局管理器：<ul><li>LinearLayoutManager：线性布局，有横向和竖直方向显示</li><li>GridLayoutManager：网格布局，有横向和竖直方向显示</li><li>StaggeredGridLayoutManager： 瀑布流布局，有横向和竖直方向显示</li></ul></li><li>然后给RecyclerView设置Adapter&lt;RecyclerView.ViewHolder&gt;</li><li>设置点击事件，由于RecyclerView没有setOnItemClickListener，只能在Adapter中给View设置Click事件</li></ul><h3 id="9-ToolBar的使用"><a href="#9-ToolBar的使用" class="headerlink" title="9. ToolBar的使用"></a>9. ToolBar的使用</h3><ul><li><p>它用来代替ActionBar，但是比ActionBar更加灵活，相当于可以写在布局文件中的ActionBar；与DrawerLayout的使用的时候，DrawerLayout可以覆盖在ToolBar上，并且ToolBar和ActionBar不能同时使用</p></li><li><p>使用ToolBar的步骤：</p><ul><li><p>先隐藏ActionBar，可以继承一个不带ActionBar的Theme，如:</p><figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><span class="line">style name=&quot;AppTheme&quot; parent=&quot;Theme.AppCompat.Light.NoActionBar&quot;</span><br></pre></td></tr></table></figure></li><li><p>然后在Activity中设置ToolBar替代ActionBar：</p><figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><span class="line">setSupportActionBar(toolBar);</span><br></pre></td></tr></table></figure></li><li><p>最后设置ToolBar的显示内容：</p><figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br></pre></td><td class="code"><pre><span class="line">toolBar.setTitle(&quot;ToolBar&quot;);//设置标题</span><br><span class="line">toolBar.setNavigationIcon(iconRes);//设置图标</span><br><span class="line">toolBar.setOnMenuItemClickListener();//设置Menu Item点击</span><br></pre></td></tr></table></figure></li></ul></li></ul><h3 id="10-Android-5-0新特性的向下兼容"><a href="#10-Android-5-0新特性的向下兼容" class="headerlink" title="10. Android 5.0新特性的向下兼容"></a>10. Android 5.0新特性的向下兼容</h3><ul><li><p>可以通过Support Library使用的新特性可以向下兼容，如：</p><ul><li>RecyclerView (recyclerview-v7)</li><li>CardView (cardview-v7)</li><li>Palette颜色识别 (palette-v7)</li><li>ToolBar (appcompat-v7)</li><li>SwipeRefreshLayout (v4)</li></ul></li><li><p>定义针对版本的资源目录</p><ul><li>layout：使用新API的布局放在res/layout-v21中，其他的放res/layout</li><li>drawable：使用新属性的drawable文件放到 res/drawable-v21，其他的放 res/drawable</li><li>values: 新的主题放到 res/values-v21, 其他的放 res/values</li></ul></li><li><p>在代码中对系统Version做判断，使用对应的效果，如:</p><figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br></pre></td><td class="code"><pre><span class="line">if(Build.VERSION.SDK_INT&gt; 21)&#123;</span><br><span class="line">        //使用新动画</span><br><span class="line">        ...</span><br><span class="line">    &#125;</span><br></pre></td></tr></table></figure></li></ul><hr><h2 id="Android-6-0新控件"><a href="#Android-6-0新控件" class="headerlink" title="Android 6.0新控件"></a>Android 6.0新控件</h2><h3 id="1-TextInputLayout的使用"><a href="#1-TextInputLayout的使用" class="headerlink" title="1. TextInputLayout的使用"></a>1. TextInputLayout的使用</h3><ul><li><p>高级炫酷带有提示的输入框，相当于输入框中的战斗框</p></li><li><p>使用需要依赖design类库：</p><figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><span class="line">compile &apos;com.android.support:design:23.0.0+&apos;</span><br></pre></td></tr></table></figure></li><li><p>使用步骤：</p><ul><li><p>先在TextInputLayout中包裹一个EditText，如：</p></li><li><p>然后给EditText添加文本变化监听器：</p><figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br></pre></td><td class="code"><pre><span class="line"> editText.addTextChangedListener(new TextWatcher() &#123;</span><br><span class="line">@Override</span><br><span class="line">public void beforeTextChanged(CharSequence s, int start, int count, int after) &#123;</span><br><span class="line"></span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line">@Override</span><br><span class="line">public void onTextChanged(CharSequence s, int start, int before, int count) &#123;</span><br><span class="line"></span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line">@Override</span><br><span class="line">public void afterTextChanged(Editable s) &#123;</span><br><span class="line">    if(s.length() &gt; 5)&#123;</span><br><span class="line">        //设置错误提示信息</span><br><span class="line">        inputLayout.setError(&quot;不能超过5个&quot;);</span><br><span class="line">        //启用错误提示</span><br><span class="line">        inputLayout.setErrorEnabled(true);</span><br><span class="line">    &#125;else&#123;</span><br><span class="line">        //关闭错误提示</span><br><span class="line">        inputLayout.setErrorEnabled(false);</span><br><span class="line">    &#125;</span><br><span class="line">&#125;</span><br><span class="line">&#125;);</span><br></pre></td></tr></table></figure></li></ul></li></ul><h3 id="2-FloatingActionButton的使用"><a href="#2-FloatingActionButton的使用" class="headerlink" title="2. FloatingActionButton的使用"></a>2. FloatingActionButton的使用</h3><ul><li><p>总是能悬浮在界面上的Button，可以设置点击事件</p></li><li><p>使用需要依赖design类库：</p><figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><span class="line">compile &apos;com.android.support:design:23.0.0+&apos;</span><br></pre></td></tr></table></figure></li><li><p>可以设置以下属性：</p><figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br></pre></td><td class="code"><pre><span class="line">app:fabSize=&quot;normal&quot;//2个取值，normal=56dp,mini=48dp</span><br><span class="line">app:elevation=&quot;10dp&quot;//高度</span><br><span class="line">app:rippleColor=&quot;#0000ff&quot;//按下水波纹颜色</span><br><span class="line">app:pressedTranslationZ=&quot;20dp&quot;//按下Z轴移动距离  </span><br><span class="line">注意：设置android:clickable=&quot;true&quot;才有按下的效果</span><br></pre></td></tr></table></figure></li></ul><h3 id="3-Snackbar的使用"><a href="#3-Snackbar的使用" class="headerlink" title="3. Snackbar的使用"></a>3. Snackbar的使用</h3><ul><li>一个介于Toast和Dialog之间的和用户交互的控件，显示在界面底部，并且可以设置点击行为，也可以滑动出去</li><li>在和FloatingActionButton一起使用时，需要让CoordinatorLayout作为父布局才能使FloatingActionButton给SnackBar腾出空间</li></ul><h3 id="4-TabLayout的使用"><a href="#4-TabLayout的使用" class="headerlink" title="4. TabLayout的使用"></a>4. TabLayout的使用</h3><ul><li><p>相当于ViewPagerIndicator的指示器效果，一般用来跟ViewPager结合使用</p></li><li><p>使用需要依赖design类库：</p><figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><span class="line">compile &apos;com.android.support:design:23.0.0+&apos;</span><br></pre></td></tr></table></figure></li><li><p>单独使用TabLayout的步骤：</p><ul><li><p>先添加Tab，使用tabLayout.newTab()方法创建Tab：</p><figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br></pre></td><td class="code"><pre><span class="line">//1.添加Tab</span><br><span class="line">tabLayout.addTab(tabLayout.newTab().setText(&quot;Tab1&quot;));</span><br></pre></td></tr></table></figure></li><li><p>给tabLayout设置tab改变的监听器：</p><figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br></pre></td><td class="code"><pre><span class="line"> //2.给tabLayout添加tab改变的监听器</span><br><span class="line">tabLayout.setOnTabSelectedListener(new TabLayout.OnTabSelectedListener() &#123;</span><br><span class="line">    @Override</span><br><span class="line">    public void onTabSelected(TabLayout.Tab tab) &#123;</span><br><span class="line">        Log.e(&quot;TAG&quot;, &quot;onTabSelected: &quot;+tab.getText());</span><br><span class="line">    &#125;</span><br><span class="line">    @Override</span><br><span class="line">    public void onTabUnselected(TabLayout.Tab tab) &#123;</span><br><span class="line">    &#125;</span><br><span class="line">    @Override</span><br><span class="line">    public void onTabReselected(TabLayout.Tab tab) &#123;</span><br><span class="line">    &#125;</span><br><span class="line">&#125;);</span><br></pre></td></tr></table></figure></li><li><p>在xml中给TabLayout设置属性：</p><figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br></pre></td><td class="code"><pre><span class="line">app:tabIndicatorColor=&quot;#00f&quot;//横线颜色</span><br><span class="line">app:tabSelectedTextColor=&quot;#f00&quot;//选中字体颜色</span><br><span class="line">app:tabTextColor=&quot;#0f0&quot;//默认字体颜色</span><br><span class="line">app:tabMode=&quot;fixed&quot;//fixed：不能滑动，每个Tab平分宽度，scrollable:可以滑动tab，每个tab宽度很小，适用于tab很多的情景</span><br><span class="line">app:tabGravity=&quot;fill&quot;//fill:平分宽度，center:让tab居中,如果tabMode是scrollable，那tabGravity会被忽略</span><br></pre></td></tr></table></figure></li></ul></li><li><p>和ViewPager关联使用步骤：</p><ul><li><p>先给ViewPager填充数据，然后关联TabLayout和ViewPager：</p><figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br></pre></td><td class="code"><pre><span class="line">//给ViewPager填充数据</span><br><span class="line">viewpager.setAdapter(new MyAdapter());</span><br><span class="line">//关联TabLayout和ViewPager</span><br><span class="line">tabLayout.setupWithViewPager(viewpager);</span><br></pre></td></tr></table></figure></li><li><p>需要注意的是，ViewPager的adapter的getPageTitle()方法的返回值将会设置给Tab的标题</p></li></ul></li></ul><h3 id="5-CoordinatorLayout的使用"><a href="#5-CoordinatorLayout的使用" class="headerlink" title="5. CoordinatorLayout的使用"></a>5. CoordinatorLayout的使用</h3><ul><li><p>协调布局，能够协调多个布局的位置关系，可以实现让FAB上下滑动，展开或折叠ToolBar，控制View扩展收缩以及放大缩小</p></li><li><p>使用需要依赖design类库：</p><figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><span class="line">compile &apos;com.android.support:design:23.0.0+&apos;</span><br></pre></td></tr></table></figure></li><li><p>使用它结合AppBarLayout实现向上滑动隐藏ToolBar的效果：</p><ul><li><p>AppBarLayout会将包裹的所有子View作为一个整体的AppBar，有着统一的界面着色;</p></li><li><p>app:layout_scrollFlags属性介绍：</p><figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br></pre></td><td class="code"><pre><span class="line">scroll:表示该View可以被滑动出CoordinatorLayout的范围，所有想滚动出屏幕的view都需要设置这个flag， 没有设置这个flag的view将被固定在屏幕顶部。例如，TabLayout 没有设置这个值，将会停留在屏幕顶部</span><br><span class="line">enterAlways:表示任意向下的滚动都会导致该View可见</span><br><span class="line">exitUntilCollapsed:滚动退出屏幕，最后折叠在顶端</span><br><span class="line">enterAlwaysCollapsed:当你的视图已经设置minHeight属性又使用此标志时，你的视图只能以最小高度进入，只有当滚动视图到达顶部时才扩大到完整高度</span><br></pre></td></tr></table></figure></li><li><p>给想滑动出范围的View设置属性，比如ToolBar：</p><figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><span class="line">app:layout_scrollFlags=”scroll|enterAlways</span><br></pre></td></tr></table></figure></li><li><p>给发出滑动行为的View设置属性，比如ViewPager：</p><figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><span class="line">app:layout_behavior=&quot;@string/appbar_scrolling_view_behavior&quot;</span><br></pre></td></tr></table></figure></li><li><p>实现步骤：</p><figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br></pre></td><td class="code"><pre><span class="line">1.CoordinatorLayout作根控件，包裹AppBarLayout和可滚动的控件，比如ViewPager  </span><br><span class="line">2.AppBarLayout包裹 ToolBar 及TabLayout，  </span><br><span class="line">  ToolBar要滑动，给其设置app:layout_scrollFlags  </span><br><span class="line">3.ViewPager是发出滑动行为的控件，设置属性 app:layout_behavior  </span><br><span class="line">注意：带layout_scrollFlags的view需要放在固定View的前面，这样滑动的view才能够正常退出，而固定的view继续留在顶部</span><br></pre></td></tr></table></figure></li></ul></li></ul>]]></content>
    
    <summary type="html">
    
      &lt;h2 id=&quot;Android-5-0新特性&quot;&gt;&lt;a href=&quot;#Android-5-0新特性&quot; class=&quot;headerlink&quot; title=&quot;Android 5.0新特性&quot;&gt;&lt;/a&gt;Android 5.0新特性&lt;/h2&gt;&lt;h3 id=&quot;1-了解Material-Design&quot;&gt;&lt;a href=&quot;#1-了解Material-Design&quot; class=&quot;headerlink&quot; title=&quot;1. 了解Material Design&quot;&gt;&lt;/a&gt;1. 了解Material Design&lt;/h3&gt;&lt;ul&gt;
&lt;li&gt;&lt;p&gt;概念：融合卡片式，立体式的设计风格,强调层次感，动画，阴影等元素&lt;/p&gt;
&lt;/li&gt;
&lt;li&gt;&lt;p&gt;国内翻译介绍：查看 &lt;a href=&quot;http://design.1sters.com/&quot; target=&quot;_blank&quot; rel=&quot;noopener&quot;&gt;http://design.1sters.com&lt;/a&gt;&lt;/p&gt;
&lt;/li&gt;
&lt;li&gt;&lt;p&gt;官网介绍：&lt;a href=&quot;http://developer.android.com/training/material&quot; target=&quot;_blank&quot; rel=&quot;noopener&quot;&gt;http://developer.android.com/training/material&lt;/a&gt;&lt;/p&gt;
&lt;/li&gt;
&lt;li&gt;&lt;p&gt;演示Android5.0 Demo&lt;/p&gt;
&lt;/li&gt;
&lt;li&gt;&lt;p&gt;Android UI样式风格发展：2.3版本(黄色丑陋版)-&amp;gt;4.0(Holo)-&amp;gt;5.0(MaterialDesign)&lt;/p&gt;
    
    </summary>
    
      <category term="android" scheme="http://yoursite.com/categories/android/"/>
    
    
  </entry>
  
  <entry>
    <title>android api指南</title>
    <link href="http://yoursite.com/2017/02/08/android%20api%E6%8C%87%E5%8D%97/"/>
    <id>http://yoursite.com/2017/02/08/android api指南/</id>
    <published>2017-02-08T09:30:00.000Z</published>
    <updated>2017-03-24T02:24:58.000Z</updated>
    
    <content type="html"><![CDATA[<h1 id="Android-简介"><a href="#Android-简介" class="headerlink" title="Android 简介"></a>Android 简介</h1><p><a href="undefined">https://developer.android.google.cn/guide/index.html</a></p><h2 id="应用基础知识"><a href="#应用基础知识" class="headerlink" title="应用基础知识"></a>应用基础知识</h2><p><a href="undefined">https://developer.android.google.cn/guide/components/fundamentals.html</a></p><h2 id="设备兼容性-Device-Compatibility"><a href="#设备兼容性-Device-Compatibility" class="headerlink" title="设备兼容性 Device Compatibility"></a>设备兼容性 Device Compatibility</h2><p><a href="undefined">https://developer.android.google.cn/guide/practices/compatibility.html</a></p><h2 id="系统权限"><a href="#系统权限" class="headerlink" title="系统权限"></a>系统权限</h2><p><a href="undefined">https://developer.android.google.cn/guide/topics/security/permissions.html</a></p><a id="more"></a><h1 id="平台架构"><a href="#平台架构" class="headerlink" title="平台架构"></a>平台架构</h1><p><a href="undefined">https://developer.android.google.cn/guide/platform/index.html</a></p><h2 id="使用-Java-8-语言功能"><a href="#使用-Java-8-语言功能" class="headerlink" title="使用 Java 8 语言功能"></a>使用 Java 8 语言功能</h2><p><a href="undefined">https://developer.android.google.cn/guide/platform/j8-jack.html</a></p><h2 id="在-Android-Runtime-ART-上验证应用行为"><a href="#在-Android-Runtime-ART-上验证应用行为" class="headerlink" title="在 Android Runtime (ART) 上验证应用行为"></a>在 Android Runtime (ART) 上验证应用行为</h2><p><a href="undefined">https://developer.android.google.cn/guide/practices/verifying-apps-art.html</a></p><h1 id="应用组件"><a href="#应用组件" class="headerlink" title="应用组件"></a>应用组件</h1><p><a href="undefined">https://developer.android.google.cn/guide/components/index.html</a></p><h2 id="Intent-和-Intent-过滤器"><a href="#Intent-和-Intent-过滤器" class="headerlink" title="Intent 和 Intent 过滤器"></a>Intent 和 Intent 过滤器</h2><p><a href="undefined">https://developer.android.google.cn/guide/components/intents-filters.html</a></p><h3 id="通用-Intent"><a href="#通用-Intent" class="headerlink" title="通用 Intent"></a>通用 Intent</h3><p><a href="undefined">https://developer.android.google.cn/guide/components/intents-common.html</a></p><h2 id="Activity"><a href="#Activity" class="headerlink" title="Activity"></a>Activity</h2><p><a href="undefined">https://developer.android.google.cn/guide/components/activities.html</a></p><h3 id="片段"><a href="#片段" class="headerlink" title="片段"></a>片段</h3><p><a href="undefined">https://developer.android.google.cn/guide/components/fragments.html</a></p><h3 id="加载器"><a href="#加载器" class="headerlink" title="加载器"></a>加载器</h3><p><a href="undefined">https://developer.android.google.cn/guide/components/loaders.html</a></p><h3 id="任务和返回栈"><a href="#任务和返回栈" class="headerlink" title="任务和返回栈"></a>任务和返回栈</h3><p><a href="undefined">https://developer.android.google.cn/guide/components/tasks-and-back-stack.html</a></p><h3 id="概览屏幕"><a href="#概览屏幕" class="headerlink" title="概览屏幕"></a>概览屏幕</h3><p><a href="undefined">https://developer.android.google.cn/guide/components/recents.html</a></p><h2 id="服务"><a href="#服务" class="headerlink" title="服务"></a>服务</h2><p><a href="undefined">https://developer.android.google.cn/guide/components/services.html</a></p><h3 id="绑定服务"><a href="#绑定服务" class="headerlink" title="绑定服务"></a>绑定服务</h3><p><a href="undefined">https://developer.android.google.cn/guide/components/bound-services.html</a></p><h3 id="Android-接口定义语言-AIDL"><a href="#Android-接口定义语言-AIDL" class="headerlink" title="Android 接口定义语言 (AIDL)"></a>Android 接口定义语言 (AIDL)</h3><p><a href="undefined">https://developer.android.google.cn/guide/components/aidl.html</a></p><h2 id="内容提供程序"><a href="#内容提供程序" class="headerlink" title="内容提供程序"></a>内容提供程序</h2><p><a href="undefined">https://developer.android.google.cn/guide/topics/providers/content-providers.html</a></p><h3 id="内容提供程序基础知识"><a href="#内容提供程序基础知识" class="headerlink" title="内容提供程序基础知识"></a>内容提供程序基础知识</h3><p><a href="undefined">https://developer.android.google.cn/guide/topics/providers/content-provider-basics.html</a></p><h3 id="创建内容提供程序"><a href="#创建内容提供程序" class="headerlink" title="创建内容提供程序"></a>创建内容提供程序</h3><p><a href="undefined">https://developer.android.google.cn/guide/topics/providers/content-provider-creating.html</a></p><h3 id="日历提供程序"><a href="#日历提供程序" class="headerlink" title="日历提供程序"></a>日历提供程序</h3><p><a href="undefined">https://developer.android.google.cn/guide/topics/providers/calendar-provider.html</a></p><h3 id="联系人提供程序"><a href="#联系人提供程序" class="headerlink" title="联系人提供程序"></a>联系人提供程序</h3><p><a href="undefined">https://developer.android.google.cn/guide/topics/providers/contacts-provider.html</a></p><h3 id="存储访问框架"><a href="#存储访问框架" class="headerlink" title="存储访问框架"></a>存储访问框架</h3><p><a href="undefined">https://developer.android.google.cn/guide/topics/providers/document-provider.html</a></p><h2 id="应用小部件-App-Widgets"><a href="#应用小部件-App-Widgets" class="headerlink" title="应用小部件 App Widgets"></a>应用小部件 App Widgets</h2><p><a href="undefined">https://developer.android.google.cn/guide/topics/appwidgets/index.html</a></p><h3 id="应用小部件主机-App-Widget-Host"><a href="#应用小部件主机-App-Widget-Host" class="headerlink" title="应用小部件主机 App Widget Host"></a>应用小部件主机 App Widget Host</h3><p><a href="undefined">https://developer.android.google.cn/guide/topics/appwidgets/index.html</a></p><h2 id="进程和线程"><a href="#进程和线程" class="headerlink" title="进程和线程"></a>进程和线程</h2><p><a href="undefined">https://developer.android.google.cn/guide/components/processes-and-threads.html</a></p><h1 id="应用资源-App-Resources"><a href="#应用资源-App-Resources" class="headerlink" title="应用资源 App Resources"></a>应用资源 App Resources</h1><p><a href="undefined">https://developer.android.google.cn/guide/topics/resources/index.html</a></p><h2 id="资源概览"><a href="#资源概览" class="headerlink" title="资源概览"></a>资源概览</h2><p><a href="undefined">https://developer.android.google.cn/guide/topics/resources/overview.html</a></p><h2 id="提供资源"><a href="#提供资源" class="headerlink" title="提供资源"></a>提供资源</h2><p><a href="undefined">https://developer.android.google.cn/guide/topics/resources/providing-resources.html</a></p><h2 id="访问资源"><a href="#访问资源" class="headerlink" title="访问资源"></a>访问资源</h2><p><a href="undefined">https://developer.android.google.cn/guide/topics/resources/accessing-resources.html</a></p><h2 id="处理运行时变更"><a href="#处理运行时变更" class="headerlink" title="处理运行时变更"></a>处理运行时变更</h2><p><a href="undefined">https://developer.android.google.cn/guide/topics/resources/runtime-changes.html</a></p><h2 id="本地化-Localizing-with-Resources"><a href="#本地化-Localizing-with-Resources" class="headerlink" title="本地化 Localizing with Resources"></a>本地化 Localizing with Resources</h2><p><a href="undefined">https://developer.android.google.cn/guide/topics/resources/localization.html</a></p><h3 id="ICU4J-Android-框架-API"><a href="#ICU4J-Android-框架-API" class="headerlink" title="ICU4J Android 框架 API"></a>ICU4J Android 框架 API</h3><p><a href="undefined">https://developer.android.google.cn/guide/topics/resources/icu4j-framework.html</a></p><h3 id="语言和语言区域"><a href="#语言和语言区域" class="headerlink" title="语言和语言区域"></a>语言和语言区域</h3><p><a href="undefined">https://developer.android.google.cn/guide/topics/resources/multilingual-support.html</a></p><h2 id="资源类型-Resource-Types"><a href="#资源类型-Resource-Types" class="headerlink" title="资源类型 Resource Types"></a>资源类型 Resource Types</h2><p><a href="undefined">https://developer.android.google.cn/guide/topics/resources/available-resources.html</a></p><h3 id="动画-Animation-Resources"><a href="#动画-Animation-Resources" class="headerlink" title="动画 Animation Resources"></a>动画 Animation Resources</h3><p><a href="undefined">https://developer.android.google.cn/guide/topics/resources/animation-resource.html</a></p><h3 id="颜色状态列表-Color-State-List-Resource"><a href="#颜色状态列表-Color-State-List-Resource" class="headerlink" title="颜色状态列表 Color State List Resource"></a>颜色状态列表 Color State List Resource</h3><p><a href="undefined">https://developer.android.google.cn/guide/topics/resources/color-list-resource.html</a></p><h3 id="可绘制对象"><a href="#可绘制对象" class="headerlink" title="可绘制对象"></a>可绘制对象</h3><p><a href="undefined">https://developer.android.google.cn/guide/topics/resources/drawable-resource.html</a></p><h3 id="布局-Layout-Resource"><a href="#布局-Layout-Resource" class="headerlink" title="布局 Layout Resource"></a>布局 Layout Resource</h3><p><a href="undefined">https://developer.android.google.cn/guide/topics/resources/layout-resource.html</a></p><h3 id="菜单-Menu-Resource"><a href="#菜单-Menu-Resource" class="headerlink" title="菜单 Menu Resource"></a>菜单 Menu Resource</h3><p><a href="undefined">https://developer.android.google.cn/guide/topics/resources/menu-resource.html</a></p><h3 id="字符串"><a href="#字符串" class="headerlink" title="字符串"></a>字符串</h3><p><a href="undefined">https://developer.android.google.cn/guide/topics/resources/string-resource.html</a></p><h3 id="样式-Style-Resource"><a href="#样式-Style-Resource" class="headerlink" title="样式 Style Resource"></a>样式 Style Resource</h3><p><a href="undefined">https://developer.android.google.cn/guide/topics/resources/style-resource.html</a></p><h3 id="其他类型-More-Resource-Types"><a href="#其他类型-More-Resource-Types" class="headerlink" title="其他类型 More Resource Types"></a>其他类型 More Resource Types</h3><p><a href="undefined">https://developer.android.google.cn/guide/topics/resources/more-resources.html</a></p><h1 id="应用清单"><a href="#应用清单" class="headerlink" title="应用清单"></a>应用清单</h1><p><a href="undefined">https://developer.android.google.cn/guide/topics/manifest/manifest-intro.html</a></p><h1 id="用户界面"><a href="#用户界面" class="headerlink" title="用户界面"></a>用户界面</h1><p><a href="undefined">https://developer.android.google.cn/guide/topics/ui/index.html</a></p><h2 id="UI-概览"><a href="#UI-概览" class="headerlink" title="UI 概览"></a>UI 概览</h2><p><a href="undefined">https://developer.android.google.cn/guide/topics/ui/overview.html</a></p><h2 id="布局"><a href="#布局" class="headerlink" title="布局"></a>布局</h2><p><a href="undefined">https://developer.android.google.cn/guide/topics/ui/declaring-layout.html</a></p><h3 id="线性布局"><a href="#线性布局" class="headerlink" title="线性布局"></a>线性布局</h3><p><a href="undefined">https://developer.android.google.cn/guide/topics/ui/layout/linear.html</a></p><h3 id="相对布局-Relative-Layout"><a href="#相对布局-Relative-Layout" class="headerlink" title="相对布局 Relative Layout"></a>相对布局 Relative Layout</h3><p><a href="undefined">https://developer.android.google.cn/guide/topics/ui/layout/relative.html</a></p><h3 id="列表视图"><a href="#列表视图" class="headerlink" title="列表视图"></a>列表视图</h3><p><a href="undefined">https://developer.android.google.cn/guide/topics/ui/layout/listview.html</a></p><h3 id="网格视图-Grid-View"><a href="#网格视图-Grid-View" class="headerlink" title="网格视图 Grid View"></a>网格视图 Grid View</h3><p><a href="undefined">https://developer.android.google.cn/guide/topics/ui/layout/gridview.html</a></p><h2 id="输入控件"><a href="#输入控件" class="headerlink" title="输入控件"></a>输入控件</h2><p><a href="undefined">https://developer.android.google.cn/guide/topics/ui/controls.html</a></p><h3 id="按钮-Buttons"><a href="#按钮-Buttons" class="headerlink" title="按钮 Buttons"></a>按钮 Buttons</h3><p><a href="undefined">https://developer.android.google.cn/guide/topics/ui/controls/button.html</a></p><h3 id="文本字段-Specifying-the-Input-Method-Type"><a href="#文本字段-Specifying-the-Input-Method-Type" class="headerlink" title="文本字段 Specifying the Input Method Type"></a>文本字段 Specifying the Input Method Type</h3><p><a href="undefined">https://developer.android.google.cn/training/keyboard-input/style.html</a></p><h3 id="复选框-Checkboxes"><a href="#复选框-Checkboxes" class="headerlink" title="复选框 Checkboxes"></a>复选框 Checkboxes</h3><p><a href="undefined">https://developer.android.google.cn/guide/topics/ui/controls/checkbox.html</a></p><h3 id="单选按钮-Radio-Buttons"><a href="#单选按钮-Radio-Buttons" class="headerlink" title="单选按钮 Radio Buttons"></a>单选按钮 Radio Buttons</h3><p><a href="undefined">https://developer.android.google.cn/guide/topics/ui/controls/radiobutton.html</a></p><h3 id="切换按钮-Toggle-Buttons"><a href="#切换按钮-Toggle-Buttons" class="headerlink" title="切换按钮 Toggle Buttons"></a>切换按钮 Toggle Buttons</h3><p><a href="undefined">https://developer.android.google.cn/guide/topics/ui/controls/togglebutton.html</a></p><h3 id="微调框"><a href="#微调框" class="headerlink" title="微调框"></a>微调框</h3><p><a href="undefined">https://developer.android.google.cn/guide/topics/ui/controls/spinner.html</a></p><h3 id="选取器"><a href="#选取器" class="headerlink" title="选取器"></a>选取器</h3><p><a href="undefined">https://developer.android.google.cn/guide/topics/ui/controls/pickers.html</a></p><h2 id="输入事件"><a href="#输入事件" class="headerlink" title="输入事件"></a>输入事件</h2><p><a href="undefined">https://developer.android.google.cn/guide/topics/ui/ui-events.html</a></p><h2 id="菜单"><a href="#菜单" class="headerlink" title="菜单"></a>菜单</h2><p><a href="undefined">https://developer.android.google.cn/guide/topics/ui/menus.html</a></p><h2 id="设置"><a href="#设置" class="headerlink" title="设置"></a>设置</h2><p><a href="undefined">https://developer.android.google.cn/guide/topics/ui/settings.html</a></p><h2 id="对话框"><a href="#对话框" class="headerlink" title="对话框"></a>对话框</h2><p><a href="undefined">https://developer.android.google.cn/guide/topics/ui/dialogs.html</a></p><h2 id="通知"><a href="#通知" class="headerlink" title="通知"></a>通知</h2><p><a href="undefined">https://developer.android.google.cn/guide/topics/ui/notifiers/notifications.html</a></p><h2 id="Toasts"><a href="#Toasts" class="headerlink" title="Toasts"></a>Toasts</h2><p><a href="undefined">https://developer.android.google.cn/guide/topics/ui/notifiers/toasts.html</a></p><h2 id="搜索-Search-Overview"><a href="#搜索-Search-Overview" class="headerlink" title="搜索 Search Overview"></a>搜索 Search Overview</h2><p><a href="undefined">https://developer.android.google.cn/guide/topics/search/index.html</a></p><h3 id="创建搜索界面-Creating-a-Search-Interface"><a href="#创建搜索界面-Creating-a-Search-Interface" class="headerlink" title="创建搜索界面 Creating a Search Interface"></a>创建搜索界面 Creating a Search Interface</h3><p><a href="undefined">https://developer.android.google.cn/guide/topics/search/search-dialog.html</a></p><h3 id="添加近期查询建议-Adding-Recent-Query-Suggestions"><a href="#添加近期查询建议-Adding-Recent-Query-Suggestions" class="headerlink" title="添加近期查询建议 Adding Recent Query Suggestions"></a>添加近期查询建议 Adding Recent Query Suggestions</h3><p><a href="undefined">https://developer.android.google.cn/guide/topics/search/adding-recent-query-suggestions.html</a></p><h3 id="添加自定义建议-Adding-Custom-Suggestions"><a href="#添加自定义建议-Adding-Custom-Suggestions" class="headerlink" title="添加自定义建议 Adding Custom Suggestions"></a>添加自定义建议 Adding Custom Suggestions</h3><p><a href="undefined">https://developer.android.google.cn/guide/topics/search/adding-custom-suggestions.html</a></p><h3 id="可搜索配置-Searchable-Configuration"><a href="#可搜索配置-Searchable-Configuration" class="headerlink" title="可搜索配置 Searchable Configuration"></a>可搜索配置 Searchable Configuration</h3><p><a href="undefined">https://developer.android.google.cn/guide/topics/search/searchable-config.html</a></p><h2 id="多窗口支持"><a href="#多窗口支持" class="headerlink" title="多窗口支持"></a>多窗口支持</h2><p><a href="undefined">https://developer.android.google.cn/guide/topics/ui/multi-window.html</a></p><h2 id="拖放"><a href="#拖放" class="headerlink" title="拖放"></a>拖放</h2><p><a href="undefined">https://developer.android.google.cn/guide/topics/ui/drag-drop.html</a></p><h2 id="无障碍功能-Accessibility"><a href="#无障碍功能-Accessibility" class="headerlink" title="无障碍功能 Accessibility"></a>无障碍功能 Accessibility</h2><p><a href="undefined">https://developer.android.google.cn/guide/topics/ui/accessibility/index.html</a></p><h3 id="为应用设置无障碍功能-Making-Apps-More-Accessible"><a href="#为应用设置无障碍功能-Making-Apps-More-Accessible" class="headerlink" title="为应用设置无障碍功能 Making Apps More Accessible"></a>为应用设置无障碍功能 Making Apps More Accessible</h3><p><a href="undefined">https://developer.android.google.cn/guide/topics/ui/accessibility/apps.html</a></p><h3 id="无障碍功能开发者检查单-Accessibility-Developer-Checklist"><a href="#无障碍功能开发者检查单-Accessibility-Developer-Checklist" class="headerlink" title="无障碍功能开发者检查单 Accessibility Developer Checklist"></a>无障碍功能开发者检查单 Accessibility Developer Checklist</h3><p><a href="undefined">https://developer.android.google.cn/guide/topics/ui/accessibility/checklist.html</a></p><h3 id="构建无障碍服务-Building-Accessibility-Services"><a href="#构建无障碍服务-Building-Accessibility-Services" class="headerlink" title="构建无障碍服务 Building Accessibility Services"></a>构建无障碍服务 Building Accessibility Services</h3><p><a href="undefined">https://developer.android.google.cn/guide/topics/ui/accessibility/services.html</a></p><h2 id="样式和主题"><a href="#样式和主题" class="headerlink" title="样式和主题"></a>样式和主题</h2><p><a href="undefined">https://developer.android.google.cn/guide/topics/ui/themes.html</a></p><h2 id="自定义组件-Custom-Components"><a href="#自定义组件-Custom-Components" class="headerlink" title="自定义组件 Custom Components"></a>自定义组件 Custom Components</h2><p><a href="undefined">https://developer.android.google.cn/guide/topics/ui/custom-components.html</a></p><h1 id="动画和图形-Animation-and-Graphics"><a href="#动画和图形-Animation-and-Graphics" class="headerlink" title="动画和图形 Animation and Graphics"></a>动画和图形 Animation and Graphics</h1><p><a href="undefined">https://developer.android.google.cn/guide/topics/graphics/index.html</a></p><h2 id="概览-Overview"><a href="#概览-Overview" class="headerlink" title="概览 Overview"></a>概览 Overview</h2><p><a href="undefined">https://developer.android.google.cn/guide/topics/graphics/overview.html</a></p><h2 id="属性动画-Property-Animation"><a href="#属性动画-Property-Animation" class="headerlink" title="属性动画 Property Animation"></a>属性动画 Property Animation</h2><p><a href="undefined">https://developer.android.google.cn/guide/topics/graphics/prop-animation.html</a></p><h2 id="视图动画-View-Animation"><a href="#视图动画-View-Animation" class="headerlink" title="视图动画 View Animation"></a>视图动画 View Animation</h2><p><a href="undefined">https://developer.android.google.cn/guide/topics/graphics/view-animation.html</a></p><h2 id="可绘制动画-Drawable-Animation"><a href="#可绘制动画-Drawable-Animation" class="headerlink" title="可绘制动画 Drawable Animation"></a>可绘制动画 Drawable Animation</h2><p><a href="undefined">https://developer.android.google.cn/guide/topics/graphics/drawable-animation.html</a></p><h2 id="画布和可绘制对象-Canvas-and-Drawables"><a href="#画布和可绘制对象-Canvas-and-Drawables" class="headerlink" title="画布和可绘制对象 Canvas and Drawables"></a>画布和可绘制对象 Canvas and Drawables</h2><p><a href="undefined">https://developer.android.google.cn/guide/topics/graphics/2d-graphics.html</a></p><h2 id="OpenGL-ES"><a href="#OpenGL-ES" class="headerlink" title="OpenGL ES"></a>OpenGL ES</h2><p><a href="undefined">https://developer.android.google.cn/guide/topics/graphics/opengl.html</a></p><h2 id="硬件加速-Hardware-Acceleration"><a href="#硬件加速-Hardware-Acceleration" class="headerlink" title="硬件加速 Hardware Acceleration"></a>硬件加速 Hardware Acceleration</h2><p><a href="undefined">https://developer.android.google.cn/guide/topics/graphics/hardware-accel.html</a></p><h1 id="计算-Computation"><a href="#计算-Computation" class="headerlink" title="计算 Computation"></a>计算 Computation</h1><p><a href="undefined">https://developer.android.google.cn/guide/topics/renderscript/index.html</a></p><h2 id="RenderScript"><a href="#RenderScript" class="headerlink" title="RenderScript"></a>RenderScript</h2><p><a href="undefined">https://developer.android.google.cn/guide/topics/renderscript/compute.html</a></p><h2 id="高级-RenderScript"><a href="#高级-RenderScript" class="headerlink" title="高级 RenderScript"></a>高级 RenderScript</h2><p><a href="undefined">https://developer.android.google.cn/guide/topics/renderscript/advanced.html</a></p><h2 id="Runtime-API-参考"><a href="#Runtime-API-参考" class="headerlink" title="Runtime API 参考"></a>Runtime API 参考</h2><p><a href="undefined">https://developer.android.google.cn/guide/topics/renderscript/reference/overview.html</a></p><h1 id="媒体和相机-Media-and-Camera"><a href="#媒体和相机-Media-and-Camera" class="headerlink" title="媒体和相机 Media and Camera"></a>媒体和相机 Media and Camera</h1><p><a href="undefined">https://developer.android.google.cn/guide/topics/media/index.html</a></p><h2 id="媒体回放-MediaPlayer"><a href="#媒体回放-MediaPlayer" class="headerlink" title="媒体回放 MediaPlayer"></a>媒体回放 MediaPlayer</h2><p><a href="undefined">https://developer.android.google.cn/guide/topics/media/mediaplayer.html</a></p><h2 id="媒体路由器-MediaRouter-API"><a href="#媒体路由器-MediaRouter-API" class="headerlink" title="媒体路由器 MediaRouter API"></a>媒体路由器 MediaRouter API</h2><p><a href="undefined">https://developer.android.google.cn/guide/topics/media/mediarouter.html</a></p><h2 id="媒体路由提供程序-Media-Route-Provider-API"><a href="#媒体路由提供程序-Media-Route-Provider-API" class="headerlink" title="媒体路由提供程序 Media Route Provider API"></a>媒体路由提供程序 Media Route Provider API</h2><p><a href="undefined">https://developer.android.google.cn/guide/topics/media/mediarouteprovider.html</a></p><h2 id="ExoPlayer"><a href="#ExoPlayer" class="headerlink" title="ExoPlayer"></a>ExoPlayer</h2><p><a href="undefined">https://developer.android.google.cn/guide/topics/media/exoplayer.html</a></p><h2 id="支持的媒体格式-Supported-Media-Formats"><a href="#支持的媒体格式-Supported-Media-Formats" class="headerlink" title="支持的媒体格式 Supported Media Formats"></a>支持的媒体格式 Supported Media Formats</h2><p><a href="undefined">https://developer.android.google.cn/guide/topics/media/media-formats.html</a></p><h2 id="音频采集-MediaRecorder"><a href="#音频采集-MediaRecorder" class="headerlink" title="音频采集 MediaRecorder"></a>音频采集 MediaRecorder</h2><p><a href="undefined">https://developer.android.google.cn/guide/topics/media/mediarecorder.html</a></p><h2 id="相机-Camera-API"><a href="#相机-Camera-API" class="headerlink" title="相机 Camera API"></a>相机 Camera API</h2><p><a href="undefined">https://developer.android.google.cn/guide/topics/media/camera.html</a></p><h1 id="位置和传感器-Location-and-Sensors-APIs"><a href="#位置和传感器-Location-and-Sensors-APIs" class="headerlink" title="位置和传感器 Location and Sensors APIs"></a>位置和传感器 Location and Sensors APIs</h1><p><a href="undefined">https://developer.android.google.cn/guide/topics/sensors/index.html</a></p><h2 id="位置和地图-Location-and-Maps"><a href="#位置和地图-Location-and-Maps" class="headerlink" title="位置和地图 Location and Maps"></a>位置和地图 Location and Maps</h2><p><a href="undefined">https://developer.android.google.cn/guide/topics/location/index.html</a></p><h2 id="位置策略-Location-Strategies"><a href="#位置策略-Location-Strategies" class="headerlink" title="位置策略 Location Strategies"></a>位置策略 Location Strategies</h2><p><a href="undefined">https://developer.android.google.cn/guide/topics/location/strategies.html</a></p><h2 id="传感器概览-Sensors-Overview"><a href="#传感器概览-Sensors-Overview" class="headerlink" title="传感器概览 Sensors Overview"></a>传感器概览 Sensors Overview</h2><p><a href="undefined">https://developer.android.google.cn/guide/topics/sensors/sensors_overview.html</a></p><h2 id="运动传感器-Motion-Sensors"><a href="#运动传感器-Motion-Sensors" class="headerlink" title="运动传感器 Motion Sensors"></a>运动传感器 Motion Sensors</h2><p><a href="undefined">https://developer.android.google.cn/guide/topics/sensors/sensors_motion.html</a></p><h2 id="位置传感器-Position-Sensors"><a href="#位置传感器-Position-Sensors" class="headerlink" title="位置传感器 Position Sensors"></a>位置传感器 Position Sensors</h2><p><a href="undefined">https://developer.android.google.cn/guide/topics/sensors/sensors_position.html</a></p><h2 id="环境传感器-Environment-Sensors"><a href="#环境传感器-Environment-Sensors" class="headerlink" title="环境传感器 Environment Sensors"></a>环境传感器 Environment Sensors</h2><p><a href="undefined">https://developer.android.google.cn/guide/topics/sensors/sensors_environment.html</a></p><h1 id="连接-Connectivity"><a href="#连接-Connectivity" class="headerlink" title="连接 Connectivity"></a>连接 Connectivity</h1><p><a href="undefined">https://developer.android.google.cn/guide/topics/connectivity/index.html</a></p><h2 id="蓝牙"><a href="#蓝牙" class="headerlink" title="蓝牙"></a>蓝牙</h2><p><a href="undefined">https://developer.android.google.cn/guide/topics/connectivity/bluetooth.html</a></p><h3 id="蓝牙低功耗-Bluetooth-Low-Energy"><a href="#蓝牙低功耗-Bluetooth-Low-Energy" class="headerlink" title="蓝牙低功耗 Bluetooth Low Energy"></a>蓝牙低功耗 Bluetooth Low Energy</h3><p><a href="undefined">https://developer.android.google.cn/guide/topics/connectivity/bluetooth-le.html</a></p><h2 id="NFC"><a href="#NFC" class="headerlink" title="NFC"></a>NFC</h2><p><a href="undefined">https://developer.android.google.cn/guide/topics/connectivity/nfc/index.html</a></p><h3 id="NFC-基础知识-NFC-Basics"><a href="#NFC-基础知识-NFC-Basics" class="headerlink" title="NFC 基础知识 NFC Basics"></a>NFC 基础知识 NFC Basics</h3><p><a href="undefined">https://developer.android.google.cn/guide/topics/connectivity/nfc/nfc.html</a></p><h3 id="高级-NFC-Advanced-NFC"><a href="#高级-NFC-Advanced-NFC" class="headerlink" title="高级 NFC Advanced NFC"></a>高级 NFC Advanced NFC</h3><p><a href="undefined">https://developer.android.google.cn/guide/topics/connectivity/nfc/advanced-nfc.html</a></p><h3 id="基于主机的卡模拟-Host-based-Card-Emulation"><a href="#基于主机的卡模拟-Host-based-Card-Emulation" class="headerlink" title="基于主机的卡模拟 Host-based Card Emulation"></a>基于主机的卡模拟 Host-based Card Emulation</h3><p><a href="undefined">https://developer.android.google.cn/guide/topics/connectivity/nfc/hce.html</a></p><h2 id="Wi-Fi-P2P"><a href="#Wi-Fi-P2P" class="headerlink" title="Wi-Fi P2P"></a>Wi-Fi P2P</h2><p><a href="undefined">https://developer.android.google.cn/guide/topics/connectivity/wifip2p.html</a></p><h2 id="USB"><a href="#USB" class="headerlink" title="USB"></a>USB</h2><p><a href="undefined">https://developer.android.google.cn/guide/topics/connectivity/usb/index.html</a></p><h3 id="配件-USB-Accessory"><a href="#配件-USB-Accessory" class="headerlink" title="配件 USB Accessory"></a>配件 USB Accessory</h3><p><a href="undefined">https://developer.android.google.cn/guide/topics/connectivity/usb/accessory.html</a></p><h3 id="主机-USB-Host"><a href="#主机-USB-Host" class="headerlink" title="主机 USB Host"></a>主机 USB Host</h3><p><a href="undefined">https://developer.android.google.cn/guide/topics/connectivity/usb/host.html</a></p><h2 id="SIP-Session-Initiation-Protocol"><a href="#SIP-Session-Initiation-Protocol" class="headerlink" title="SIP Session Initiation Protocol"></a>SIP Session Initiation Protocol</h2><p><a href="undefined">https://developer.android.google.cn/guide/topics/connectivity/sip.html</a></p><h1 id="文本和输入-Text-and-Input"><a href="#文本和输入-Text-and-Input" class="headerlink" title="文本和输入 Text and Input"></a>文本和输入 Text and Input</h1><p><a href="undefined">https://developer.android.google.cn/guide/topics/text/index.html</a></p><h2 id="复制和粘贴-Copy-and-Paste"><a href="#复制和粘贴-Copy-and-Paste" class="headerlink" title="复制和粘贴 Copy and Paste"></a>复制和粘贴 Copy and Paste</h2><p><a href="undefined">https://developer.android.google.cn/guide/topics/text/copy-paste.html</a></p><h2 id="创建-IME-Creating-an-Input-Method"><a href="#创建-IME-Creating-an-Input-Method" class="headerlink" title="创建 IME Creating an Input Method"></a>创建 IME Creating an Input Method</h2><p><a href="undefined">https://developer.android.google.cn/guide/topics/text/creating-input-method.html</a></p><h2 id="拼写检查程序-Spelling-Checker-Framework"><a href="#拼写检查程序-Spelling-Checker-Framework" class="headerlink" title="拼写检查程序 Spelling Checker Framework"></a>拼写检查程序 Spelling Checker Framework</h2><p><a href="undefined">https://developer.android.google.cn/guide/topics/text/spell-checker-framework.html</a></p><h1 id="数据存储-Data-Storage"><a href="#数据存储-Data-Storage" class="headerlink" title="数据存储 Data Storage"></a>数据存储 Data Storage</h1><p><a href="undefined">https://developer.android.google.cn/guide/topics/data/index.html</a></p><h2 id="存储选项"><a href="#存储选项" class="headerlink" title="存储选项"></a>存储选项</h2><p><a href="undefined">https://developer.android.google.cn/guide/topics/data/data-storage.html</a></p><h2 id="数据备份-Backing-up-App-Data-to-the-Cloud"><a href="#数据备份-Backing-up-App-Data-to-the-Cloud" class="headerlink" title="数据备份 Backing up App Data to the Cloud"></a>数据备份 Backing up App Data to the Cloud</h2><p><a href="undefined">https://developer.android.google.cn/guide/topics/data/backup.html</a></p><h2 id="应用安装位置-App-Install-Location"><a href="#应用安装位置-App-Install-Location" class="headerlink" title="应用安装位置 App Install Location"></a>应用安装位置 App Install Location</h2><p><a href="undefined">https://developer.android.google.cn/guide/topics/data/install-location.html</a></p><h1 id="Android-库"><a href="#Android-库" class="headerlink" title="Android 库"></a>Android 库</h1><p><a href="undefined">https://developer.android.google.cn/topic/libraries/index.html</a></p><h2 id="支持库"><a href="#支持库" class="headerlink" title="支持库"></a>支持库</h2><p><a href="undefined">https://developer.android.google.cn/topic/libraries/support-library/index.html</a></p><h3 id="功能"><a href="#功能" class="headerlink" title="功能"></a>功能</h3><p><a href="undefined">https://developer.android.google.cn/topic/libraries/support-library/features.html</a></p><h3 id="设置-1"><a href="#设置-1" class="headerlink" title="设置"></a>设置</h3><p><a href="undefined">https://developer.android.google.cn/topic/libraries/support-library/setup.html</a></p><h3 id="修订历史记录-Recent-Support-Library-Revisions"><a href="#修订历史记录-Recent-Support-Library-Revisions" class="headerlink" title="修订历史记录 Recent Support Library Revisions"></a>修订历史记录 Recent Support Library Revisions</h3><p><a href="undefined">https://developer.android.google.cn/topic/libraries/support-library/revisions.html</a></p><h2 id="数据绑定库-Data-Binding-Library"><a href="#数据绑定库-Data-Binding-Library" class="headerlink" title="数据绑定库 Data Binding Library"></a>数据绑定库 Data Binding Library</h2><p><a href="undefined">https://developer.android.google.cn/topic/libraries/data-binding/index.html</a></p><h2 id="测试支持库"><a href="#测试支持库" class="headerlink" title="测试支持库"></a>测试支持库</h2><p><a href="undefined">https://developer.android.google.cn/topic/libraries/testing-support-library/index.html</a></p><h1 id="管理-Administration"><a href="#管理-Administration" class="headerlink" title="管理 Administration"></a>管理 Administration</h1><p><a href="undefined">https://developer.android.google.cn/guide/topics/admin/index.html</a></p><h2 id="设备政策-Device-Administration"><a href="#设备政策-Device-Administration" class="headerlink" title="设备政策 Device Administration"></a>设备政策 Device Administration</h2><p><a href="undefined">https://developer.android.google.cn/guide/topics/admin/device-admin.html</a></p><h1 id="网络应用-Web-Apps"><a href="#网络应用-Web-Apps" class="headerlink" title="网络应用 Web Apps"></a>网络应用 Web Apps</h1><p><a href="undefined">https://developer.android.google.cn/guide/webapps/index.html</a></p><h2 id="在网络应用中支持不同屏幕-Supporting-Different-Screens-in-Web-Apps"><a href="#在网络应用中支持不同屏幕-Supporting-Different-Screens-in-Web-Apps" class="headerlink" title="在网络应用中支持不同屏幕 Supporting Different Screens in Web Apps"></a>在网络应用中支持不同屏幕 Supporting Different Screens in Web Apps</h2><p><a href="undefined">https://developer.android.google.cn/guide/webapps/targeting.html</a></p><h2 id="在-WebView-中构建网络应用-Building-Web-Apps-in-WebView"><a href="#在-WebView-中构建网络应用-Building-Web-Apps-in-WebView" class="headerlink" title="在 WebView 中构建网络应用 Building Web Apps in WebView"></a>在 WebView 中构建网络应用 Building Web Apps in WebView</h2><p><a href="undefined">https://developer.android.google.cn/guide/webapps/webview.html</a></p><h2 id="迁移到-Android-4-4-中的-WebView-Migrating-to-WebView-in-Android-4-4"><a href="#迁移到-Android-4-4-中的-WebView-Migrating-to-WebView-in-Android-4-4" class="headerlink" title="迁移到 Android 4.4 中的 WebView Migrating to WebView in Android 4.4"></a>迁移到 Android 4.4 中的 WebView Migrating to WebView in Android 4.4</h2><p><a href="undefined">https://developer.android.google.cn/guide/webapps/migrating.html</a></p><h2 id="调试网络应用-Debugging-Web-Apps"><a href="#调试网络应用-Debugging-Web-Apps" class="headerlink" title="调试网络应用 Debugging Web Apps"></a>调试网络应用 Debugging Web Apps</h2><p><a href="undefined">https://developer.android.google.cn/guide/webapps/debugging.html</a></p><h2 id="网络应用最佳做法-Best-Practices-for-Web-Apps"><a href="#网络应用最佳做法-Best-Practices-for-Web-Apps" class="headerlink" title="网络应用最佳做法 Best Practices for Web Apps"></a>网络应用最佳做法 Best Practices for Web Apps</h2><p><a href="undefined">https://developer.android.google.cn/guide/webapps/best-practices.html</a></p><h1 id="最佳实践-Best-Practices"><a href="#最佳实践-Best-Practices" class="headerlink" title="最佳实践 Best Practices"></a>最佳实践 Best Practices</h1><p><a href="undefined">https://developer.android.google.cn/guide/practices/index.html</a></p><h2 id="支持多种屏幕"><a href="#支持多种屏幕" class="headerlink" title="支持多种屏幕"></a>支持多种屏幕</h2><p><a href="undefined">https://developer.android.google.cn/guide/practices/screens_support.html</a></p><h3 id="分配到特定屏幕-Distributing-to-Specific-Screens"><a href="#分配到特定屏幕-Distributing-to-Specific-Screens" class="headerlink" title="分配到特定屏幕 Distributing to Specific Screens"></a>分配到特定屏幕 Distributing to Specific Screens</h3><p><a href="undefined">https://developer.android.google.cn/guide/practices/screens-distribution.html</a></p><h3 id="屏幕兼容性模式-Screen-Compatibility-Mode"><a href="#屏幕兼容性模式-Screen-Compatibility-Mode" class="headerlink" title="屏幕兼容性模式 Screen Compatibility Mode"></a>屏幕兼容性模式 Screen Compatibility Mode</h3><p><a href="undefined">https://developer.android.google.cn/guide/practices/screen-compat-mode.html</a></p><h2 id="支持平板电脑和手机-Supporting-Tablets-and-Handsets"><a href="#支持平板电脑和手机-Supporting-Tablets-and-Handsets" class="headerlink" title="支持平板电脑和手机 Supporting Tablets and Handsets"></a>支持平板电脑和手机 Supporting Tablets and Handsets</h2><p><a href="undefined">https://developer.android.google.cn/guide/practices/tablets-and-handsets.html</a></p>]]></content>
    
    <summary type="html">
    
      &lt;h1 id=&quot;Android-简介&quot;&gt;&lt;a href=&quot;#Android-简介&quot; class=&quot;headerlink&quot; title=&quot;Android 简介&quot;&gt;&lt;/a&gt;Android 简介&lt;/h1&gt;&lt;p&gt;&lt;a href=&quot;undefined&quot;&gt;https://developer.android.google.cn/guide/index.html&lt;/a&gt;&lt;/p&gt;
&lt;h2 id=&quot;应用基础知识&quot;&gt;&lt;a href=&quot;#应用基础知识&quot; class=&quot;headerlink&quot; title=&quot;应用基础知识&quot;&gt;&lt;/a&gt;应用基础知识&lt;/h2&gt;&lt;p&gt;&lt;a href=&quot;undefined&quot;&gt;https://developer.android.google.cn/guide/components/fundamentals.html&lt;/a&gt;&lt;/p&gt;
&lt;h2 id=&quot;设备兼容性-Device-Compatibility&quot;&gt;&lt;a href=&quot;#设备兼容性-Device-Compatibility&quot; class=&quot;headerlink&quot; title=&quot;设备兼容性 Device Compatibility&quot;&gt;&lt;/a&gt;设备兼容性 Device Compatibility&lt;/h2&gt;&lt;p&gt;&lt;a href=&quot;undefined&quot;&gt;https://developer.android.google.cn/guide/practices/compatibility.html&lt;/a&gt;&lt;/p&gt;
&lt;h2 id=&quot;系统权限&quot;&gt;&lt;a href=&quot;#系统权限&quot; class=&quot;headerlink&quot; title=&quot;系统权限&quot;&gt;&lt;/a&gt;系统权限&lt;/h2&gt;&lt;p&gt;&lt;a href=&quot;undefined&quot;&gt;https://developer.android.google.cn/guide/topics/security/permissions.html&lt;/a&gt;&lt;/p&gt;
    
    </summary>
    
      <category term="android" scheme="http://yoursite.com/categories/android/"/>
    
    
  </entry>
  
  <entry>
    <title>第2章 常用互动方法</title>
    <link href="http://yoursite.com/2017/02/08/%E7%AC%AC2%E7%AB%A0%20%E5%B8%B8%E7%94%A8%E4%BA%92%E5%8A%A8%E6%96%B9%E6%B3%95/"/>
    <id>http://yoursite.com/2017/02/08/第2章 常用互动方法/</id>
    <published>2017-02-08T09:30:00.000Z</published>
    <updated>2017-03-24T02:32:50.000Z</updated>
    
    <content type="html"><![CDATA[<h1 id="第2章-常用互动方法"><a href="#第2章-常用互动方法" class="headerlink" title="第2章 常用互动方法"></a>第2章 常用互动方法</h1><h2 id="2-1-JavaScript-输出内容（document-write）"><a href="#2-1-JavaScript-输出内容（document-write）" class="headerlink" title="2.1 JavaScript-输出内容（document.write）"></a>2.1 JavaScript-输出内容（document.write）</h2><p><code>document.write()</code> 可用于直接向 HTML 输出流写内容。简单的说就是直接在网页中输出内容。</p><p><strong>第一种**</strong>:<strong><strong>输出内容用””括起，直接输出</strong></strong>“”<strong>**号内的内容。</strong></p><figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br></pre></td><td class="code"><pre><span class="line">&lt;script type=&quot;text/javascript&quot;&gt;</span><br><span class="line">  document.write(&quot;I love JavaScript！&quot;); //内容用&quot;&quot;括起来，&quot;&quot;里的内容直接输出。</span><br><span class="line">&lt;/script&gt;</span><br></pre></td></tr></table></figure><a id="more"></a><p><strong>第二种**</strong>:通过变量，输出内容**</p><figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br></pre></td><td class="code"><pre><span class="line">&lt;script type=&quot;text/javascript&quot;&gt;</span><br><span class="line">  var mystr=&quot;hello world!&quot;;</span><br><span class="line">  document.write(mystr);  //直接写变量名，输出变量存储的内容。</span><br><span class="line">&lt;/script&gt;</span><br></pre></td></tr></table></figure><p><strong>第三种**</strong>:<strong><strong>输出多项内容，内容之间用</strong></strong>+<strong>**号连接。</strong></p><figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br></pre></td><td class="code"><pre><span class="line">&lt;script type=&quot;text/javascript&quot;&gt;</span><br><span class="line">  var mystr=&quot;hello&quot;;</span><br><span class="line">  document.write(mystr+&quot;I love JavaScript&quot;); //多项内容之间用+号连接</span><br><span class="line">&lt;/script&gt;</span><br></pre></td></tr></table></figure><p><strong>第四种**</strong>:<strong><strong>输出</strong></strong>HTML<strong>**标签，并起作用，标签使用””括起来。</strong></p><figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br></pre></td><td class="code"><pre><span class="line">&lt;script type=&quot;text/javascript&quot;&gt;</span><br><span class="line">  var mystr=&quot;hello&quot;;</span><br><span class="line">document.write(mystr+&quot;&lt;br&gt;&quot;);//输出hello后，输出一个换行符</span><br><span class="line">  document.write(&quot;JavaScript&quot;);</span><br><span class="line">&lt;/script&gt;</span><br></pre></td></tr></table></figure><p>关于JS输出空格问题，请查看wiki中” <a href="http://www.imooc.com/wiki/view?pid=167" target="_blank" rel="noopener">JS如何输出空格</a> “</p><h2 id="2-1-JavaScript-警告（alert-消息对话框）"><a href="#2-1-JavaScript-警告（alert-消息对话框）" class="headerlink" title="2.1 JavaScript-警告（alert 消息对话框）"></a>2.1 JavaScript-警告（alert 消息对话框）</h2><p>我们在访问网站的时候，有时会突然弹出一个小窗口，上面写着一段提示信息文字。如果你不点击“确定”，就不能对网页做任何操作，这个小窗口就是使用alert实现的。</p><p><strong>语法:</strong></p><figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><span class="line">alert(字符串或变量);</span><br></pre></td></tr></table></figure><p><strong>看下面的代码:</strong></p><figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br></pre></td><td class="code"><pre><span class="line">&lt;script type=&quot;text/javascript&quot;&gt;</span><br><span class="line">   var mynum = 30;</span><br><span class="line">   alert(&quot;hello!&quot;);</span><br><span class="line">   alert(mynum);</span><br><span class="line">&lt;/script&gt;</span><br></pre></td></tr></table></figure><p><strong>注:</strong>alert弹出消息对话框(包含一个确定按钮)。</p><p><strong>结果:按顺序弹出消息框</strong></p><p><strong><img src="http://img.mukewang.com/52e362430001bdd204850354.jpg" alt="img"></strong></p><p><a href="http://img.mukewang.com/52e362850001024d04840353.jpg" target="_blank" rel="noopener"><img src="http://img.mukewang.com/52e362850001024d04840353.jpg" alt="img"></a></p><p><strong>注意:</strong></p><ol><li>在点击对话框”确定”按钮前，不能进行任何其它操作。</li><li>消息对话框通常可以用于调试程序。</li><li>alert输出内容，可以是字符串或变量，与document.write 相似。</li></ol><h2 id="2-3-JavaScript-确认（confirm-消息对话框）"><a href="#2-3-JavaScript-确认（confirm-消息对话框）" class="headerlink" title="2.3 JavaScript-确认（confirm 消息对话框）"></a>2.3 JavaScript-确认（confirm 消息对话框）</h2><p>onfirm 消息对话框通常用于允许用户做选择的动作，如：“你对吗？”等。弹出对话框(包括一个确定按钮和一个取消按钮)。</p><p><strong>语法:</strong></p><figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><span class="line">confirm(str);</span><br></pre></td></tr></table></figure><p><strong>参数说明:</strong></p><figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br></pre></td><td class="code"><pre><span class="line">str：在消息对话框中要显示的文本</span><br><span class="line">返回值: Boolean值</span><br></pre></td></tr></table></figure><p><strong>返回值:</strong></p><figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br></pre></td><td class="code"><pre><span class="line">当用户点击&quot;确定&quot;按钮时，返回true</span><br><span class="line">当用户点击&quot;取消&quot;按钮时，返回false</span><br></pre></td></tr></table></figure><p><strong>注:</strong> <strong>通过返回值可以判断用户点击了什么按钮</strong></p><p>看下面的代码:</p><figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br></pre></td><td class="code"><pre><span class="line">&lt;script type=&quot;text/javascript&quot;&gt;</span><br><span class="line">    var mymessage=confirm(&quot;你喜欢JavaScript吗?&quot;);</span><br><span class="line">    if(mymessage==true)</span><br><span class="line">    &#123;   document.write(&quot;很好,加油!&quot;);   &#125;</span><br><span class="line">    else</span><br><span class="line">    &#123;  document.write(&quot;JS功能强大，要学习噢!&quot;);   &#125;</span><br><span class="line">&lt;/script&gt;</span><br></pre></td></tr></table></figure><p><strong>结果:</strong></p><p><strong><img src="http://img.mukewang.com/52e35bc60001f01a04230353.jpg" alt="img"></strong></p><p><strong>注: 消息对话框是排它的，即用户在点击对话框按钮前，不能进行任何其它操作。</strong></p><h2 id="2-4-JavaScript-提问（prompt-消息对话框）"><a href="#2-4-JavaScript-提问（prompt-消息对话框）" class="headerlink" title="2.4 JavaScript-提问（prompt 消息对话框）"></a>2.4 JavaScript-提问（prompt 消息对话框）</h2><p><strong>prompt</strong>弹出消息对话框,通常用于询问一些需要与用户交互的信息。弹出消息对话框（包含一个确定按钮、取消按钮与一个文本输入框）。</p><p><strong>语法:</strong></p><figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><span class="line">prompt(str1, str2);</span><br></pre></td></tr></table></figure><p><strong>参数说明：</strong></p><figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br></pre></td><td class="code"><pre><span class="line">str1: 要显示在消息对话框中的文本，不可修改</span><br><span class="line">str2：文本框中的内容，可以修改</span><br></pre></td></tr></table></figure><p><strong>返回值:</strong></p><figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br></pre></td><td class="code"><pre><span class="line">1. 点击确定按钮，文本框中的内容将作为函数返回值</span><br><span class="line">2. 点击取消按钮，将返回null</span><br></pre></td></tr></table></figure><p>看看下面代码:</p><figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br></pre></td><td class="code"><pre><span class="line">var myname=prompt(&quot;请输入你的姓名:&quot;);</span><br><span class="line">if(myname!=null)</span><br><span class="line">  &#123;   alert(&quot;你好&quot;+myname); &#125;</span><br><span class="line">else</span><br><span class="line">  &#123;  alert(&quot;你好 my friend.&quot;);  &#125;</span><br></pre></td></tr></table></figure><p><strong>结果:</strong></p><p><strong><img src="http://img.mukewang.com/52e360780001ede107090353.jpg" alt="img"></strong></p><p><strong>注:在用户点击对话框的按钮前，不能进行任何其它操作。</strong></p><h2 id="2-5-JavaScript-打开新窗口（window-open）"><a href="#2-5-JavaScript-打开新窗口（window-open）" class="headerlink" title="2.5 JavaScript-打开新窗口（window.open）"></a>2.5 JavaScript-打开新窗口（window.open）</h2><p>open() 方法可以查找一个已经存在或者新建的浏览器窗口。</p><p><strong>语法：</strong></p><figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><span class="line">window.open([URL], [窗口名称], [参数字符串])</span><br></pre></td></tr></table></figure><p><strong>参数说明:</strong></p><figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br></pre></td><td class="code"><pre><span class="line">URL：可选参数，在窗口中要显示网页的网址或路径。如果省略这个参数，或者它的值是空字符串，那么窗口就不显示任何文档。</span><br><span class="line">窗口名称：可选参数，被打开窗口的名称。</span><br><span class="line">    1.该名称由字母、数字和下划线字符组成。</span><br><span class="line">    2.&quot;_top&quot;、&quot;_blank&quot;、&quot;_self&quot;具有特殊意义的名称。</span><br><span class="line">       _blank：在新窗口显示目标网页</span><br><span class="line">       _self：在当前窗口显示目标网页</span><br><span class="line">       _top：框架网页中在上部窗口中显示目标网页</span><br><span class="line">    3.相同 name 的窗口只能创建一个，要想创建多个窗口则 name 不能相同。</span><br><span class="line">   4.name 不能包含有空格。</span><br><span class="line">参数字符串：可选参数，设置窗口参数，各参数用逗号隔开。</span><br></pre></td></tr></table></figure><p><strong>参数表:</strong></p><p><strong><img src="http://img.mukewang.com/52e3677900013d6a05020261.jpg" alt="img"></strong></p><p>例如:打开<a href="http://www.imooc.com网站，大小为300px" target="_blank" rel="noopener">http://www.imooc.com网站，大小为300px</a> * 200px，无菜单，无工具栏，无状态栏，有滚动条窗口：</p><figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br></pre></td><td class="code"><pre><span class="line">&lt;script type=&quot;text/javascript&quot;&gt; window.open(&apos;http://www.imooc.com&apos;,&apos;_blank&apos;,&apos;width=300,height=200,menubar=no,toolbar=no, status=no,scrollbars=yes&apos;)</span><br><span class="line">&lt;/script&gt;</span><br></pre></td></tr></table></figure><p><strong>注意：</strong>运行结果考虑浏览器兼容问题。</p><h2 id="2-6-JavaScript-关闭窗口（window-close）"><a href="#2-6-JavaScript-关闭窗口（window-close）" class="headerlink" title="2.6 JavaScript-关闭窗口（window.close）"></a>2.6 JavaScript-关闭窗口（window.close）</h2><p>close()关闭窗口</p><p><strong>用法：</strong></p><figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><span class="line">window.close();   //关闭本窗口</span><br></pre></td></tr></table></figure><p>或</p><figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><span class="line">&lt;窗口对象&gt;.close();   //关闭指定的窗口</span><br></pre></td></tr></table></figure><p>例如:关闭新建的窗口。</p><figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br></pre></td><td class="code"><pre><span class="line">&lt;script type=&quot;text/javascript&quot;&gt;</span><br><span class="line">   var mywin=window.open(&apos;http://www.imooc.com&apos;); //将新打的窗口对象，存储在变量mywin中</span><br><span class="line">   mywin.close();</span><br><span class="line">&lt;/script&gt;</span><br></pre></td></tr></table></figure><p><strong>注意:上面代码在打开新窗口的同时，关闭该窗口，看不到被打开的窗口。</strong></p>]]></content>
    
    <summary type="html">
    
      &lt;h1 id=&quot;第2章-常用互动方法&quot;&gt;&lt;a href=&quot;#第2章-常用互动方法&quot; class=&quot;headerlink&quot; title=&quot;第2章 常用互动方法&quot;&gt;&lt;/a&gt;第2章 常用互动方法&lt;/h1&gt;&lt;h2 id=&quot;2-1-JavaScript-输出内容（document-write）&quot;&gt;&lt;a href=&quot;#2-1-JavaScript-输出内容（document-write）&quot; class=&quot;headerlink&quot; title=&quot;2.1 JavaScript-输出内容（document.write）&quot;&gt;&lt;/a&gt;2.1 JavaScript-输出内容（document.write）&lt;/h2&gt;&lt;p&gt;&lt;code&gt;document.write()&lt;/code&gt; 可用于直接向 HTML 输出流写内容。简单的说就是直接在网页中输出内容。&lt;/p&gt;
&lt;p&gt;&lt;strong&gt;第一种**&lt;/strong&gt;:&lt;strong&gt;&lt;strong&gt;输出内容用””括起，直接输出&lt;/strong&gt;&lt;/strong&gt;“”&lt;strong&gt;**号内的内容。&lt;/strong&gt;&lt;/p&gt;
&lt;figure class=&quot;highlight plain&quot;&gt;&lt;table&gt;&lt;tr&gt;&lt;td class=&quot;gutter&quot;&gt;&lt;pre&gt;&lt;span class=&quot;line&quot;&gt;1&lt;/span&gt;&lt;br&gt;&lt;span class=&quot;line&quot;&gt;2&lt;/span&gt;&lt;br&gt;&lt;span class=&quot;line&quot;&gt;3&lt;/span&gt;&lt;br&gt;&lt;/pre&gt;&lt;/td&gt;&lt;td class=&quot;code&quot;&gt;&lt;pre&gt;&lt;span class=&quot;line&quot;&gt;&amp;lt;script type=&amp;quot;text/javascript&amp;quot;&amp;gt;&lt;/span&gt;&lt;br&gt;&lt;span class=&quot;line&quot;&gt;  document.write(&amp;quot;I love JavaScript！&amp;quot;); //内容用&amp;quot;&amp;quot;括起来，&amp;quot;&amp;quot;里的内容直接输出。&lt;/span&gt;&lt;br&gt;&lt;span class=&quot;line&quot;&gt;&amp;lt;/script&amp;gt;&lt;/span&gt;&lt;br&gt;&lt;/pre&gt;&lt;/td&gt;&lt;/tr&gt;&lt;/table&gt;&lt;/figure&gt;
    
    </summary>
    
      <category term="JS" scheme="http://yoursite.com/categories/JS/"/>
    
    
  </entry>
  
  <entry>
    <title>Android studio编码技巧</title>
    <link href="http://yoursite.com/2017/02/08/Android%20Studio%20%E7%BC%96%E7%A0%81%E6%8A%80%E5%B7%A7/"/>
    <id>http://yoursite.com/2017/02/08/Android Studio 编码技巧/</id>
    <published>2017-02-08T09:30:00.000Z</published>
    <updated>2017-03-24T02:29:02.000Z</updated>
    
    <content type="html"><![CDATA[<h3 id="常用快捷键"><a href="#常用快捷键" class="headerlink" title="常用快捷键"></a>常用快捷键</h3><p> <strong>1.0 搜索or查看</strong></p><ul><li><p><code>Ctrl+G</code>  跳到指定的行</p></li><li><p><code>Ctrl+Shift+R</code>  在选中的文件目录里替换</p></li><li><p><code>Ctrl+Shift+F</code>  在选中的文件目录里搜索</p></li><li><p><code>Ctrl+N</code>  查找类</p></li><li><p><code>Ctrl+Shift+N</code>  查找文件</p></li><li><p><code>F2 或Shift+F2</code>  高亮错误或警告快速定位</p><a id="more"></a></li><li><p><code>Alt＋Q</code> 可以看到当前方法的声明</p></li><li><p><code>Ctrl＋P</code>  可以显示参数信息</p></li><li><p><code>ctrl+tab标签</code>  查看最近的操作</p></li><li><p><code>ctrl+e</code>  查看最近访问的文件</p></li><li><p><code>ctrl+alt+home</code> 查看相关文件</p></li><li><p><code>alt+f1</code>  在项目文件或资源管理器中打开该文件</p></li><li><p><code>ctrl+f12</code> 当前文件结构</p></li><li><p><code>ctrl+Q</code>  显示方法的注释</p></li><li><p><code>ctrl+h</code>  查看类结构</p></li><li><p><code>ctrl+shift+i</code>  快速查看方法的具体实现</p></li><li><p><code>ctrl+shift+E</code>  查看最近修改的类</p></li><li><p><code>ctrl+b</code>  查看一个变量的声明</p></li></ul><p><strong>2.0  重构</strong></p><ul><li><p><code>Ctrl＋Alt＋V</code>  可以引入变量。例如把括号内的SQL赋成一个变量</p></li><li><p><code>ctrl+alt+v</code> 生成变量</p></li><li><p><code>ctrl+alt+n</code> 反向提取（合并）</p></li><li><p><code>ctrl+shift+j</code>  合并文本行</p></li><li><p><code>ctlr+alt+m</code>  抽取代码块成为方法</p></li><li><p><code>ctrl+alt+p</code> 将当前值作为当前方法的一个参数</p></li><li><p><code>shift+f6</code> 重名包、类、文件、方法名、变量名等等</p></li><li><p><code>ctrl+shift+delete</code> 移除包裹代码</p></li></ul><p><a href="http://www.open-open.com/lib/view/open1454166356120.html" target="_blank" rel="noopener">更多重构技巧</a></p><p><strong>3.0  快捷操作</strong></p><ul><li><p><code>Ctrl+Alt+O</code>  优化导入的类和包</p></li><li><p><code>Ctrl＋Alt＋T</code>  可以把代码包在一块内，例如try/catch</p></li><li><p><code>Shift＋Click</code> 可以关闭文件</p></li><li><p><code>Alt＋Up and Alt＋Down</code> 可在方法间快速移动</p></li><li><p><code>Ctrl+1</code>  切换工程视图</p></li><li><p><code>Alt+Insert</code>  创建构造方法</p></li><li><p><code>Ctrl+O</code>  选择创建未实现的方法</p></li><li><p><code>alt+1</code> 快速打开工程面板</p></li><li><p><code>ctrl+shift+f12</code> 隐藏所有面板</p></li><li><p><code>f12</code> 回到上一个工具</p></li><li><p><code>ctrl+U</code>  定位到父类</p></li><li><p><code>alt+数字</code> 打开关闭有数字标记的面板</p></li><li><p><code>ctrl+W</code> 扩大选择</p></li><li><p><code>alt+J</code> 多处选择</p></li><li><p><code>Ctrl+Alt+Space</code> 类名或接口名提示</p></li><li><p><code>ctlr+shift+Enter</code></p><ol><li>为行末添加一个分号，即使光标不在行末;</li><li>为if,while,for语句生成小括号和大括号;</li><li>方法声明后添加大括号</li><li>如果一个语句已经补全，你使用该快捷键后会之间跳导下一行去，即使光标不在最后;</li></ol></li></ul><ul><li><p><code>alt+Enter+check regexp</code>  帮助编写正则表达式</p></li><li><p><code>altr+shift+up/down</code> 代码上下移动</p></li><li><p><code>ctrl+shift+up/down</code> 函数上下移动</p></li><li><p><code>Object.for/Object.cast</code>在代码后边加上<code>.xxx</code>可以生成例如for循环之类的模板。具体的<br>可以在editor → Postfix Completion中查看所有的代码补全后缀</p></li><li><p><code>ctrl+shift+↑↓</code> 代码换行</p></li><li><p><code>ctrl+[或]</code>  跳到大括号的开头或者结尾</p></li></ul><p><strong>4.0 版本控制</strong></p><ul><li><p><code>alt+&#39;</code> 版本控制弹窗</p></li><li><p><code>Alt+Shift+C</code> 对比最近修改的代码</p></li></ul><p><strong>5.0 技巧</strong></p><ul><li><p><code>ctrl+shift+A</code>  快速查找并打开某个操作</p><ul><li><p><code>ctrl+j</code>  查看动态模板</p></li><li><p>操作名称 Analyze Data Flow to Here 查看数据变量的向下传递过程</p></li><li><p>操作名称 Attach to Android Process 快速进入调试模式</p></li></ul></li></ul>]]></content>
    
    <summary type="html">
    
      &lt;h3 id=&quot;常用快捷键&quot;&gt;&lt;a href=&quot;#常用快捷键&quot; class=&quot;headerlink&quot; title=&quot;常用快捷键&quot;&gt;&lt;/a&gt;常用快捷键&lt;/h3&gt;&lt;p&gt; &lt;strong&gt;1.0 搜索or查看&lt;/strong&gt;&lt;/p&gt;
&lt;ul&gt;
&lt;li&gt;&lt;p&gt;&lt;code&gt;Ctrl+G&lt;/code&gt;  跳到指定的行&lt;/p&gt;
&lt;/li&gt;
&lt;li&gt;&lt;p&gt;&lt;code&gt;Ctrl+Shift+R&lt;/code&gt;  在选中的文件目录里替换&lt;/p&gt;
&lt;/li&gt;
&lt;li&gt;&lt;p&gt;&lt;code&gt;Ctrl+Shift+F&lt;/code&gt;  在选中的文件目录里搜索&lt;/p&gt;
&lt;/li&gt;
&lt;li&gt;&lt;p&gt;&lt;code&gt;Ctrl+N&lt;/code&gt;  查找类&lt;/p&gt;
&lt;/li&gt;
&lt;li&gt;&lt;p&gt;&lt;code&gt;Ctrl+Shift+N&lt;/code&gt;  查找文件&lt;/p&gt;
&lt;/li&gt;
&lt;li&gt;&lt;p&gt;&lt;code&gt;F2 或Shift+F2&lt;/code&gt;  高亮错误或警告快速定位&lt;/p&gt;
    
    </summary>
    
      <category term="android" scheme="http://yoursite.com/categories/android/"/>
    
    
  </entry>
  
  <entry>
    <title>关于Webview拍照或从相册上传图片处理总结</title>
    <link href="http://yoursite.com/2017/02/08/Webview%E6%8B%8D%E7%85%A7%E6%88%96%E4%BB%8E%E7%9B%B8%E5%86%8C%E4%B8%8A%E4%BC%A0%E5%9B%BE%E7%89%87%E5%A4%84%E7%90%86%E6%80%BB%E7%BB%93/"/>
    <id>http://yoursite.com/2017/02/08/Webview拍照或从相册上传图片处理总结/</id>
    <published>2017-02-08T09:30:00.000Z</published>
    <updated>2017-03-31T10:10:50.000Z</updated>
    
    <content type="html"><![CDATA[<h1 id="【Android开发技巧】-关于Webview拍照或从相册上传图片处理总结"><a href="#【Android开发技巧】-关于Webview拍照或从相册上传图片处理总结" class="headerlink" title="【Android开发技巧】 关于Webview拍照或从相册上传图片处理总结"></a>【Android开发技巧】 关于Webview拍照或从相册上传图片处理总结</h1><p><a href="http://www.jianshu.com/u/188cd52c1820" target="_blank" rel="noopener"><img src="http://upload.jianshu.io/users/upload_avatars/305662/229df9c9c66e?imageMogr2/auto-orient/strip|imageView2/1/w/144/h/144" alt="144"></a></p><p><strong>前言：</strong><br>各公司为了处理更多的业务流程， 一般都会加入H5与原生交互处理，方便快速开发，迭代项目。但，在Android中，H5与原生的交互处理的就没有iOS那么好。其中适配也是一个问题，Android系统版本众多，国内手机开发商都各自定制自家的系统，所以适配起来的话，也是一个不小的工作量。本文就总结一下我本人在公司项目使用到Webview中上传图片的处理。</p><p>WebView 上传图片, 想必很多人都碰到过这样的场景. 而且 WebView 在4.4前后的区别非常大, 比如对URL跳转的格式, 对JS的注入声明等等, 4.4以后的WebView 已经是chromium内核, 有多强大就无需我赘述. 说这些, 其实也是为了说明也因为WebView的前后变化太大了, 所以在低版本和版本上, WebView上传文件的方式都略有不同, 而且在安卓4.4.4的一些设备上难以保证所有机型都成功。</p><a id="more"></a><p>111_看图王.png</p><p>222222_看图王.jpg</p><p><strong>实现过程：</strong> 在Android4.4之前，Webview的webkit中支持openFileChooser.当Webview加载一个HTML页面，点击按钮需要模拟form提交的方式去上传文件时，就会回调：<br><code>openFileChooser(...)</code></p><p>然后在这个方法里接受并处理参数ValueCallback uploadMsg. 里面的 uri 就是所从本地选择的文件路径.</p><p>然后通过Intent的startActivityForResult(…) 方法跳转到系统选择文件的界面进行文件选择, 最后在:<br><code>onActivityResult(int requestCode, int resultCode, Intent data)</code></p><p>方法中获取data中的字符串路径， 并转换成Uri 格式，并传给uploadMsg 即可, 类似:</p><figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br></pre></td><td class="code"><pre><span class="line">String sourcePath = ImageUtil.retrievePath(this, mSourceIntent, data);</span><br><span class="line">if (TextUtils.isEmpty(sourcePath) || !new File(sourcePath).exists()) &#123; </span><br><span class="line">    Log.e(TAG, &quot;sourcePath empty or not exists.&quot;);</span><br><span class="line">    break;</span><br><span class="line">&#125;</span><br><span class="line">Uri uri = Uri.fromFile(new File(sourcePath));</span><br><span class="line">mUploadMsg.onReceiveValue(uri);</span><br></pre></td></tr></table></figure><p>这样, 接下来的上传工作, WebView会自动完成. 当然, 这是顺利的流程, 如果 onActivityResult(…) 中返回的 resultcode 不等于 Activity.RESULT_OK , 也要做一点处理, 不然再去点击第二次上传文件时是没有反应的. 类似这样:</p><figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br></pre></td><td class="code"><pre><span class="line">if (resultCode != Activity.RESULT_OK) &#123; </span><br><span class="line">    if (mUploadMsg != null) &#123; </span><br><span class="line">        mUploadMsg.onReceiveValue(null);</span><br><span class="line"> &#125; </span><br><span class="line">    return;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure><p><strong>传个null 即可 。</strong><br>OK, 上面就是4.4 以前的实现过程, 上面提及的代码在下载的demo里会有, 为保证篇幅不会放在文章里. 那么5.0及以上的sdk变动时, webkit不再支持 ：</p><p><code>openFileChooser(...)</code></p><p>而是提供了一个代替的方法:</p><figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br></pre></td><td class="code"><pre><span class="line">public boolean onShowFileChooser(WebView webView, ValueCallback&lt;Uri[]&gt; filePathCallback, FileChooserParams fileChooserParams) &#123;</span><br><span class="line"> return false;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure><p>这个方法的参数跟 openFileChooser(…) 方法很像, 其实作用都是类似的, 只是 从</p><p><code>ValueCallback uploadMsg 变成了 ValueCallback filePathCallback,</code></p><p>还多了FileChooserParams类型参数. fileChooserParams 其实是一个属性封装的参数, 里面包含了acceptType, title等这样的文件属性, 名称等信息.</p><p>所以, onShowFileChooser(…) 的使用方法跟 openFileChooser(…) 是很类似的, 这里通过 onActivityResult(…) 看两者的使用区别:</p><figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br><span class="line">28</span><br><span class="line">29</span><br><span class="line">30</span><br><span class="line">31</span><br><span class="line">32</span><br><span class="line">33</span><br><span class="line">34</span><br><span class="line">35</span><br><span class="line">36</span><br><span class="line">37</span><br><span class="line">38</span><br><span class="line">39</span><br><span class="line">40</span><br><span class="line">41</span><br><span class="line">42</span><br><span class="line">43</span><br><span class="line">44</span><br><span class="line">45</span><br><span class="line">46</span><br><span class="line">47</span><br><span class="line">48</span><br><span class="line">49</span><br><span class="line">50</span><br><span class="line">51</span><br></pre></td><td class="code"><pre><span class="line">@Override</span><br><span class="line">public void onActivityResult(int requestCode, int resultCode, Intent data) &#123;</span><br><span class="line">    if (resultCode != Activity.RESULT_OK) &#123;</span><br><span class="line">        if (mUploadMsg != null) &#123;</span><br><span class="line">            mUploadMsg.onReceiveValue(null);</span><br><span class="line">        &#125;</span><br><span class="line"></span><br><span class="line">        if (mUploadMsgForAndroid5 != null) &#123;         // for android 5.0+</span><br><span class="line">            mUploadMsgForAndroid5.onReceiveValue(null);</span><br><span class="line">        &#125;</span><br><span class="line">        return;</span><br><span class="line">    &#125;</span><br><span class="line">    switch (requestCode) &#123;</span><br><span class="line">        case REQUEST_CODE_IMAGE_CAPTURE:</span><br><span class="line">        case REQUEST_CODE_PICK_IMAGE: &#123;</span><br><span class="line">            try &#123;</span><br><span class="line">                if (Build.VERSION.SDK_INT &lt; Build.VERSION_CODES.LOLLIPOP) &#123;</span><br><span class="line">                    if (mUploadMsg == null) &#123;</span><br><span class="line">                        return;</span><br><span class="line">                    &#125;</span><br><span class="line"></span><br><span class="line">                    String sourcePath = ImageUtil.retrievePath(this, mSourceIntent, data);</span><br><span class="line"></span><br><span class="line">                    if (TextUtils.isEmpty(sourcePath) || !new File(sourcePath).exists()) &#123;</span><br><span class="line">                        Log.e(TAG, &quot;sourcePath empty or not exists.&quot;);</span><br><span class="line">                        break;</span><br><span class="line">                    &#125;</span><br><span class="line">                    Uri uri = Uri.fromFile(new File(sourcePath));</span><br><span class="line">                    mUploadMsg.onReceiveValue(uri);</span><br><span class="line"></span><br><span class="line">                &#125; else if (Build.VERSION.SDK_INT &gt;= Build.VERSION_CODES.LOLLIPOP) &#123;</span><br><span class="line">                    if (mUploadMsgForAndroid5 == null) &#123;        // for android 5.0+</span><br><span class="line">                        return;</span><br><span class="line">                    &#125;</span><br><span class="line"></span><br><span class="line">                    String sourcePath = ImageUtil.retrievePath(this, mSourceIntent, data);</span><br><span class="line"></span><br><span class="line">                    if (TextUtils.isEmpty(sourcePath) || !new File(sourcePath).exists()) &#123;</span><br><span class="line">                        Log.e(TAG, &quot;sourcePath empty or not exists.&quot;);</span><br><span class="line">                        break;</span><br><span class="line">                    &#125;</span><br><span class="line">                    Uri uri = Uri.fromFile(new File(sourcePath));</span><br><span class="line">                    mUploadMsgForAndroid5.onReceiveValue(new Uri[]&#123;uri&#125;);</span><br><span class="line">                &#125;</span><br><span class="line">            &#125; catch (Exception e) &#123;</span><br><span class="line">                e.printStackTrace();</span><br><span class="line">            &#125;</span><br><span class="line">            break;</span><br><span class="line">        &#125;</span><br><span class="line">    &#125;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure><p>主要是针对 5.0前后的系统做了一些区别处理, 其他无大异.</p><p><strong>提高兼容性的解决方案:</strong></p><ol><li>使用加强版的WebView, cordova , 可以考虑编译这个项目获得jar包, 然后导入项目中使用它的WebView组件.</li><li>也可以通过JS调用本地的方法自行实现上传.<br>以上两个方法的兼容性都相当不错, 可自行尝试.</li></ol><p><strong>可能导致失败的原因：</strong> 如果选择文件到上传文件的过程中失败, 有可能是以下原因导致的: 1. 文件的路径包含中文. (9部设备中, vivo X6D不支持中文路径包含中文) 2. 手机系统是Android 6.0以上 (API &gt;= 23), 且没有获得文件和摄像头权限.</p><p>如果你的项目中还兼容到4.0以下的版本, build.gradle 配置文件中的compileSdkVersion 和 targetSdkVersion 是16甚至更低, 那么恭喜你, 直接使用 openFileChooser(…) 这种处理方法即可.</p><p>主要类：<strong>MyWebChomeClient</strong></p><figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br><span class="line">28</span><br><span class="line">29</span><br><span class="line">30</span><br><span class="line">31</span><br><span class="line">32</span><br><span class="line">33</span><br><span class="line">34</span><br><span class="line">35</span><br></pre></td><td class="code"><pre><span class="line">/**</span><br><span class="line"> * MyWebChomeClient</span><br><span class="line"> */</span><br><span class="line">public class MyWebChomeClient extends WebChromeClient &#123;</span><br><span class="line"></span><br><span class="line">    private OpenFileChooserCallBack mOpenFileChooserCallBack;</span><br><span class="line"></span><br><span class="line">    public MyWebChomeClient(OpenFileChooserCallBack openFileChooserCallBack) &#123;</span><br><span class="line">        mOpenFileChooserCallBack = openFileChooserCallBack;</span><br><span class="line">    &#125;</span><br><span class="line"></span><br><span class="line">    public void openFileChooser(ValueCallback&lt;Uri&gt; uploadMsg, String acceptType) &#123;</span><br><span class="line">        mOpenFileChooserCallBack.openFileChooserCallBack(uploadMsg, acceptType);</span><br><span class="line">    &#125;</span><br><span class="line"></span><br><span class="line">    public void openFileChooser(ValueCallback&lt;Uri&gt; uploadMsg) &#123;</span><br><span class="line">        openFileChooser(uploadMsg, &quot;&quot;);</span><br><span class="line">    &#125;</span><br><span class="line"></span><br><span class="line">    public void openFileChooser(ValueCallback&lt;Uri&gt; uploadMsg, String acceptType, String capture) &#123;</span><br><span class="line">        openFileChooser(uploadMsg, acceptType);</span><br><span class="line">    &#125;</span><br><span class="line"></span><br><span class="line">    public boolean onShowFileChooser(WebView webView, ValueCallback&lt;Uri[]&gt; filePathCallback,</span><br><span class="line">                                     FileChooserParams fileChooserParams) &#123;</span><br><span class="line">        return mOpenFileChooserCallBack.openFileChooserCallBackAndroid5(webView, filePathCallback, fileChooserParams);</span><br><span class="line">    &#125;</span><br><span class="line"></span><br><span class="line">    public interface OpenFileChooserCallBack &#123;</span><br><span class="line">        // for API - Version below 5.0.</span><br><span class="line">        void openFileChooserCallBack(ValueCallback&lt;Uri&gt; uploadMsg, String acceptType);</span><br><span class="line"></span><br><span class="line">        // for API - Version above 5.0 (contais 5.0).</span><br><span class="line">        boolean openFileChooserCallBackAndroid5(WebView webView, ValueCallback&lt;Uri[]&gt; filePathCallback,</span><br><span class="line">                                                FileChooserParams fileChooserParams);</span><br></pre></td></tr></table></figure>]]></content>
    
    <summary type="html">
    
      &lt;h1 id=&quot;【Android开发技巧】-关于Webview拍照或从相册上传图片处理总结&quot;&gt;&lt;a href=&quot;#【Android开发技巧】-关于Webview拍照或从相册上传图片处理总结&quot; class=&quot;headerlink&quot; title=&quot;【Android开发技巧】 关于Webview拍照或从相册上传图片处理总结&quot;&gt;&lt;/a&gt;【Android开发技巧】 关于Webview拍照或从相册上传图片处理总结&lt;/h1&gt;&lt;p&gt;&lt;a href=&quot;http://www.jianshu.com/u/188cd52c1820&quot; target=&quot;_blank&quot; rel=&quot;noopener&quot;&gt;&lt;img src=&quot;http://upload.jianshu.io/users/upload_avatars/305662/229df9c9c66e?imageMogr2/auto-orient/strip|imageView2/1/w/144/h/144&quot; alt=&quot;144&quot;&gt;&lt;/a&gt;&lt;/p&gt;
&lt;p&gt;&lt;strong&gt;前言：&lt;/strong&gt;&lt;br&gt;各公司为了处理更多的业务流程， 一般都会加入H5与原生交互处理，方便快速开发，迭代项目。但，在Android中，H5与原生的交互处理的就没有iOS那么好。其中适配也是一个问题，Android系统版本众多，国内手机开发商都各自定制自家的系统，所以适配起来的话，也是一个不小的工作量。本文就总结一下我本人在公司项目使用到Webview中上传图片的处理。&lt;/p&gt;
&lt;p&gt;WebView 上传图片, 想必很多人都碰到过这样的场景. 而且 WebView 在4.4前后的区别非常大, 比如对URL跳转的格式, 对JS的注入声明等等, 4.4以后的WebView 已经是chromium内核, 有多强大就无需我赘述. 说这些, 其实也是为了说明也因为WebView的前后变化太大了, 所以在低版本和版本上, WebView上传文件的方式都略有不同, 而且在安卓4.4.4的一些设备上难以保证所有机型都成功。&lt;/p&gt;
    
    </summary>
    
      <category term="android" scheme="http://yoursite.com/categories/android/"/>
    
    
  </entry>
  
  <entry>
    <title>第3章 DOM操作</title>
    <link href="http://yoursite.com/2017/02/08/%E7%AC%AC3%E7%AB%A0%20DOM%E6%93%8D%E4%BD%9C/"/>
    <id>http://yoursite.com/2017/02/08/第3章 DOM操作/</id>
    <published>2017-02-08T09:30:00.000Z</published>
    <updated>2017-03-24T02:33:28.000Z</updated>
    
    <content type="html"><![CDATA[<h1 id="第3章-DOM操作"><a href="#第3章-DOM操作" class="headerlink" title="第3章 DOM操作"></a>第3章 DOM操作</h1><h2 id="3-1-认识DOM"><a href="#3-1-认识DOM" class="headerlink" title="3.1 认识DOM"></a>3.1 认识DOM</h2><p>文档对象模型DOM（Document Object Model）定义访问和处理HTML文档的标准方法。DOM 将HTML文档呈现为带有元素、属性和文本的树结构（节点树）。</p><p><strong>先来看看下面代码:</strong></p><p><strong><img src="http://img.mukewang.com/52e4be610001c67307860420.jpg" alt="img"></strong></p><p><strong>将HTML代码分解为DOM**</strong>节点层次图:**</p><p><strong><img src="http://img.mukewang.com/52e4bd0f0001dd8d04830279.jpg" alt="img"></strong></p><a id="more"></a><p><strong>HTML文档可以说由节点构成的集合，三种常见的DOM节点:</strong></p><p><strong>1. 元素节点：</strong>上图中<html>、<body>、<p>等都是元素节点，即标签。</p><p><strong>2. 文本节点:</strong>向用户展示的内容，如<li>…</li>中的JavaScript、DOM、CSS等文本。</p><p><strong>3. 属性节点:</strong>元素属性，如<a>标签的链接属性href=”<a href="http://www.imooc.com&quot;。" target="_blank" rel="noopener">http://www.imooc.com&quot;。</a></a></p><p><strong>看下面代码:</strong></p><figure class="highlight javascript"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><span class="line">&lt;a href=<span class="string">"http://www.imooc.com"</span>&gt;JavaScript DOM&lt;<span class="regexp">/a&gt;</span></span><br></pre></td></tr></table></figure><p><a href="http://img.mukewang.com/52e4bdb80001064c04480196.jpg" target="_blank" rel="noopener"><img src="http://img.mukewang.com/52e4bdb80001064c04480196.jpg" alt="img"></a></p></body></html></p>]]></content>
    
    <summary type="html">
    
      &lt;h1 id=&quot;第3章-DOM操作&quot;&gt;&lt;a href=&quot;#第3章-DOM操作&quot; class=&quot;headerlink&quot; title=&quot;第3章 DOM操作&quot;&gt;&lt;/a&gt;第3章 DOM操作&lt;/h1&gt;&lt;h2 id=&quot;3-1-认识DOM&quot;&gt;&lt;a href=&quot;#3-1-认识DOM&quot; class=&quot;headerlink&quot; title=&quot;3.1 认识DOM&quot;&gt;&lt;/a&gt;3.1 认识DOM&lt;/h2&gt;&lt;p&gt;文档对象模型DOM（Document Object Model）定义访问和处理HTML文档的标准方法。DOM 将HTML文档呈现为带有元素、属性和文本的树结构（节点树）。&lt;/p&gt;
&lt;p&gt;&lt;strong&gt;先来看看下面代码:&lt;/strong&gt;&lt;/p&gt;
&lt;p&gt;&lt;strong&gt;&lt;img src=&quot;http://img.mukewang.com/52e4be610001c67307860420.jpg&quot; alt=&quot;img&quot;&gt;&lt;/strong&gt;&lt;/p&gt;
&lt;p&gt;&lt;strong&gt;将HTML代码分解为DOM**&lt;/strong&gt;节点层次图:**&lt;/p&gt;
&lt;p&gt;&lt;strong&gt;&lt;img src=&quot;http://img.mukewang.com/52e4bd0f0001dd8d04830279.jpg&quot; alt=&quot;img&quot;&gt;&lt;/strong&gt;&lt;/p&gt;
    
    </summary>
    
      <category term="JS" scheme="http://yoursite.com/categories/JS/"/>
    
    
  </entry>
  
  <entry>
    <title>Gradle插件学习笔记</title>
    <link href="http://yoursite.com/2017/02/08/Gradle%E6%8F%92%E4%BB%B6%E5%AD%A6%E4%B9%A0%E7%AC%94%E8%AE%B0/"/>
    <id>http://yoursite.com/2017/02/08/Gradle插件学习笔记/</id>
    <published>2017-02-08T09:26:00.000Z</published>
    <updated>2017-03-24T02:31:18.000Z</updated>
    
    <content type="html"><![CDATA[<h1 id="Gradle插件学习笔记"><a href="#Gradle插件学习笔记" class="headerlink" title="Gradle插件学习笔记"></a>Gradle插件学习笔记</h1><h2 id="1-简介"><a href="#1-简介" class="headerlink" title="1 简介"></a>1 简介</h2><p>Gradle是一个基于Apache Ant和Apache Maven概念的项目自动化建构工具。它使用一种基于Groovy的特定领域语言(DSL)来声明项目设置，抛弃了基于XML的各种繁琐配置。</p><h3 id="1-1-新构建系统的目标是："><a href="#1-1-新构建系统的目标是：" class="headerlink" title="1.1 新构建系统的目标是："></a>1.1 新构建系统的目标是：</h3><p>新构建系统的目标是：</p><ul><li><p>使得代码和资源的重用更加简单</p></li><li><p>使得创建同一应用程序的不同版本更加容易，不管是多个apk版本还是同一版本的多种定制</p></li><li><p>使得配置，扩展和自定义构建更加容易</p></li><li><p>良好的IDE集成</p><a id="more"></a></li></ul><h4 id="1-2-为什么使用Gradle"><a href="#1-2-为什么使用Gradle" class="headerlink" title="1.2 为什么使用Gradle"></a>1.2 为什么使用Gradle</h4><ul><li>使用特定领域语言(DSL)来描述和控制构建逻辑</li><li>构建脚本基于Groovy语言，允许通过DSL混合元素声明和通过代码控制DSL元素，来产生自定义的构建逻辑</li><li>支持Maven和(或者)Ivy管理依赖</li><li>非常灵活。允许使用最佳实践，但也不强制自己的实现方式</li><li>插件能够提供自己的DSL和API供构建脚本使用</li><li>提供优秀的工具API以供IDE集成</li></ul><h2 id="2-基本项目"><a href="#2-基本项目" class="headerlink" title="2 基本项目"></a>2 基本项目</h2><p>Gradle项目通过项目根目录下的 build.gradle 文件来描述构建过程</p><h4 id="2-1-简单的构建文件"><a href="#2-1-简单的构建文件" class="headerlink" title="2.1 简单的构建文件"></a>2.1 简单的构建文件</h4><p>最简单的Java项目构建文件 build.gradle<br><code>apply plugin: &#39;java&#39;</code><br>这个脚本应用了Gradle的Java插件。这个插件了提供构建和测试Java应用的所有功能</p><p>最简单的Android项目的构建文件包含以下内容：</p><pre><code>buildscript {    repositories {        mavenCentral()    }    dependencies {        classpath 'com.android.tools.build:gradle:0.11.1'    }}apply plugin: 'android'android {    compileSdkVersion 19    buildToolsVersion "19.0.0"}    </code></pre><p>Note(译注): 最新的android插件声明<br><code>apply plugin: &#39;com.android.application&#39;</code></p><p>在这个Android构建脚本里包含了三个主要内容：<br><code>buildscript { ... }</code> 配置了驱动构建过程的代码。在这个案例中，声明了使用Maven仓库，以及一个Maven文件(artifact)的依赖路径。这个文件就是包含了Android Gradle插件的库，版本为0.11.1</p><p>然后，android插件被应用，像之前的Java插件一样</p><p>最后，<code>android { ... }</code> 配置了anroid构建过程需要的参数。这也是Adnroid DSL的入口。默认的情况下，只有编译目标SDK版本，和构建工具版本是必须的。在脚本中，对应的是<code>compileSdkVersion</code>和<code>buildtoolsVersion</code>属性。<code>compileSdkVersion</code>和旧编译系统中<code>project.properties</code>文件中的<code>target</code>属性对应。这个新属性<code>compileSdkVersion</code>可以是一个int值(API Level)或者一个和之前的<code>target</code>属性值一样的字符串</p><p><strong>重点：</strong> 你应该只应用android插件，同时应用java插件会导致构建错误</p><p><strong>注意：</strong> 你同样需要一个<code>local.properties</code>文件来指明SDK的路径，和<code>build.gradle</code>在同一路径下，在文件中使用<code>sdk.dir</code>属性指明。或者，你可以设置ANDROID_HOME环境变量。两者是一致的，你可以选择一种你喜欢的方式。</p><h3 id="2-2-项目结构"><a href="#2-2-项目结构" class="headerlink" title="2.2 项目结构"></a>2.2 项目结构</h3><p>前面的android构建脚本使用了默认的文件夹目录结构。Gradle遵循约定优于配置的原则，在可能的情况下提供了合理的默认配置参数。</p><p>基本的项目包含两个“source sets”组件。main source code和test code，位于以下的目录中:</p><p><code>src/main/ src/androidTest/</code></p><p>在这些目录中，都存在目录对应源码组件</p><p>不管是Java还是Android插件，源码目录和资源目录都如下 ：</p><p><code>java/ resources/</code></p><p>对于Android插件，还有特有的文件和目录</p><p><code>AndroidManifest.xml res/ assets/ aidl/ rs/ jni/</code></p><h4 id="2-2-1-配置项目结构"><a href="#2-2-1-配置项目结构" class="headerlink" title="2.2.1 配置项目结构"></a>2.2.1 配置项目结构</h4><p>当默认项目结构不合适的时候，可以配置项目目录。根据Gradle文档，可以通过下面的脚本重新配置Java项目的sourceSets：</p><pre><code>sourceSets {    main {        java {            srcDir 'src/java'        }        resources {            srcDir 'src/resources'        }    }}</code></pre><p><strong>Note</strong>: srcDir 会添加指定的目录到源文件目录列表中(这在Gradele文档中没有提及，但是实际上是这样的)。</p><p>为了替换默认的源文件目录列表，可以使用srcDirs来指定目录数组。这也是一种不同的使用方式：</p><pre><code>sourceSets {    main.java.srcDirs = ['src/java']    main.resources.srcDirs = ['src/resources']}</code></pre><p>更多的信息，参考Gradle文档中的Java插件<a href="http://gradle.org/docs/current/userguide/java_plugin.html" target="_blank" rel="noopener">内容</a></p><p>Android插件使用相似的语法，但是由于使用是自己的sourceSets，相应的目录在(build.gradle文件中的)android对象中指定</p><p>下面是一个示例，它使用旧项目的源码结构，并且将androidTest sourceSet映射到tests目录</p><pre><code>android {    sourceSets {        main {            manifest.srcFile 'AndroidManifest.xml'            java.srcDirs = ['src']            resources.srcDirs = ['src']            aidl.srcDirs = ['src']            renderscript.srcDirs = ['src']            res.srcDirs = ['res']            assets.srcDirs = ['assets']        }        androidTest.setRoot('tests')    }}</code></pre><p><strong>Note</strong>: 由于旧的结构将所有的源文件 (java, aidl, renderscript, and java资源文件)放在一个目录里，我们需要映射这些sourceSet组件到src目录。</p><p><strong>Note</strong>: setRoot() 方法将整个sourceSet(包含子目录)指向新的目录。比如上面，将<code>src/androidTest/*</code> 指向了 <code>tests/*</code></p><p>以上是Android特有的，如果配置在Java sourceSets中就没有作用</p><h3 id="2-3-构建任务"><a href="#2-3-构建任务" class="headerlink" title="2.3 构建任务"></a>2.3 构建任务</h3><h4 id="2-3-1-通用任务"><a href="#2-3-1-通用任务" class="headerlink" title="2.3.1 通用任务"></a>2.3.1 通用任务</h4><p>在build文件中应用一个插件将自动创建一系列构建任务。Java插件和Android插件都是这样。任务约定如下：</p><ul><li>assemble</li></ul><p>组合项目输出</p><ul><li>check</li></ul><p>执行所有检查</p><ul><li>build</li></ul><p>执行assemble和check两个task的所有工作</p><ul><li>clean</li></ul><p>任务<code>assemble</code>, <code>check</code> 和 <code>build</code> 不会做任何实际的事情。他们只是锚点任务(anchor tasks)，插件依赖他们来添加实际执行实际操作的任务。</p><p>这样就不需要考虑项目是什么类型，使用的是什么插件，都可以执行同样的任务。<br>例如，使用findbugs插件，会创建新的任务，并让<code>check</code>依赖这个任务，使得<code>check</code>被调用时这个任务就会被调用。</p><p>在终端(命令行，gradle项目目录下)中运行下面的任务可以查询到高级别的任务：</p><p><code>gradle tasks</code> 运行以下命令可以看到全部任务和任务依赖关系：</p><p><code>gradle tasks --all</code></p><p><strong>Note</strong>: Gradle自动监视一个任务声明的输入输出文件。再次执行构建任务时，如果文件没有改变，Gradle会指明所有任务为<code>UP-TO-DATE</code>，意味着任务不需要执行。这样的话，任务可以正确地互相依赖，而不不会导致非必须的构建操作</p><h4 id="2-3-2-Java项目的任务"><a href="#2-3-2-Java项目的任务" class="headerlink" title="2.3.2 Java项目的任务"></a>2.3.2 Java项目的任务</h4><p>Java插件主要创建两个任务，下面是这两个锚点任务的依赖关系</p><ul><li>assemble<ul><li>jar<br>这个任务创建输出</li></ul></li><li>ckeck<ul><li>test<br>这个任务运行测试</li></ul></li></ul><p><code>jar</code>任务直接或间接地依赖其他任务：例如<code>classes</code>任务将编译Java源码<br><code>testClasses</code>任务用于编译测试的，但是这个任务很少被调用，因为<code>test</code>任务依赖于它(就像依赖<code>classes</code>任务一样)</p><p>通常来说，你只需要调用<code>assemble</code>或者<code>check</code>任务，而不需要调用其他任务。</p><p>你可以在<a href="http://gradle.org/docs/current/userguide/java_plugin.html" target="_blank" rel="noopener">Gradle Java</a>插件文档看到Java插件的全部任务和它们的描述</p><h4 id="2-3-3-Android任务"><a href="#2-3-3-Android任务" class="headerlink" title="2.3.3 Android任务"></a>2.3.3 Android任务</h4><p>Android插件使用同样的约定来保持和其他插件的兼容，并且添加了额外的锚点任务：</p><ul><li>assemble  这个任务组织项目的输出</li><li>check   这个项目运行所有检查</li><li>connectedCheck  运行检查需要一个已连接的设备或者模拟器。并在所有已连接的设备上异步运行。</li><li>deviceCheck  通过APIs连接远程设备并运行检查。这通常在CI服务器上运行。</li><li>build  运行<code>assemble</code>和<code>check</code></li><li>clean  清理项目输出</li></ul><p>新的锚点任务是必须的，以保证在不需要设备连接的情况下能运行常规检查。<br>需要注意的是，<code>build</code>任务并不依赖<code>deviceCheck</code>或者<code>connectedCheck</code></p><p>一个Android项目至少有两个输出：debug APK 和 release APK。它们每一个都有自己的锚点任务来帮助它们完成独立的构建：</p><ul><li>assemble<ul><li>assembleDebug</li><li>assembleRelease</li></ul></li></ul><p>它们都依赖其它任务来完成构建一个apk所需要的多个步骤。<code>assemble</code>任务依赖这两个任务，所以调用<code>assemble</code>会生成两个APK。</p><blockquote><p>Tip: Gradle支持在命令行中使用camel形式的任务名缩写。<br>例如：<br>gradle aR和gradle assembleRelease是一样的，因为没有别的任务名有同样的缩写</p></blockquote><p>锚点任务<code>check</code>也有自己的依赖：</p><ul><li>check<ul><li>lint</li></ul></li><li>connectedCheck<ul><li>connectedAndroidTest</li><li>connectedUiAutomatorTest (not implemented yet)</li></ul></li><li>deviceCheck<ul><li>依赖于当其它插件实现测试扩展点时所创建的任务。</li></ul></li></ul><p>最终，插件会为所有构建类型(debug, release, test)创建install/uninstall任务，如果输出文件可以安装的话(必须签名)。</p><h3 id="2-4-基本的构建过程定制"><a href="#2-4-基本的构建过程定制" class="headerlink" title="2.4 基本的构建过程定制"></a>2.4 基本的构建过程定制</h3><p>Android插件提供了大量DSL来直接从构建系统中定制大多数事情。</p><h4 id="2-4-1-Manifest属性"><a href="#2-4-1-Manifest属性" class="headerlink" title="2.4.1 Manifest属性"></a>2.4.1 Manifest属性</h4><p>通过DSL，可以配置以下manifest属性：</p><ul><li>minSdkVersion</li><li>targetSdkVersion</li><li>versionCode</li><li>versionName</li><li>applicationId (实际的packageName – 前往 ApplicationId versus PackageName 查看更多)</li><li>Package Name for the test application</li><li>Instrumentation test runner</li></ul><p>例如:</p><pre><code>android {    compileSdkVersion 19    buildToolsVersion "19.0.0"    defaultConfig {        versionCode 12        versionName "2.0"        minSdkVersion 16        targetSdkVersion 16    }}</code></pre><p>配置项位于<code>android</code>元素中的<code>defaultConfig</code>元素中。</p><p>之前版本的<code>Android Plugin</code>使用<code>packageName</code>来配置<code>manifest</code>文件的<code>packageName</code>属性。从0.11.1版本开始，你应该在<code>build.gradle</code>文件使用<code>applicationId</code>来配置<code>manifest</code>文件的<code>packageName</code> 属性。<br>这是为了消除Android应用的<code>packageName</code>(作为Android应用的ID)和java包名之间的疑义。</p><p>在构建文件中定义的强大之处在于它可以是动态的。<br>例如，可以从一个文件中读取版本名称，或者使用自定义的逻辑：</p><pre><code>def computeVersionName() {    ...}android {    compileSdkVersion 19    buildToolsVersion "19.0.0"    defaultConfig {        versionCode 12        versionName computeVersionName()        minSdkVersion 16        targetSdkVersion 16    }}</code></pre><p><strong>Note</strong>: 函数名不要与指定范围内已经存在的getter方法名冲突。例如，在<code>defaultConfig { ...}</code>中调用<code>getVersionName()</code>会自动使用defaultConfig.getVersionName()，而不是你自定义的其它<code>getVersionName()</code>。</p><p>如果属性没有通过DSL设置，那么默认的属性值会被使用。下面是默认的属性值列表：</p><table><thead><tr><th>Property Name</th><th style="text-align:center">Default value in DSL</th><th style="text-align:right">object    Default value</th></tr></thead><tbody><tr><td>versionCode</td><td style="text-align:center">-1</td><td style="text-align:right">value from manifest if present</td></tr><tr><td>versionName</td><td style="text-align:center">null</td><td style="text-align:right">value from manifest if present</td></tr><tr><td>minSdkVersion</td><td style="text-align:center">-1</td><td style="text-align:right">value from manifest if present</td></tr><tr><td>targetSdkVersion</td><td style="text-align:center">-1</td><td style="text-align:right">value from manifest if present</td></tr><tr><td>applicationId</td><td style="text-align:center">null</td><td style="text-align:right">value from manifest if present</td></tr><tr><td>testApplicationId</td><td style="text-align:center">null</td><td style="text-align:right">applicationId + “.test”</td></tr><tr><td>testInstrumentationRunner</td><td style="text-align:center">null</td><td style="text-align:right">android.test.InstrumentationTestRunner</td></tr><tr><td>signingConfig</td><td style="text-align:center">null</td><td style="text-align:right">null</td></tr><tr><td>proguardFile</td><td style="text-align:center">N/A (set only)</td><td style="text-align:right">N/A (set only)</td></tr><tr><td>proguardFiles</td><td style="text-align:center">N/A (set only)</td><td style="text-align:right">N/A (set only)</td></tr></tbody></table><p>如果你在构建脚本中使用自定义的逻辑读取这些属性，那么第二列的属性就很重要。例如，你可能这样写：</p><pre><code>if (android.defaultConfig.testInstrumentationRunner == null) {    // assign a better default...}</code></pre><p>如果这个值是null，那么在构建过程中会被第三列的默认值替代，但是DSL元素不会包含这个默认值(第三列的值)，所以你查询不到这个值。这是为了防止解析应用的manifest文件，除非真的必要。</p><h4 id="2-4-2-构建类型-Build-Types"><a href="#2-4-2-构建类型-Build-Types" class="headerlink" title="2.4.2 构建类型(Build Types)"></a>2.4.2 构建类型(Build Types)</h4><p>默认情况下，Android插件会自动设置项目同时构建debug和release版本的应用程序。<br>这两个版本的不同之处主要在于能否在一个安全设备上调试程序，和APK如何签名。</p><p>debug版本使用一个自动创建的密钥/证书，并使用已知的name/password来签名(防止构建过程中出现请求提示)。release版本在构建过程中没有签名，需要稍后签名。</p><p>这些配置通过一个构建类型(BuildTpye)对象来设置。默认情况下，debug和release这两个构建类型都会被创建。</p><p>Android插件允许自定义这两个实例，也允许创建其它构建类型。这些都在buildTypes的DSL容器中配置：</p><pre><code>android {    buildTypes {        debug {            applicationIdSuffix ".debug"        }        jnidebug.initWith(buildTypes.debug)        jnidebug {            packageNameSuffix ".jnidebug"            jniDebuggable true        }    }}</code></pre><p>上面的代码片段完成来以下功能：</p><ul><li>配置默认的debug构建类型：</li><li>将包名设置成<app appliationid="">.debug，以便在同一设备上同时安装debug和release版本</app></li><li>创建了一个新的名为jnidebug的构建类型，是debug构建类型的一个副本</li><li>配置jnidebug构建类型，允许调试JNI组件，并且添加一个不同的包名后缀</li></ul><p>创建一个新的构建类型就像在<code>buildTypes</code>容器中使用一个新的元素一样简单，可以通过调用<code>initWith()</code>或者使用闭包来配置</p><table><thead><tr><th>Property name</th><th style="text-align:center">Default values for debug</th><th style="text-align:right">Default values for release / other</th></tr></thead><tbody><tr><td>debuggable</td><td style="text-align:center">true</td><td style="text-align:right">false</td></tr><tr><td>jniDebuggable</td><td style="text-align:center">false</td><td style="text-align:right">false</td></tr><tr><td>renderscriptDebuggable</td><td style="text-align:center">false</td><td style="text-align:right">false</td></tr><tr><td>renderscriptOptimLevel</td><td style="text-align:center">3</td><td style="text-align:right">3</td></tr><tr><td>applicationIdSuffix</td><td style="text-align:center">null</td><td style="text-align:right">null</td></tr><tr><td>versionNameSuffix</td><td style="text-align:center">null</td><td style="text-align:right">null</td></tr><tr><td>signingConfig</td><td style="text-align:center">android.signingConfigs.debug</td><td style="text-align:right">null</td></tr><tr><td>zipAlignEnabled</td><td style="text-align:center">false</td><td style="text-align:right">true</td></tr><tr><td>minifyEnabled</td><td style="text-align:center">false</td><td style="text-align:right">false</td></tr><tr><td>proguardFile</td><td style="text-align:center">N/A (set only)</td><td style="text-align:right">N/A (set only)</td></tr><tr><td>proguardFiles</td><td style="text-align:center">N/A (set only)</td><td style="text-align:right">N/A (set only)</td></tr></tbody></table><p>除了以上这些属性，Build Types还可以通过源码和资源来影响构建过程。<br>每一个构建类型都会创建一个匹配的sourceSet，默认的路径为：<br><code>src/&lt;buildtypename&gt;/</code></p><p>这意味这新的构建类型的名字不能是main或者androidTest(这是插件强制要求的)，而构建类型的名称必须是唯一的。</p><p>像其它sourceSet一样，构建类型的sourceSet可以重新被定向：</p><pre><code>android {    sourceSets.jnidebug.setRoot('foo/jnidebug')}</code></pre><p>另外，每一个Build Type都会创建一个<code>assemble&lt;BuildTypeName&gt;</code>任务。</p><p>在前面，<code>assembleDebug</code>和<code>assembleRelease</code>已经提到过了，这就是它们的来源。当debug和release构建类型被预创建的时候，它们相关的任务就被自动创建了，比如<code>assembleDebug</code>和<code>assembleRelease</code><br>上面的build.gradle片段同样会创建<code>assembleJnidebug</code>任务，<code>assemble</code>会像依赖<code>assembleDebug</code>和<code>assembleRelease</code>任务一样依赖<code>assembleJnidebug</code>。</p><blockquote><p>Tip: 你可以在命令行下输入gradle aJ来运行assembleJnidebug任务。</p></blockquote><p>可能用到的场景：</p><ul><li>只有debug模式才需要的权限，而release模式不需要</li><li>自定义debug实现</li><li>debug模式使用不同的资源(例如，资源取值与签名证书绑定)</li><li>BuildType的源码和资源通过以下方式使用：</li><li>manifest文件合并到app的manifest文件中</li><li>源码作为另一个源码目录</li><li>资源叠加到main的资源中，取代已经存在的值</li></ul><h4 id="2-4-3-签名配置"><a href="#2-4-3-签名配置" class="headerlink" title="2.4.3 签名配置"></a>2.4.3 签名配置</h4><ul><li>对一个应用程序签名需要以下：</li><li>一个keystore</li><li>一个keystore密码</li><li>一个key的别名</li><li>一个key密码</li><li>存储类型</li></ul><p>位置，别名，两个密码和存储类型一个组成一个签名配置(SigningConfig)<br>默认情况下，debug签名配置使用一个debug keystore，已知的密码和已知的别名以及别名密码。<br>debug keystore位于<code>$HOME/.android/debug.keystore</code>，如果没有的话会自动创建一个。<br>debug构建类型会自动使用debug SigningConfig。</p><p>可以创建其它签名配置或者自定义默认内建配置。通过signingConfigs DSL容器来配置</p><pre><code>android {    signingConfigs {        debug {            storeFile file("debug.keystore")        }        myConfig {            storeFile file("other.keystore")            storePassword "android"            keyAlias "androiddebugkey"            keyPassword "android"        }    }    buildTypes {        foo {            debuggable true            jniDebuggable true            signingConfig signingConfigs.myConfig        }    }}</code></pre><p>上面的片段修改debug keystore的位置到项目根目录下。这会影响任何使用它的构建类型，在这个案例中，受影响的是<code>debug</code>构建类型。<br>这里也创建了一个新的签名配置和一个使用这个新签名配置的行的构建类型。</p><p><strong>Note: </strong>只有默认路径下debug keystore不存在的时候会被自动创建。改变debug keystore的路径则不会在新的路径下自动创建debug keystore。创建一个名字不同的签名配置，但是使用默认的debug keystore路径，会自动创建debug keystore。也就是说，是否自动创建debug keystore，是由keystore的位置决定，而不是配置的名称。</p><p><strong>Note: </strong>keystore的路径通常是项目根目录的相对路径，但是也可以使用绝对路径，尽管不推荐这样(debug keystore除外，因为它会自动被创建)。</p><p><strong>Note:</strong>如果你要把这些文件添加到版本控制系统中，你可能不想把密码写在文件中。下面的Stack Overflow连接提供了从从控制台或者环境变量读取的方法。</p><p><a href="http://stackoverflow.com/questions/18328730/how-to-create-a-release-signed-apk-file-using-gradle" target="_blank" rel="noopener">http://stackoverflow.com/questions/18328730/how-to-create-a-release-signed-apk-file-using-gradle</a></p><h4 id="2-4-4-运行ProGuard"><a href="#2-4-4-运行ProGuard" class="headerlink" title="2.4.4 运行ProGuard"></a>2.4.4 运行ProGuard</h4><p>ProGuard从Gradle plugin for ProGuard 4.10开始支持的(since Gradle plugin 0.4)。如果构建类型的<code>minifyEnabled</code>属性被设置为true，那么Progruard插件会自动被添加进来，对应的任务也自动被创建。</p><p><strong>Note:</strong> 从Gradle插件版本0.14.0开始BuildType.runProguard更改为minifyEnabled属性。具体请参考<a href="http://tools.android.com/tech-docs/new-build-system" target="_blank" rel="noopener">Release notes</a></p><pre><code>android {    buildTypes {        release {            minifyEnabled true            proguardFile getDefaultProguardFile('proguard-android.txt')        }    }    productFlavors {        flavor1 {        }        flavor2 {            proguardFile 'some-other-rules.txt'        }    }}</code></pre><p>Variant会使用所有声明的规则文件，包括声明在相应的Build Type和flavor中的。</p><p>SDK中有两个默认的规则文件：</p><ul><li>proguard-android.txt</li><li>proguard-android-optimize.txt</li></ul><p>它们位于sdk路径下，使用getDefaultProguardFile()可以获取文件的完整路径。它们除了是否要进行优化之外，其它都是相同的。</p><h4 id="2-4-5-压缩资源文件"><a href="#2-4-5-压缩资源文件" class="headerlink" title="2.4.5 压缩资源文件"></a>2.4.5 压缩资源文件</h4><p>构建时可以自动移除没有被使用的资源文件。更多详细信息请查看文档资源文件压缩</p><h2 id="3-依赖关系，Android库项目和多项目设置"><a href="#3-依赖关系，Android库项目和多项目设置" class="headerlink" title="3 依赖关系，Android库项目和多项目设置"></a>3 依赖关系，Android库项目和多项目设置</h2><p>Gradle项目可以依赖其它组件，这些组件可以是外部二进制包，或者其它Gradle项目。</p><h3 id="3-1-依赖二进制包"><a href="#3-1-依赖二进制包" class="headerlink" title="3.1 依赖二进制包"></a>3.1 依赖二进制包</h3><p>####3.1.1 本地包</p><p>为了配置一个外部库jar依赖，你需要在<code>compile</code>配置中添加一个依赖</p><pre><code>dependencies {    compile files('libs/foo.jar')}android {    ...}</code></pre><p><strong>Note:</strong> <code>dependenciesDSL</code>元素是标准Gradle API的一部分，并不属于<code>android</code>元素。</p><p><code>compile</code>配置是用来编译main应用的。任何添加到编译路径中的东西都会被打包到最终的apk文件中。<br>下面是其它一些在添加依赖时可能用到的配置：</p><ul><li><code>compile</code>: 主module</li><li><code>androidTestCompil</code>e: 测试module</li><li><code>debugCompile</code>: debug构建类型的编译</li><li><code>releaseCompile</code>: release构建类型的编译</li></ul><p>因为构建一个apk必然有一个相关的构建类型，所以apk通常至少有两个编译配置：<code>compile</code>和<code>&lt;buildtype&gt;Compile</code><br>创建一个构建类型时会自动创建一个基于它名字的编译配置<code>&lt;buildtype&gt;Compile</code></p><p>当在debug版本里需要使用一个自定义库（例如记录crash信息），而release版本不需要，或者他们依赖同一个库的不同版本的时候，会非常有用。</p><p><strong>也可以通过添加一个目录来依赖目录下的所有jar文件： <code>compile fileTree(dir: &#39;libs&#39;, include: [&#39;*.jar&#39;])</code></strong></p><h4 id="3-1-2-远程文件"><a href="#3-1-2-远程文件" class="headerlink" title="3.1.2 远程文件"></a>3.1.2 远程文件</h4><p>Gradle支持从Maven或者Ivy仓库获取依赖文件。</p><p>首先，必须把仓库添加到列表中，其次，必须按照Maven或者Ivy的文件声明规范来声明依赖。</p><pre><code>repositories {    mavenCentral()}dependencies {    compile 'com.google.guava:guava:11.0.2'}android {    ...}</code></pre><p><strong>Note:</strong> mavenCentral()是指定仓库URL的便捷方式。Gradle支持远程和本地仓库。<br><strong>Note:</strong> Gradle遵循依赖关系的传递性。如果一个被依赖文件也依赖其它文件，那些被依赖的文件也会被拉取下来。<br>更多关于配置依赖的信息，请查看<a href="http://gradle.org/docs/current/userguide/artifact_dependencies_tutorial.html" target="_blank" rel="noopener">Gradle</a>用户指南和<a href="http://gradle.org/docs/current/dsl/org.gradle.api.artifacts.dsl.DependencyHandler.html" target="_blank" rel="noopener">DSL</a>文档</p><h3 id="3-2-多项目设置"><a href="#3-2-多项目设置" class="headerlink" title="3.2 多项目设置"></a>3.2 多项目设置</h3><p>Gradle项目可以通过多项目设置依赖其它gradle项目。</p><p>一个多项目设置通常把所有子项目作为子目录放在指定的项目根目录下。<br>例如，项目结构如下：</p><pre><code>MyProject/+ app/+ libraries/    + lib1/    + lib2/</code></pre><p>我们在这个结构中定义3个项目。Gradle将通过以下名字引用它们：</p><pre><code>MyProject/:app:libraries:lib1:libraries:lib2</code></pre><p>每个项目都有自己的<code>build.gradle</code>文件，声明来它怎样构建。另外，在根目录下还有一个<code>settings.gradle</code>文件，声明了所有的子项目。<br>目录结构如下：</p><pre><code>MyProject/ | settings.gradle+ app/    | build.gradle+ libraries/    + lib1/       | build.gradle    + lib2/       | build.gradle</code></pre><p><code>settings.gradle</code>文件的内容十分简单：</p><pre><code>include ':app', ':libraries:lib1', ':libraries:lib2'</code></pre><p>指明哪个文件夹是一个实际的Gradle项目。</p><p><code>:app</code>项目或许依赖其它库项目，那么依赖关系声明如下：</p><pre><code>dependencies {    compile project(':libraries:lib1')}</code></pre><p>更多关于多项目设置的信息在<a href="http://gradle.org/docs/current/userguide/multi_project_builds.html" target="_blank" rel="noopener">这里</a>。</p><h3 id="3-3-库项目"><a href="#3-3-库项目" class="headerlink" title="3.3 库项目"></a>3.3 库项目</h3><p>在上面的多项目设置中，<code>:libraries:lib1</code>和<code>:libraries:lib2</code>可能是Java项目，<code>:app</code>Android项目将会使用它们输出的jar文件。</p><p>然而，如果你想要共享使用了Android API或者Android资源文件的代码(在库项目中使用了Android API或Android资源文件)，这些库项目就不能是常规的Java项目，必须是Android库项目。</p><h4 id="3-3-1-创建一个库项目"><a href="#3-3-1-创建一个库项目" class="headerlink" title="3.3.1 创建一个库项目"></a>3.3.1 创建一个库项目</h4><p>一个库项目和常规的Android项目很相似，只有很少的区别。<br>因为构建库项目和构建应用程序不一样，所以使用不同的插件。构建库项目的插件和构建应用程序的插件在内部共享大部分的代码，并且它们都是由<code>com.android.tools.build.gradlejar</code>库提供。</p><pre><code>buildscript {    repositories {        mavenCentral()    }    dependencies {        classpath 'com.android.tools.build:gradle:0.5.6'    }}apply plugin: 'android-library'android {    compileSdkVersion 15}</code></pre><p>这是一个使用API 15编译的库项目。<code>SourceSets</code>和依赖关系的处理跟应用程序项目中一样，而且定制方式也一样。</p><h4 id="3-3-2-普通项目和库项目的区别"><a href="#3-3-2-普通项目和库项目的区别" class="headerlink" title="3.3.2 普通项目和库项目的区别"></a>3.3.2 普通项目和库项目的区别</h4><p>一个库项目的主要输出是一个<code>.aar</code>包（它代表Android的归档文件）。它包含编译好的源码（例如jar文件或者本地.so文件）以及资源文件（manifest, res, assets）。</p><p>一个库项目也可以生成一个测试apk来测试，而不依赖应用程序。</p><p>由于使用同样的锚点任务（<code>assembleDebug</code>, <code>assembleRelease</code>），所以在命令行中构建库项目和普通项目没有区别。<br>其余部分，库项目和应用程序项目一样。都有构建类型和product flavors，可以生成多个版本的aar。<br>要注意的是，多数Build Type配置不适用于库项目。然而，你可以定制<code>sourceSet</code>来改变所依赖库的内容，不论它是被普通项目使用还是被测试。</p><h4 id="3-3-3-引用一个库项目"><a href="#3-3-3-引用一个库项目" class="headerlink" title="3.3.3 引用一个库项目"></a>3.3.3 引用一个库项目</h4><p>引用一个库项目和引用其它项目的方式一样：</p><pre><code>dependencies {    compile project(':libraries:lib1')    compile project(':libraries:lib2')}</code></pre><p><strong>Note:</strong> 如果你由多个库项目，那么顺序是很重要的。这和旧构建系统中的project.properties文件中的依赖顺序一样重要。</p><h4 id="3-3-4-库项目发布"><a href="#3-3-4-库项目发布" class="headerlink" title="3.3.4 库项目发布"></a>3.3.4 库项目发布</h4><p>默认的情况下，库项目只会发布release变种版本(release variant)。这个版本会被所有引用了库项目的项目使用，不管它们自己构建的是什么版本。这是Gradle导致的限制，我们正努力消除这个限制。<br>可以如下控制哪个版本会被发布：</p><pre><code>android {    defaultPublishConfig "debug"}</code></pre><p>要注意的是，这个发布配置名称必须是完整的variant名称，<code>release</code>和<code>debug</code>这两个名称只有在没有flavor的时候才使用。如果想要在有flavor的时候改变默认的发布版本，你必须这样写：</p><pre><code>android {    defaultPublishConfig "flavor1Debug"}</code></pre><p>发布库项目的所有版本也是可能的。我们计划在普通的项目依赖项目的工程中允许这种做法，但是由于Gradle的限制，现在还不能这么做（我们也在努力修复这个问题）。<br>发布所有版本的功能默认没有开启。开启如下：</p><pre><code>android {    publishNonDefault true}</code></pre><p>必须认识到发布多个variant版本意味着发布多个aar文件，而不是在一个aar文件中包含了多个variant版本。每一个aar文件就是一个独立的variant。</p><p>发布一个variant版本意味着构建出了一个可用的aar文件，作为Gradle项目的输出文件。这个文件可以发布到maven仓库，或者在其他项目依赖该库项目时作为依赖目标。</p><p>Gradle有默认文件的概念。下面这个就使用了默认文件：</p><pre><code>compile project(':libraries:lib2')</code></pre><p>为了依赖其他的发布版本，你必须指定具体使用哪一个：</p><pre><code>dependencies {    flavor1Compile project(path: ':lib1', configuration: 'flavor1Release')    flavor2Compile project(path: ':lib1', configuration: 'flavor2Release')}</code></pre><p><strong>重要:</strong> 要注意已发布的配置是完整的variant版本，包含了构建类型，因此引用的时候也必须是完整的。</p><p><strong>重要: </strong>当开启了无默认版本发布，Maven发布插件会把这些额外的版本作为扩展包（按分类器）发布。这意味着并不是真正兼容地发布到maven仓库。你应该发布一个独立的vatiant到仓库，或者开启发布所有配置来支持跨项目依赖。</p><h2 id="4-测试"><a href="#4-测试" class="headerlink" title="4 测试"></a>4 测试</h2><p>构建一个测试应用已经内置在应用项目内。不需要再创建单独的测试项目。</p><h3 id="4-1-单元测试"><a href="#4-1-单元测试" class="headerlink" title="4.1 单元测试"></a>4.1 单元测试</h3><p>验性的单元测试功能支持已经加入到1.1中，具体请看这个<a href="http://tools.android.com/tech-docs/unit-testing-support" target="_blank" rel="noopener">页面</a>。本节其他部分讲述的是”instrumentation tests”</p><h3 id="4-2-基础和配置"><a href="#4-2-基础和配置" class="headerlink" title="4.2 基础和配置"></a>4.2 基础和配置</h3><p>正如前面提到的，紧邻着<code>main sourceSet</code> 的就是 <code>androidTest</code> sourceSet，默认在<code>src/androidTest/</code>路径下。</p><p>从这个sourceSet 会构建出一个使用Android测试框架，并且可以部署到设备上的测试apk来测试应用程序。这里面可以包含单元测试，集成测试，和后续UI自动化测试。</p><p>测试应用的<code>&lt;instrumentation&gt;</code>节点是自动生成的，但是你也可以创建一个<code>src/androidTest/AndroidManifest.xml</code> ，并在这个manifest文件中添加其他组件。</p><p>下面是一些测试应用可以配置的值：</p><ul><li>testPackageName</li><li>testInstrumentationRunner</li><li>testHandleProfiling</li><li>testFunctionalTest</li></ul><p>正如前面所看到的，这些在defaultConfig对象中配置：</p><pre><code>android {    defaultConfig {        testPackageName "com.test.foo"        testInstrumentationRunner "android.test.InstrumentationTestRunner"        testHandleProfiling true        testFunctionalTest true    }}</code></pre><p>在测试应用程序的manifest文件中，instrumentation节点的targetPackage属性值会自动使用测试应用的package名称设置，即使这个名称是通过defaultConfig或者Build Type对象自定义的。这也是manifest文件需要自动生成的一个原因。</p><p>另外，这个测试sourceSet也可以拥有自己的依赖。 默认情况下，应用程序和他的依赖会自动添加的测试应用的classpath中，但是也可以通过以下来扩展：</p><pre><code>dependencies {    androidTestCompile 'com.google.guava:guava:11.0.2'}</code></pre><p>测试应用通过<code>assembleTest</code>任务来构建。assembleTest不依赖于main中的<code>assemble</code>任务，需要手动设置运行，不能自动运行。</p><p>目前只有一个Build Type被测试。默认情况下是<code>debug</code> Build Type，但是这也可以通过以下自定义配置：</p><pre><code>android {    ...    testBuildType "staging"}</code></pre><h4 id="4-3-运行测试"><a href="#4-3-运行测试" class="headerlink" title="4.3 运行测试"></a>4.3 运行测试</h4><p>正如前面提到的，检查通过锚点任务<code>connectedCheck</code>启动，这需要一个设备已连接。<br>这个过程依赖于androidTest任务，因此将会运行androidTest。这个task将会执行下面内容：</p><ul><li>确认应用和测试应用都被构建（依赖于<code>assembleDebug</code>和<code>assembleTest</code>）</li><li>安装这两个应用</li><li>运行这些测试</li><li>卸载这两个应用.</li></ul><p>如果有多于一个连接设备，那么所有测试都会同时运行在所有连接设备上。如果其中一个测试失败，不管是哪一个设备，这个构建就失败。</p><p>所有测试结果都被保存为XML文档，路径为：</p><pre><code>build/androidTest-results</code></pre><p>（这和常规的JUnit类似，运行结果保存在build/test-results）<br>同样，这也可以自定义配置：</p><pre><code>android {    ...    testOptions {        resultsDir = "$project.buildDir/foo/results"    }}</code></pre><p><code>android.testOptions.resultsDir</code>由Project.file(String)获得。</p><h3 id="4-4-测试Android库"><a href="#4-4-测试Android库" class="headerlink" title="4.4 测试Android库"></a>4.4 测试Android库</h3><p>测试Android库项目的方法与应用项目的测试方法基本一样。</p><p>唯一的不同在于整个库（包括它的依赖）都是自动作为依赖库被添加到测试应用中。结果就是测试APK不单只包含它的代码，还包含了库项目自己和库的所有依赖。</p><p>库的manifest被组合到测试应用的manifest中（和其他项目引用这个库时一样）。</p><p><code>androidTest</code>变成只是安装（或者卸载）测试APK（因为没有其它APK要安装）。<br>其它的部分都是类似的。</p><h3 id="4-5-测试报告"><a href="#4-5-测试报告" class="headerlink" title="4.5 测试报告"></a>4.5 测试报告</h3><p>当运行单元测试的时候，Gradle会输出一份HTML格式的报告以方便查看结果。<br>Android plugin也是基于此，并且扩展了HTML报告文件，它将所有连接设备的报告都合并到一个文件里面。</p><h4 id="4-5-1-独立项目"><a href="#4-5-1-独立项目" class="headerlink" title="4.5.1 独立项目"></a>4.5.1 独立项目</h4><p>项目将会自动生成测试运行，测试报告默认位置：</p><pre><code>build/reports/androidTests</code></pre><p>这非常类似于JUnit的报告所在位置<code>build/reports/tests</code>，其它的报告通常位于<code>build/reports/&lt;plugin&gt;/</code></p><p>这个路径也可以通过以下方式自定义：</p><pre><code>android {    ...    testOptions {        reportDir = "$project.buildDir/foo/report"    }}</code></pre><p>报告将会合并运行在不同设备上的测试结果。</p><h4 id="4-5-2-多项目测试报告"><a href="#4-5-2-多项目测试报告" class="headerlink" title="4.5.2 多项目测试报告"></a>4.5.2 多项目测试报告</h4><p>在一个配置了多个应用或者多个库项目的项目中，当同时运行所有测试的时候，生成一个单一报告文件记录所有的测试可能是非常有用的。</p><p>为了实现这个目的，需要使用同一个依赖文件中的另一个插件。可以通过以下方式添加：</p><pre><code>buildscript {    repositories {        mavenCentral()    }    dependencies {        classpath 'com.android.tools.build:gradle:0.5.6'    }}</code></pre><p>apply plugin: ‘android-reporting’</p><p>这必须添加到项目的根目录下，例如与settings.gradle文件同个目录的build.gradle文件中。</p><p>然后，在命令行中导航到项目根目录下，输入以下命令就可以运行所有测试并合并所有报告：</p><pre><code>gradle deviceCheck mergeAndroidReports --continue</code></pre><p>注意：<code>--continue</code> 选项将允许所有测试，即使子项目中的任何一个运行失败都不会停止。如果没有这个选项，第一个失败测试将会终止全部测试的运行，这可能导致一些项目没有执行过它们的测试。</p><h3 id="4-6-Lint支持"><a href="#4-6-Lint支持" class="headerlink" title="4.6 Lint支持"></a>4.6 Lint支持</h3><p>从0.7.0版本开始，你可以为项目中一个特定的variant版本运行lint，也可以为所有variant版本都运行lint。它将会生成一个报告描述哪一个variant版本中存在着问题。</p><p>你可以通过以下lint选项配置lint。通常情况下你只需要配置其中一部分，以下列出了所有可使用的选项：</p><pre><code>android {    lintOptions {        // set to true to turn off analysis progress reporting by lint        quiet true        // if true, stop the gradle build if errors are found        abortOnError false        // if true, only report errors        ignoreWarnings true        // if true, emit full/absolute paths to files with errors (true by default)        //absolutePaths true        // if true, check all issues, including those that are off by default        checkAllWarnings true        // if true, treat all warnings as errors        warningsAsErrors true        // turn off checking the given issue id's        disable 'TypographyFractions','TypographyQuotes'        // turn on the given issue id's        enable 'RtlHardcoded','RtlCompat', 'RtlEnabled'        // check *only* the given issue id's        check 'NewApi', 'InlinedApi'        // if true, don't include source code lines in the error output        noLines true        // if true, show all locations for an error, do not truncate lists, etc.        showAll true        // Fallback lint configuration (default severities, etc.)        lintConfig file("default-lint.xml")        // if true, generate a text report of issues (false by default)        textReport true        // location to write the output; can be a file or 'stdout'        textOutput 'stdout'        // if true, generate an XML report for use by for example Jenkins        xmlReport false        // file to write report to (if not specified, defaults to lint-results.xml)        xmlOutput file("lint-report.xml")        // if true, generate an HTML report (with issue explanations, sourcecode, etc)        htmlReport true        // optional path to report (default will be lint-results.html in the builddir)        htmlOutput file("lint-report.html")   // set to true to have all release builds run lint on issues with severity=fatal   // and abort the build (controlled by abortOnError above) if fatal issues are found   checkReleaseBuilds true        // Set the severity of the given issues to fatal (which means they will be        // checked during release builds (even if the lint target is not included)        fatal 'NewApi', 'InlineApi'        // Set the severity of the given issues to error        error 'Wakelock', 'TextViewEdits'        // Set the severity of the given issues to warning        warning 'ResourceAsColor'        // Set the severity of the given issues to ignore (same as disabling the check)        ignore 'TypographyQuotes'    }}</code></pre><h2 id="5-构建不同版本-Build-Variants"><a href="#5-构建不同版本-Build-Variants" class="headerlink" title="5  构建不同版本(Build Variants)"></a>5  构建不同版本(Build Variants)</h2><p>新构建系统的一个目标就是为一个应用构建不同的版本。</p><p>有两个主要的场景：</p><ul><li>同一个应用的不同版本。例如，免费版和收费版</li><li>同一个应用，为了在Google Play Store上发布并适配多钟设备，打包出不同的apk。</li><li>以上两种情况的综合</li></ul><p>也就是说，从同一个项目中生成这些不同的apk，而不是使用一个库工程和2个以上的主应用工程。</p><h3 id="5-1-产品定制-Product-flavors"><a href="#5-1-产品定制-Product-flavors" class="headerlink" title="5.1 产品定制(Product flavors)"></a>5.1 产品定制(Product flavors)</h3><p>一个<code>product flavor</code>定义了项目构建输出的一个自定义应用版本。一个单独项目可以有不同的flavor，来生成不同的应用。</p><p>这个新概念(flavor)是用来解决不同应用版本间差异很小的情形。如果“这是否同一个应用？”的回答是肯定的话，这是比使用库项目更好的做法。</p><p>flavor使用<code>productFlavors</code> 这个DSL容器来声明：</p><pre><code>android {    ....    productFlavors {        flavor1 {            ...        }        flavor2 {            ...        }    }}</code></pre><p>这里创建了两个flavor，分别是<code>flavor1</code> 和 <code>flavor2</code>。</p><p><strong>注意：</strong> flavor的名字不能喝已有的构建类型(Build Type)名字冲突，或者和androidTest这个sourceSet的名字冲突。</p><h3 id="5-2-构建类型＋产品定制＝变种版本-Build-Type-Product-Flavor-Build-Variant"><a href="#5-2-构建类型＋产品定制＝变种版本-Build-Type-Product-Flavor-Build-Variant" class="headerlink" title="5.2 构建类型＋产品定制＝变种版本(Build Type + Product Flavor = Build Variant)"></a>5.2 构建类型＋产品定制＝变种版本(Build Type + Product Flavor = Build Variant)</h3><p>前面已经提到，每一个构建类型都会生成一个apk。忘了的话，请看2.4.2</p><p>Product Flavors 也会做同样的事情，实际上，项目输出来自所有可能的，Build Types和Product Flavors的组合，如果有Product Flavors的话。</p><p>每种Build Types和Product Flavors的组合就是一个Build Variant。</p><p>例如，默认的<code>debug</code> 和 <code>release</code>这两个Build Types，和上面创建的两个flavor会生成4个Build Variants：</p><ul><li>Flavor1 - debug</li><li>Flavor1 - release</li><li>Flavor2 - debug</li><li>Flavor2 - release</li></ul><p>没有flavor的项目也有Build Variants，使用默认的没有名字的flavor配置，使得Build Variants列表看起来和 Build Types一样。</p><h3 id="5-3-ProductFlavor配置"><a href="#5-3-ProductFlavor配置" class="headerlink" title="5.3 ProductFlavor配置"></a>5.3 ProductFlavor配置</h3><p>每个flavor在下面这样的闭包结构中配置：</p><pre><code>android {    ...    defaultConfig {        minSdkVersion 8        versionCode 10    }    productFlavors {        flavor1 {            packageName "com.example.flavor1"            versionCode 20        }        flavor2 {            packageName "com.example.flavor2"            minSdkVersion 14        }    }}</code></pre><p>注意到<code>android.productFlavors.*</code>和<code>android.defaultConfig</code>的配置项类型相同，这意味着他们共享相同的属性。</p><p><code>defaultConfig</code>为所有的flavor提供默认的配置，每个flavor都可以覆盖配置项的值。上面的例子中，最终的配置如下：</p><ul><li>flavor1<ul><li>packageName: com.example.flavor1</li><li>minSdkVersion: 8</li><li>versionCode: 20</li></ul></li><li>flavor2<ul><li>packageName: com.example.flavor2</li><li>minSdkVersion: 14</li><li>versionCode: 10</li></ul></li></ul><p>通常，Build Type配置会覆盖其他配置。例如Build Type‘的<code>packageNameSuffix</code>会添加到Product Flavor‘的 <code>packageName</code>上。</p><p>也有一些情况下，一个配置项可以同时在Build Type 和 Product Flavor都进行配置，这时，就要具体情况具体分析了。</p><p>例如，<code>signingConfig</code>就是这样一个配置项。<br>可以设置<code>android.buildTypes.release.signingConfig</code>让所有release版本使用同一个SigningConfig，也可以单独设置<code>android.productFlavors.*.signingConfig</code>让各release使用各自的SigningConfig。</p><h3 id="5-4-源集合和依赖关系"><a href="#5-4-源集合和依赖关系" class="headerlink" title="5.4 源集合和依赖关系"></a>5.4 源集合和依赖关系</h3><p>和构建类型类似，产品flavor也可以通过他们自己的sourceSets影响最终的代码和资源</p><p>在上面的例子中，创建了四个sourceSet：</p><ul><li>android.sourceSets.flavor1<ul><li>位置 <code>src/flavor1/</code></li></ul></li><li>android.sourceSets.flavor2<ul><li>位置 <code>src/flavor2/</code></li></ul></li><li>android.sourceSets.androidTestFlavor1<ul><li>位置 <code>src/androidTestFlavor1/</code></li></ul></li><li>android.sourceSets.androidTestFlavor2<ul><li>位置 <code>src/androidTestFlavor2/</code></li></ul></li></ul><p>这些sourceSet 都会用来创建apk，和<code>android.sourceSets.main</code>以及构建类型的sourceSet一起。</p><p>下面是构建apk时，所有sourceSet的处理原则：</p><ol><li>所有文件夹里的源码(src/*/java)都会被合并起来构建一个输出。</li><li>多个Manifest文件会合并成一个。这样使得flavor和构建类型一样，可以有不同的组件和permission</li><li>所有资源的使用遵循优先级覆盖，Product Flavor资源覆盖main sourceSet资源，Build Type资源覆盖Product Flavor资源</li><li>每个Build Variant会从资源中生成各自的R文件（或者其他生成的源码）。各个Build Variant不会共享任何东西。</li><li>最后，和Build Type一样，Product Flavor还可以有自己的依赖。例如，flavor包含了一个广告版本和一个支付版本，那么就会依赖广告sdk，而其他版本不依赖。</li></ol><p>最后，和Build Type一样，Product Flavor还可以有自己的依赖。例如，flavor包含了一个广告版本和一个支付版本，那么就会依赖广告sdk，而其他版本不依赖。</p><pre><code>dependencies {    flavor1Compile "..."}</code></pre><p>在这个特别的情况下，src/flavor1/AndroidManifest.xml也许需要添加一个网络权限</p><p>每个variant也会包含额外的sourceset：</p><ul><li>android.sourceSets.flavor1Debug<ul><li>位置 <code>src/flavor1Debug/</code></li></ul></li><li>android.sourceSets.flavor1Release<ul><li>位置 <code>src/flavor1Release/</code></li></ul></li><li>android.sourceSets.flavor2Debug<ul><li>位置 <code>src/flavor2Debug/</code></li></ul></li><li>android.sourceSets.flavor2Release<ul><li>位置 <code>src/flavor2Release/</code></li></ul></li></ul><p>这些sourceset比build type的sourceset有更高的优先级，允许variant级别的定制。</p><h3 id="5-5-构建和任务"><a href="#5-5-构建和任务" class="headerlink" title="5.5 构建和任务"></a>5.5 构建和任务</h3><p>前面提到，每个Build Type有自己的<code>assemble&lt;name&gt;</code>任务。但是Build Variant是Build Type 和 Product Flavor组合。</p><p>当使用Product Flavor的时候，更多的assemble-type任务会被创建出来，分别是：</p><p>1.assemble<variant name=""></variant></p><p>  允许直接构建一个Variant版本，例如assembleFlavor1Debug。</p><p>2.assemble<build type="" name=""></build></p><p>  允许构建指定Build Type的所有APK，例如assembleDebug将会构建Flavor1Debug和Flavor2Debug两个Variant版本。</p><p>3.assemble<product flavor="" name=""></product></p><p>  允许构建指定flavor的所有APK，例如assembleFlavor1将会构建Flavor1Debug和Flavor1Release两个Variant版本。</p><p><code>assemble</code>任务会构建所有可能的variant版本。</p><h3 id="5-6-测试"><a href="#5-6-测试" class="headerlink" title="5.6 测试"></a>5.6 测试</h3><p>测试多flavor的项目和简单项目十分类似。</p><p><code>androidTest</code> sourceset被用来定义所有flavor的通用测试，同时，每个flavor也可以有各自的测试。</p><p>正如上面提到的，测试各flavor的sourceSet会被创建：</p><ul><li><p>android.sourceSets.androidTestFlavor1</p><p>位置 <code>src/androidTestFlavor1/</code></p></li><li><p>android.sourceSets.androidTestFlavor2</p><p>位置 <code>src/androidTestFlavor2</code>/</p></li></ul><p>同样，他们也可以有他们自己的依赖:</p><pre><code>dependencies {    androidTestFlavor1Compile "..."}</code></pre><p>可以通过锚点任务<code>deviceCheck</code>来运行测试，或者<code>androidTest</code>任务（当使用flavor时，它作为锚点任务）。</p><p>每个flavor有自己的任务运行测试：<code>androidTest&lt;VariantName&gt;</code>。例如：</p><ul><li>androidTestFlavor1Debug</li><li>androidTestFlavor2Debug</li></ul><p>类似的，每个variant都有构建测试apk和安装/卸载任务。</p><ul><li>assembleFlavor1Test</li><li>installFlavor1Debug</li><li>installFlavor1Test</li><li>uninstallFlavor1Debug</li></ul><p>…</p><p>最后，生成的HTML报告支持按照flavor合并。<br>测试结果和报告位置如下，首先是每个flavor版本的，然后是合并的。</p><ul><li>build/androidTest-results/flavors/</li><li>build/androidTest-results/all/</li><li>build/reports/androidTests/flavors</li><li>build/reports/androidTests/all/</li></ul><p>改变任一个路径，只会影响根目录，仍然会为每个flavor和合并后的结果创建子目录。</p><h3 id="5-7-多flaver维度的版本-Multi-flavor-variants"><a href="#5-7-多flaver维度的版本-Multi-flavor-variants" class="headerlink" title="5.7 多flaver维度的版本(Multi-flavor variants)"></a>5.7 多flaver维度的版本(Multi-flavor variants)</h3><p>某些情况下，应用可能需要基于多个标准来创建多个版本。</p><p>例如，Google Play中multi-apk支持4个不同的过滤器。为每一个过滤器而创建的apk要求使用多个Product Flavor维度。</p><p>假设有一个游戏项目，有demo和付费版本，想要使用multi-apk中的ABI过滤器。由于要兼顾3种ABI和两个版本，所以需要生成6个apk（没有计算多个Build Type产生的版本）。</p><p>然而，付费版本的代码对于所有三个ABI都是一样，因此创建简单的6个flavor不是一个好方法。</p><p>相反的，将flavor分为两个维度，并自动构建所有可能的组合variant。</p><p>这个功能通过Flavor Dimensions来实现。flavor都被分配到一个特定的维度</p><pre><code>android {    ...    flavorDimensions "abi", "version"    productFlavors {        freeapp {            flavorDimension "version"            ...        }        x86 {            flavorDimension "abi"            ...        }    }}</code></pre><p>在<code>android.flavorDimensions</code>数组中定义可能的维度，并且每个flavor都指定一个维度。</p><p>根据已经划分维度的flavor([freeapp, paidapp] 和 [x86, arm, mips])，和Build Type[debug, release]，会创建以下variant：</p><ul><li>x86-freeapp-debug</li><li>x86-freeapp-release</li><li>arm-freeapp-debug</li><li>arm-freeapp-release</li><li>mips-freeapp-debug</li><li>mips-freeapp-release</li><li>x86-paidapp-debug</li><li>x86-paidapp-release</li><li>arm-paidapp-debug</li><li>arm-paidapp-release</li><li>mips-paidapp-debug</li><li>mips-paidapp-release</li></ul><p><code>android.flavorDimensions</code>中定义维度的顺序非常重要。</p><p>每个variant配置由多个Product Flavor对象决定：</p><ul><li>android.defaultConfig</li><li>One from the abi dimension</li><li>One from the version dimension</li></ul><p>维度的顺序决定哪个flavor的配置会覆盖另一个，这对资源来说很重要，高优先级flavor中的资源会替换低优先级的。flavor维度定义时高优先级在前。所以上面的例子中：</p><pre><code>abi > version > defaultConfig</code></pre><p>多维flavor项目也有额外的sourceset，和variant类似，但是没有build type：</p><ul><li>android.sourceSets.x86Freeapp <code>Location src/x86Freeapp/</code></li><li>android.sourceSets.armPaidapp <code>Location src/armPaidapp/</code></li><li>etc…</li></ul><p>这些sourceset允许在flavor-combination的级别进行定制。他们比基础的flavor sourceset优先级高，但是比build type sourceset优先级低。</p><h2 id="6-高级构建定制"><a href="#6-高级构建定制" class="headerlink" title="6 高级构建定制"></a>6 高级构建定制</h2><h3 id="6-1-构建选项"><a href="#6-1-构建选项" class="headerlink" title="6.1 构建选项"></a>6.1 构建选项</h3><h4 id="6-1-1-Java编译选项"><a href="#6-1-1-Java编译选项" class="headerlink" title="6.1.1 Java编译选项"></a>6.1.1 Java编译选项</h4><pre><code>android {    compileOptions {        sourceCompatibility = "1.6"        targetCompatibility = "1.6"    }}</code></pre><p>默认值是1.6。影响所有编译java源码的任务。</p><h4 id="6-1-2-aapt选项"><a href="#6-1-2-aapt选项" class="headerlink" title="6.1.2 aapt选项"></a>6.1.2 aapt选项</h4><pre><code>android {    aaptOptions {        noCompress 'foo', 'bar'        ignoreAssetsPattern "!.svn:!.git:!.ds_store:!*.scc:.*:<dir>_*:!CVS:!thumbs.db:!picasa.ini:!*~"    }}</dir></code></pre><code>android {    dexOptions {        incremental false        preDexLibraries = false        jumboMode = false        javaMaxHeapSize "2048M"    }}</code><p>影响所有使用dex的任务。</p><h3 id="6-2-修改构建任务"><a href="#6-2-修改构建任务" class="headerlink" title="6.2 修改构建任务"></a>6.2 修改构建任务</h3><p>基础的Java项目有一套有限的任务共同工作来生成输出。</p><p><code>classes</code>任务是一个编译Java源码的任务。很容易在<code>build.gradle</code>文件的脚本中用<code>classes</code>调用。这是<code>project.tasks.classes</code>的缩写。</p><p>在Android项目中，情况就有点复杂，因为存在大量同样的任务，他们的名字是基于Build Type 和 Product Flavor生成的。</p><p>为了解决这个问题，android有两个属性：</p><ul><li>applicationVariants (只适用于 app plugin)</li><li>libraryVariants (只适用于 library plugin)</li><li>testVariants (两者都适用)</li></ul><p>这三者分别返回一个<code>ApplicationVariant</code>, <code>LibraryVariant</code>, 和 <code>TestVariant</code>对象的<a href="http://www.gradle.org/docs/current/javadoc/org/gradle/api/DomainObjectCollection.html" target="_blank" rel="noopener">DomainObjectCollection</a>。</p><p>要注意使用这些collection中的任一个都会触发创建所有的任务。这意味着使用collection之后不应该修改配置。</p><p><code>DomainObjectCollection</code>可以直接访问所有对象，或者通过过滤器筛选（更方便）。</p><pre><code>android.applicationVariants.each { variant ->    ....}</code></pre><p>所有三种variant共享下面这些属性：</p><table><thead><tr><th>Property Name</th><th style="text-align:center">Property Type</th><th style="text-align:right">Description</th></tr></thead><tbody><tr><td>name</td><td style="text-align:center">String</td><td style="text-align:right">variant的名字，必须是唯一的</td></tr><tr><td>description</td><td style="text-align:center">String</td><td style="text-align:right">variant的描述</td></tr><tr><td>dirName</td><td style="text-align:center">String</td><td style="text-align:right">Variant的子文件夹名，必须是唯一的。可能也会有多个子文件夹，例如“debug/flavor1”</td></tr><tr><td>baseName</td><td style="text-align:center">String</td><td style="text-align:right">variant输出的基本名字，必须唯一</td></tr><tr><td>outputFile</td><td style="text-align:center">File</td><td style="text-align:right">Variant的输出，这是一个可读写的属性</td></tr><tr><td>processManifest</td><td style="text-align:center">ProcessManifest</td><td style="text-align:right">处理Manifest的任务</td></tr><tr><td>aidlCompile</td><td style="text-align:center">AidlCompile</td><td style="text-align:right">编译AIDL文件的的任务</td></tr><tr><td>renderscriptCompile</td><td style="text-align:center">RenderscriptCompile</td><td style="text-align:right">编译Renderscript文件的任务</td></tr><tr><td>mergeResources</td><td style="text-align:center">MergeResources</td><td style="text-align:right">合并资源文件的任务</td></tr><tr><td>mergeAssets</td><td style="text-align:center">MergeAssets</td><td style="text-align:right">合并asset的任务</td></tr><tr><td>processResources</td><td style="text-align:center">ProcessAndroidResources</td><td style="text-align:right">处理并编译资源文件的任务</td></tr><tr><td>generateBuildConfig</td><td style="text-align:center">GenerateBuildConfig</td><td style="text-align:right">生成BuildConfig类的任务</td></tr><tr><td>javaCompile</td><td style="text-align:center">JavaCompile</td><td style="text-align:right">编译Java源代码的任务</td></tr><tr><td>processJavaResources</td><td style="text-align:center">Copy</td><td style="text-align:right">处理Java资源文件的任务</td></tr><tr><td>assemble</td><td style="text-align:center">DefaultTask</td><td style="text-align:right">variant的标志任务assemble</td></tr></tbody></table><p><code>ApplicationVariant</code>拥有以下额外属性：</p><table><thead><tr><th>Property Name</th><th style="text-align:center">Property Type</th><th style="text-align:right">Description</th></tr></thead><tbody><tr><td>buildType</td><td style="text-align:center">BuildType</td><td style="text-align:right">variant的构建类型</td></tr><tr><td>productFlavors</td><td style="text-align:center">List</td><td style="text-align:right">Variant的ProductFlavor。一般不为空但允许空值</td></tr><tr><td>mergedFlavor</td><td style="text-align:center">ProductFlavor</td><td style="text-align:right">android.defaultConfig和variant.productFlavors的合并</td></tr><tr><td>signingConfig</td><td style="text-align:center">SigningConfig</td><td style="text-align:right">variant使用的SigningConfig对象</td></tr><tr><td>isSigningReady</td><td style="text-align:center">boolean</td><td style="text-align:right">如果是true则表明这个variant已经具备了签名所需的所有信息</td></tr><tr><td>testVariant</td><td style="text-align:center">BuildVariant</td><td style="text-align:right">将会测试这个variant的TestVariant</td></tr><tr><td>dex</td><td style="text-align:center">Dex</td><td style="text-align:right">将代码打包成dex的任务，库工程该属性可以为空</td></tr><tr><td>packageApplication</td><td style="text-align:center">PackageApplication</td><td style="text-align:right">打包出最终apk的任务，库工程该属性可以为空</td></tr><tr><td>zipAlign</td><td style="text-align:center">ZipAlign</td><td style="text-align:right">对apk进行对齐(zipalign)的任务，库工程或者apk无法签名时，该属性可以为空</td></tr><tr><td>install</td><td style="text-align:center">DefaultTask</td><td style="text-align:right">安装apk的任务，可以为空</td></tr><tr><td>uninstall</td><td style="text-align:center">DefaultTask</td><td style="text-align:right">卸载任务</td></tr></tbody></table><p><code>LibraryVariant</code>拥有以下额外属性：</p><table><thead><tr><th>Property Name</th><th style="text-align:center">Property Type</th><th style="text-align:right">Description</th></tr></thead><tbody><tr><td>buildType</td><td style="text-align:center">BuildType</td><td style="text-align:right">variant的构建类型</td></tr><tr><td>mergedFlavor</td><td style="text-align:center">ProductFlavor</td><td style="text-align:right">The defaultConfig values</td></tr><tr><td>testVariant</td><td style="text-align:center">BuildVariant</td><td style="text-align:right">用于测试这个variant的Variant</td></tr><tr><td>packageLibrary</td><td style="text-align:center">Zip</td><td style="text-align:right">打包成库工程AAR文件的任务，非库工程该属性为空</td></tr></tbody></table><p><code>TestVariant</code>拥有以下额外属性：</p><table><thead><tr><th>Property Name</th><th style="text-align:center">Property Type</th><th style="text-align:right">Description</th></tr></thead><tbody><tr><td>buildType</td><td style="text-align:center">BuildType</td><td style="text-align:right">variant的构建类型</td></tr><tr><td>productFlavors</td><td style="text-align:center">List</td><td style="text-align:right">Variant的ProductFlavor。一般不为空但允许空值</td></tr><tr><td>mergedFlavor</td><td style="text-align:center">ProductFlavor</td><td style="text-align:right">android.defaultConfig和variant.productFlavors的合并</td></tr><tr><td>signingConfig</td><td style="text-align:center">SigningConfig</td><td style="text-align:right">variant使用的SigningConfig对象</td></tr><tr><td>isSigningReady</td><td style="text-align:center">boolean</td><td style="text-align:right">如果是true则表明这个variant已经具备了签名所需的所有信息</td></tr><tr><td>testedVariant</td><td style="text-align:center">BaseVariant</td><td style="text-align:right">被当前TestVariant测试的BaseVariant</td></tr><tr><td>dex</td><td style="text-align:center">Dex</td><td style="text-align:right">将代码打包成dex的任务，库工程该属性可以为空</td></tr><tr><td>packageApplication</td><td style="text-align:center">PackageApplication</td><td style="text-align:right">打包出最终apk的任务，库工程该属性可以为空</td></tr><tr><td>zipAlign</td><td style="text-align:center">ZipAlign</td><td style="text-align:right">对apk进行对齐(zipalign)的任务，库工程或者apk无法签名时，该属性可以为空</td></tr><tr><td>install</td><td style="text-align:center">DefaultTask</td><td style="text-align:right">安装apk的任务，可以为空</td></tr><tr><td>uninstall</td><td style="text-align:center">DefaultTask</td><td style="text-align:right">卸载任务</td></tr><tr><td>connectedAndroidTest</td><td style="text-align:center">DefaultTask</td><td style="text-align:right">在已连接的设备上运行android测试的任务</td></tr><tr><td>providerAndroidTest</td><td style="text-align:center">DefaultTask</td><td style="text-align:right">使用扩展API运行android测试的任务</td></tr></tbody></table><p>API for Android specific task types.</p><p>android特有任务的API：</p><ul><li>ProcessManifest<ul><li>File manifestOutputFile</li></ul></li><li>AidlCompile<ul><li>File sourceOutputDir</li></ul></li><li>RenderscriptCompile<ul><li>File sourceOutputDir</li><li>File resOutputDir</li></ul></li><li>MergeResources<ul><li>File outputDir</li></ul></li><li>MergeAssets<ul><li>File outputDir</li></ul></li><li>ProcessAndroidResources<ul><li>File manifestFile</li><li>File resDir</li><li>File assetsDir</li><li>File sourceOutputDir</li><li>File textSymbolOutputDir</li><li>File packageOutputFile</li><li>File proguardOutputFile</li></ul></li><li>GenerateBuildConfig<ul><li>File sourceOutputDir</li></ul></li><li>Dex<ul><li>File outputFolder</li></ul></li><li>PackageApplication<ul><li>File resourceFile</li><li>File dexFile</li><li>File javaResourceDir</li><li>File jniDir</li><li>File outputFile<ul><li>直接在Variant对象中使用“outputFile”可以改变最终的输出文件。</li></ul></li></ul></li><li>ZipAlign<ul><li>File inputFile</li><li>File outputFile<ul><li>直接在Variant对象中使用“outputFile”可以改变最终的输出文件。</li></ul></li></ul></li></ul><p>由于Gradle的工作方式和Android plugin的配置方式， 每个task类型的API是受限的。<br>首先，Gradle使得任务只能配置输入输出的路径和一些可能使用的选项标识。因此，任务只定义一些输入或者输出。</p><p>其次，大多数任务的输入都很复杂，一般都混合了sourceSet、Build Type和Product Flavor中的值。为了保持构建文件的简单，可读，我们的目标是让开发者通过略微改动DSL对象来修改构建过程，而不是深入到输入文件和任务选项中去。</p><p>另外需要注意，除了ZipAlign这个任务类型，其它所有类型都要求设置私有数据来让它们运行。这意味着不能手动创建这些任务的实例。</p><p>这些API也可能改变。大体来说，当前的API是围绕着修改任务的输入（可能的话）和输出来添加额外的处理过程（必要的话）。欢迎反馈，特别是那些没有预见到的问题。</p><p>对于Gradle任务(DefaultTask, JavaCompile, Copy, Zip)，请参考Gradle文档。</p><h3 id="6-3-BuildType和Product-Flavor属性参考）"><a href="#6-3-BuildType和Product-Flavor属性参考）" class="headerlink" title="6.3 BuildType和Product Flavor属性参考）"></a>6.3 BuildType和Product Flavor属性参考）</h3><p>敬请期待。<br>对于Gradle任务(DefaultTask, JavaCompile, Copy, Zip)，请参考Gradle文档。</p><h3 id="6-4-使用（JDK）1-7版本的sourceCompatibility）"><a href="#6-4-使用（JDK）1-7版本的sourceCompatibility）" class="headerlink" title="6.4 使用（JDK）1.7版本的sourceCompatibility）"></a>6.4 使用（JDK）1.7版本的sourceCompatibility）</h3><p>使用Android KitKat（buildTools v19）就可以使用diamond operator，multi-catch，在switch中使用字符串，try with resource等等（jdk7中的新特性），要使用这些，需要修改你的构建文件如下：</p><pre><code>android {    compileSdkVersion 19    buildToolsVersion "19.0.0"    defaultConfig {        minSdkVersion 7        targetSdkVersion 19    }    compileOptions {        sourceCompatibility JavaVersion.VERSION_1_7        targetCompatibility JavaVersion.VERSION_1_7    }}</code></pre>  <p>注意：你可以将minSdkVersion的值设置为19之前的版本，只是你只能使用除了try with resources之外的语言特性。如果你想要使用try with resources特性，你就需要把minSdkVersion也设置为19。<br>你同样也需要确认Gradle使用1.7或者更高版本的JDK。（Android Gradle plugin也需要0.6.1或者更高的版本）</p>]]></content>
    
    <summary type="html">
    
      &lt;h1 id=&quot;Gradle插件学习笔记&quot;&gt;&lt;a href=&quot;#Gradle插件学习笔记&quot; class=&quot;headerlink&quot; title=&quot;Gradle插件学习笔记&quot;&gt;&lt;/a&gt;Gradle插件学习笔记&lt;/h1&gt;&lt;h2 id=&quot;1-简介&quot;&gt;&lt;a href=&quot;#1-简介&quot; class=&quot;headerlink&quot; title=&quot;1 简介&quot;&gt;&lt;/a&gt;1 简介&lt;/h2&gt;&lt;p&gt;Gradle是一个基于Apache Ant和Apache Maven概念的项目自动化建构工具。它使用一种基于Groovy的特定领域语言(DSL)来声明项目设置，抛弃了基于XML的各种繁琐配置。&lt;/p&gt;
&lt;h3 id=&quot;1-1-新构建系统的目标是：&quot;&gt;&lt;a href=&quot;#1-1-新构建系统的目标是：&quot; class=&quot;headerlink&quot; title=&quot;1.1 新构建系统的目标是：&quot;&gt;&lt;/a&gt;1.1 新构建系统的目标是：&lt;/h3&gt;&lt;p&gt;新构建系统的目标是：&lt;/p&gt;
&lt;ul&gt;
&lt;li&gt;&lt;p&gt;使得代码和资源的重用更加简单&lt;/p&gt;
&lt;/li&gt;
&lt;li&gt;&lt;p&gt;使得创建同一应用程序的不同版本更加容易，不管是多个apk版本还是同一版本的多种定制&lt;/p&gt;
&lt;/li&gt;
&lt;li&gt;&lt;p&gt;使得配置，扩展和自定义构建更加容易&lt;/p&gt;
&lt;/li&gt;
&lt;li&gt;&lt;p&gt;良好的IDE集成&lt;/p&gt;
    
    </summary>
    
      <category term="android" scheme="http://yoursite.com/categories/android/"/>
    
    
  </entry>
  
  <entry>
    <title>RxJava</title>
    <link href="http://yoursite.com/2017/02/08/RxJava/"/>
    <id>http://yoursite.com/2017/02/08/RxJava/</id>
    <published>2017-02-08T02:26:00.000Z</published>
    <updated>2017-03-24T02:31:48.000Z</updated>
    
    <content type="html"><![CDATA[<h3 id="RxJava-到底是什么"><a href="#RxJava-到底是什么" class="headerlink" title="RxJava 到底是什么"></a>RxJava 到底是什么</h3><p>一个词：<strong>异步</strong>。</p><p>RxJava 在 GitHub 主页上的自我介绍是 “a library for composing asynchronous and event-based programs using observable sequences for the Java VM”（一个在 Java VM 上使用可观测的序列来组成异步的、基于事件的程序的库）。这就是 RxJava ，概括得非常精准。</p><p>然而，对于初学者来说，这太难看懂了。因为它是一个『总结』，而初学者更需要一个『引言』。</p><p>其实， RxJava 的本质可以压缩为异步这一个词。说到根上，它就是一个实现异步操作的库，而别的定语都是基于这之上的。</p><a id="more"></a><h3 id="RxJava-好在哪"><a href="#RxJava-好在哪" class="headerlink" title="RxJava 好在哪"></a>RxJava 好在哪</h3><p>换句话说，『同样是做异步，为什么人们用它，而不用现成的 AsyncTask / Handler / XXX / … ？』</p><p>一个词：<strong>简洁</strong>。</p><p>异步操作很关键的一点是程序的简洁性，因为在调度过程比较复杂的情况下，异步代码经常会既难写也难被读懂。 Android 创造的 <code>AsyncTask</code> 和<code>Handler</code> ，其实都是为了让异步代码更加简洁。RxJava 的优势也是简洁，但它的简洁的与众不同之处在于，<strong>随着程序逻辑变得越来越复杂，它依然能够保持简洁。</strong></p><h3 id="API-介绍和原理简析"><a href="#API-介绍和原理简析" class="headerlink" title="API 介绍和原理简析"></a>API 介绍和原理简析</h3><p>这个我就做不到一个词说明了……因为这一节的主要内容就是一步步地说明 RxJava 到底怎样做到了异步，怎样做到了简洁。</p><h4 id="1-概念：扩展的观察者模式"><a href="#1-概念：扩展的观察者模式" class="headerlink" title="1. 概念：扩展的观察者模式"></a>1. 概念：扩展的观察者模式</h4><p>RxJava 的异步实现，是通过一种扩展的观察者模式来实现的。</p><h5 id="观察者模式"><a href="#观察者模式" class="headerlink" title="观察者模式"></a>观察者模式</h5><p>先简述一下观察者模式，已经熟悉的可以跳过这一段。</p><p>观察者模式面向的需求是：A 对象（观察者）对 B 对象（被观察者）的某种变化高度敏感，需要在 B 变化的一瞬间做出反应。举个例子，新闻里喜闻乐见的警察抓小偷，警察需要在小偷伸手作案的时候实施抓捕。在这个例子里，警察是观察者，小偷是被观察者，警察需要时刻盯着小偷的一举一动，才能保证不会漏过任何瞬间。程序的观察者模式和这种真正的『观察』略有不同，观察者不需要时刻盯着被观察者（例如 A 不需要每过 2ms 就检查一次 B 的状态），而是采用<strong>注册</strong>(Register)<strong>或者称为</strong>订阅<strong>(Subscribe)</strong>的方式，告诉被观察者：我需要你的某某状态，你要在它变化的时候通知我。 Android 开发中一个比较典型的例子是点击监听器 <code>OnClickListener</code> 。对设置 <code>OnClickListener</code> 来说， <code>View</code> 是被观察者， <code>OnClickListener</code> 是观察者，二者通过 <code>setOnClickListener()</code> 方法达成订阅关系。订阅之后用户点击按钮的瞬间，Android Framework 就会将点击事件发送给已经注册的 <code>OnClickListener</code> 。采取这样被动的观察方式，既省去了反复检索状态的资源消耗，也能够得到最高的反馈速度。当然，这也得益于我们可以随意定制自己程序中的观察者和被观察者，而警察叔叔明显无法要求小偷『你在作案的时候务必通知我』。</p><p>OnClickListener 的模式大致如下图：</p><p><img src="http://ww4.sinaimg.cn/mw1024/52eb2279jw1f2rx42h1wgj20fz03rglt.jpg" alt="OnClickListener 观察者模式"></p><p>如图所示，通过 <code>setOnClickListener()</code> 方法，<code>Button</code> 持有 <code>OnClickListener</code> 的引用（这一过程没有在图上画出）；当用户点击时，<code>Button</code> 自动调用 <code>OnClickListener</code> 的 <code>onClick()</code> 方法。另外，如果把这张图中的概念抽象出来（<code>Button</code> -&gt; 被观察者、<code>OnClickListener</code> -&gt; 观察者、<code>setOnClickListener()</code> -&gt; 订阅，<code>onClick()</code> -&gt; 事件），就由专用的观察者模式（例如只用于监听控件点击）转变成了通用的观察者模式。如下图：</p><p><img src="http://ww3.sinaimg.cn/mw1024/52eb2279jw1f2rx4446ldj20ga03p74h.jpg" alt="通用观察者模式"></p><p>而 RxJava 作为一个工具库，使用的就是通用形式的观察者模式。</p><h5 id="RxJava-的观察者模式"><a href="#RxJava-的观察者模式" class="headerlink" title="RxJava 的观察者模式"></a>RxJava 的观察者模式</h5><p>RxJava 有四个基本概念：<code>Observable</code> (可观察者，即被观察者)、 <code>Observer</code> (观察者)、 <code>subscribe</code> (订阅)、事件。<code>Observable</code> 和 <code>Observer</code> 通过 <code>subscribe()</code> 方法实现订阅关系，从而 <code>Observable</code> 可以在需要的时候发出事件来通知 <code>Observer</code>。</p><p>与传统观察者模式不同， RxJava 的事件回调方法除了普通事件 <code>onNext()</code> （相当于 <code>onClick()</code> / <code>onEvent()</code>）之外，还定义了两个特殊的事件：<code>onCompleted()</code> 和 <code>onError()</code>。</p><ul><li><code>onCompleted()</code>: 事件队列完结。RxJava 不仅把每个事件单独处理，还会把它们看做一个队列。RxJava 规定，当不会再有新的 <code>onNext()</code> 发出时，需要触发 <code>onCompleted()</code> 方法作为标志。</li><li><code>onError()</code>: 事件队列异常。在事件处理过程中出异常时，<code>onError()</code> 会被触发，同时队列自动终止，不允许再有事件发出。</li><li>在一个正确运行的事件序列中, <code>onCompleted()</code> 和 <code>onError()</code> 有且只有一个，并且是事件序列中的最后一个。需要注意的是，<code>onCompleted()</code> 和 <code>onError()</code> 二者也是互斥的，即在队列中调用了其中一个，就不应该再调用另一个。</li></ul><p>RxJava 的观察者模式大致如下图：</p><p><img src="http://ww3.sinaimg.cn/mw1024/52eb2279jw1f2rx46dspqj20gn04qaad.jpg" alt="RxJava 的观察者模式"></p><h4 id="2-基本实现"><a href="#2-基本实现" class="headerlink" title="2. 基本实现"></a>2. 基本实现</h4><p>基于以上的概念， RxJava 的基本实现主要有三点：</p><h5 id="1-创建-Observer"><a href="#1-创建-Observer" class="headerlink" title="1) 创建 Observer"></a>1) 创建 Observer</h5><p>Observer 即观察者，它决定事件触发的时候将有怎样的行为。 RxJava 中的 <code>Observer</code> 接口的实现方式：</p><figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br></pre></td><td class="code"><pre><span class="line">Observer&lt;String&gt; observer = new Observer&lt;String&gt;() &#123;</span><br><span class="line">    @Override</span><br><span class="line">    public void onNext(String s) &#123;</span><br><span class="line">        Log.d(tag, &quot;Item: &quot; + s);</span><br><span class="line">    &#125;</span><br><span class="line"></span><br><span class="line">    @Override</span><br><span class="line">    public void onCompleted() &#123;</span><br><span class="line">        Log.d(tag, &quot;Completed!&quot;);</span><br><span class="line">    &#125;</span><br><span class="line"></span><br><span class="line">    @Override</span><br><span class="line">    public void onError(Throwable e) &#123;</span><br><span class="line">        Log.d(tag, &quot;Error!&quot;);</span><br><span class="line">    &#125;</span><br><span class="line">&#125;;</span><br></pre></td></tr></table></figure><p>除了 <code>Observer</code> 接口之外，RxJava 还内置了一个实现了 <code>Observer</code> 的抽象类：<code>Subscriber</code>。 <code>Subscriber</code> 对 <code>Observer</code> 接口进行了一些扩展，但他们的基本使用方式是完全一样的：</p><figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br></pre></td><td class="code"><pre><span class="line">Subscriber&lt;String&gt; subscriber = new Subscriber&lt;String&gt;() &#123;</span><br><span class="line">    @Override</span><br><span class="line">    public void onNext(String s) &#123;</span><br><span class="line">        Log.d(tag, &quot;Item: &quot; + s);</span><br><span class="line">    &#125;</span><br><span class="line"></span><br><span class="line">    @Override</span><br><span class="line">    public void onCompleted() &#123;</span><br><span class="line">        Log.d(tag, &quot;Completed!&quot;);</span><br><span class="line">    &#125;</span><br><span class="line"></span><br><span class="line">    @Override</span><br><span class="line">    public void onError(Throwable e) &#123;</span><br><span class="line">        Log.d(tag, &quot;Error!&quot;);</span><br><span class="line">    &#125;</span><br><span class="line">&#125;;</span><br></pre></td></tr></table></figure><p>不仅基本使用方式一样，实质上，在 RxJava 的 subscribe 过程中，<code>Observer</code> 也总是会先被转换成一个 <code>Subscriber</code> 再使用。所以如果你只想使用基本功能，选择 <code>Observer</code> 和 <code>Subscriber</code> 是完全一样的。它们的区别对于使用者来说主要有两点：</p><ol><li><code>onStart()</code>: 这是 <code>Subscriber</code> 增加的方法。它会在 subscribe 刚开始，而事件还未发送之前被调用，可以用于做一些准备工作，例如数据的清零或重置。这是一个可选方法，默认情况下它的实现为空。需要注意的是，如果对准备工作的线程有要求（例如弹出一个显示进度的对话框，这必须在主线程执行）， <code>onStart()</code> 就不适用了，因为它总是在 subscribe 所发生的线程被调用，而不能指定线程。要在指定的线程来做准备工作，可以使用 <code>doOnSubscribe()</code> 方法，具体可以在后面的文中看到。</li><li><code>unsubscribe()</code>: 这是 <code>Subscriber</code> 所实现的另一个接口 <code>Subscription</code> 的方法，用于取消订阅。在这个方法被调用后，<code>Subscriber</code> 将不再接收事件。一般在这个方法调用前，可以使用 <code>isUnsubscribed()</code> 先判断一下状态。 <code>unsubscribe()</code> 这个方法很重要，因为在 <code>subscribe()</code> 之后， <code>Observable</code> 会持有 <code>Subscriber</code> 的引用，这个引用如果不能及时被释放，将有内存泄露的风险。所以最好保持一个原则：要在不再使用的时候尽快在合适的地方（例如 <code>onPause()</code> <code>onStop()</code> 等方法中）调用 <code>unsubscribe()</code> 来解除引用关系，以避免内存泄露的发生。</li></ol><h5 id="2-创建-Observable"><a href="#2-创建-Observable" class="headerlink" title="2) 创建 Observable"></a>2) 创建 Observable</h5><p>Observable 即被观察者，它决定什么时候触发事件以及触发怎样的事件。 RxJava 使用 <code>create()</code> 方法来创建一个 Observable ，并为它定义事件触发规则：</p><figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br></pre></td><td class="code"><pre><span class="line">Observable observable = Observable.create(new Observable.OnSubscribe&lt;String&gt;() &#123;</span><br><span class="line">    @Override</span><br><span class="line">    public void call(Subscriber&lt;? super String&gt; subscriber) &#123;</span><br><span class="line">        subscriber.onNext(&quot;Hello&quot;);</span><br><span class="line">        subscriber.onNext(&quot;Hi&quot;);</span><br><span class="line">        subscriber.onNext(&quot;Aloha&quot;);</span><br><span class="line">        subscriber.onCompleted();</span><br><span class="line">    &#125;</span><br><span class="line">&#125;);</span><br></pre></td></tr></table></figure><p>可以看到，这里传入了一个 <code>OnSubscribe</code> 对象作为参数。<code>OnSubscribe</code> 会被存储在返回的 <code>Observable</code> 对象中，它的作用相当于一个计划表，当 <code>Observable</code> 被订阅的时候，<code>OnSubscribe</code> 的 <code>call()</code> 方法会自动被调用，事件序列就会依照设定依次触发（对于上面的代码，就是观察者<code>Subscriber</code> 将会被调用三次 <code>onNext()</code> 和一次 <code>onCompleted()</code>）。这样，由被观察者调用了观察者的回调方法，就实现了由被观察者向观察者的事件传递，即观察者模式。</p><blockquote><p>这个例子很简单：事件的内容是字符串，而不是一些复杂的对象；事件的内容是已经定好了的，而不像有的观察者模式一样是待确定的（例如网络请求的结果在请求返回之前是未知的）；所有事件在一瞬间被全部发送出去，而不是夹杂一些确定或不确定的时间间隔或者经过某种触发器来触发的。总之，这个例子看起来毫无实用价值。但这是为了便于说明，实质上只要你想，各种各样的事件发送规则你都可以自己来写。至于具体怎么做，后面都会讲到，但现在不行。只有把基础原理先说明白了，上层的运用才能更容易说清楚。</p></blockquote><p><code>create()</code> 方法是 RxJava 最基本的创造事件序列的方法。基于这个方法， RxJava 还提供了一些方法用来快捷创建事件队列，例如：</p><ul><li><code>just(T...)</code>: 将传入的参数依次发送出来。</li></ul><figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br></pre></td><td class="code"><pre><span class="line">Observable observable = Observable.just(&quot;Hello&quot;, &quot;Hi&quot;, &quot;Aloha&quot;);</span><br><span class="line">// 将会依次调用：</span><br><span class="line">// onNext(&quot;Hello&quot;);</span><br><span class="line">// onNext(&quot;Hi&quot;);</span><br><span class="line">// onNext(&quot;Aloha&quot;);</span><br><span class="line">// onCompleted();</span><br></pre></td></tr></table></figure><ul><li><code>from(T[])</code> / <code>from(Iterable)</code> : 将传入的数组或 <code>Iterable</code> 拆分成具体对象后，依次发送出来。</li></ul><figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br></pre></td><td class="code"><pre><span class="line">String[] words = &#123;&quot;Hello&quot;, &quot;Hi&quot;, &quot;Aloha&quot;&#125;;</span><br><span class="line">Observable observable = Observable.from(words);</span><br><span class="line">// 将会依次调用：</span><br><span class="line">// onNext(&quot;Hello&quot;);</span><br><span class="line">// onNext(&quot;Hi&quot;);</span><br><span class="line">// onNext(&quot;Aloha&quot;);</span><br><span class="line">// onCompleted();</span><br></pre></td></tr></table></figure><p>上面 <code>just(T...)</code> 的例子和 <code>from(T[])</code> 的例子，都和之前的 <code>create(OnSubscribe)</code> 的例子是等价的。</p><h5 id="3-Subscribe-订阅"><a href="#3-Subscribe-订阅" class="headerlink" title="3) Subscribe (订阅)"></a>3) Subscribe (订阅)</h5><p>创建了 <code>Observable</code> 和 <code>Observer</code> 之后，再用 <code>subscribe()</code> 方法将它们联结起来，整条链子就可以工作了。代码形式很简单：</p><figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br></pre></td><td class="code"><pre><span class="line">observable.subscribe(observer);</span><br><span class="line">// 或者：</span><br><span class="line">observable.subscribe(subscriber);</span><br></pre></td></tr></table></figure><blockquote><p>有人可能会注意到， <code>subscribe()</code> 这个方法有点怪：它看起来是『<code>observalbe</code> 订阅了 <code>observer</code> / <code>subscriber</code>』而不是『<code>observer</code> / <code>subscriber</code> 订阅了 <code>observalbe</code>』，这看起来就像『杂志订阅了读者』一样颠倒了对象关系。这让人读起来有点别扭，不过如果把 API 设计成 <code>observer.subscribe(observable)</code> / <code>subscriber.subscribe(observable)</code> ，虽然更加符合思维逻辑，但对流式 API 的设计就造成影响了，比较起来明显是得不偿失的。</p></blockquote><p><code>Observable.subscribe(Subscriber)</code> 的内部实现是这样的（仅核心代码）：</p><figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br></pre></td><td class="code"><pre><span class="line">// 注意：这不是 subscribe() 的源码，而是将源码中与性能、兼容性、扩展性有关的代码剔除后的核心代码。</span><br><span class="line">// 如果需要看源码，可以去 RxJava 的 GitHub 仓库下载。</span><br><span class="line">public Subscription subscribe(Subscriber subscriber) &#123;</span><br><span class="line">    subscriber.onStart();</span><br><span class="line">    onSubscribe.call(subscriber);</span><br><span class="line">    return subscriber;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure><p>可以看到，<code>subscriber()</code> 做了3件事：</p><ol><li>调用 <code>Subscriber.onStart()</code> 。这个方法在前面已经介绍过，是一个可选的准备方法。</li><li>调用 <code>Observable</code> 中的 <code>OnSubscribe.call(Subscriber)</code> 。在这里，事件发送的逻辑开始运行。从这也可以看出，在 RxJava 中， <code>Observable</code> 并不是在创建的时候就立即开始发送事件，而是在它被订阅的时候，即当 <code>subscribe()</code> 方法执行的时候。</li><li>将传入的 <code>Subscriber</code> 作为 <code>Subscription</code> 返回。这是为了方便 <code>unsubscribe()</code>.</li></ol><p>整个过程中对象间的关系如下图：</p><p><img src="http://ww4.sinaimg.cn/mw1024/52eb2279jw1f2rx489robj20lk0a8my2.jpg" alt="关系静图"></p><p>或者可以看动图：</p><p><img src="http://ww3.sinaimg.cn/mw1024/52eb2279jw1f2rx4ay0hrg20ig08wk4q.gif" alt="关系静图"></p><p>除了 <code>subscribe(Observer)</code> 和 <code>subscribe(Subscriber)</code> ，<code>subscribe()</code> 还支持不完整定义的回调，RxJava 会自动根据定义创建出 <code>Subscriber</code> 。形式如下：</p><figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br><span class="line">28</span><br></pre></td><td class="code"><pre><span class="line">Action1&lt;String&gt; onNextAction = new Action1&lt;String&gt;() &#123;</span><br><span class="line">    // onNext()</span><br><span class="line">    @Override</span><br><span class="line">    public void call(String s) &#123;</span><br><span class="line">        Log.d(tag, s);</span><br><span class="line">    &#125;</span><br><span class="line">&#125;;</span><br><span class="line">Action1&lt;Throwable&gt; onErrorAction = new Action1&lt;Throwable&gt;() &#123;</span><br><span class="line">    // onError()</span><br><span class="line">    @Override</span><br><span class="line">    public void call(Throwable throwable) &#123;</span><br><span class="line">        // Error handling</span><br><span class="line">    &#125;</span><br><span class="line">&#125;;</span><br><span class="line">Action0 onCompletedAction = new Action0() &#123;</span><br><span class="line">    // onCompleted()</span><br><span class="line">    @Override</span><br><span class="line">    public void call() &#123;</span><br><span class="line">        Log.d(tag, &quot;completed&quot;);</span><br><span class="line">    &#125;</span><br><span class="line">&#125;;</span><br><span class="line"></span><br><span class="line">// 自动创建 Subscriber ，并使用 onNextAction 来定义 onNext()</span><br><span class="line">observable.subscribe(onNextAction);</span><br><span class="line">// 自动创建 Subscriber ，并使用 onNextAction 和 onErrorAction 来定义 onNext() 和 onError()</span><br><span class="line">observable.subscribe(onNextAction, onErrorAction);</span><br><span class="line">// 自动创建 Subscriber ，并使用 onNextAction、 onErrorAction 和 onCompletedAction 来定义 onNext()、 onError() 和 onCompleted()</span><br><span class="line">observable.subscribe(onNextAction, onErrorAction, onCompletedAction);</span><br></pre></td></tr></table></figure><p>简单解释一下这段代码中出现的 <code>Action1</code> 和 <code>Action0</code>。 <code>Action0</code> 是 RxJava 的一个接口，它只有一个方法 <code>call()</code>，这个方法是无参无返回值的；由于 <code>onCompleted()</code> 方法也是无参无返回值的，因此 <code>Action0</code> 可以被当成一个包装对象，将 <code>onCompleted()</code> 的内容打包起来将自己作为一个参数传入 <code>subscribe()</code> 以实现不完整定义的回调。这样其实也可以看做将 <code>onCompleted()</code> 方法作为参数传进了 <code>subscribe()</code>，相当于其他某些语言中的『闭包』。 <code>Action1</code> 也是一个接口，它同样只有一个方法 <code>call(T param)</code>，这个方法也无返回值，但有一个参数；与 <code>Action0</code> 同理，由于 <code>onNext(T obj)</code> 和 <code>onError(Throwable error)</code> 也是单参数无返回值的，因此 <code>Action1</code> 可以将 <code>onNext(obj)</code> 和 <code>onError(error)</code> 打包起来传入 <code>subscribe()</code> 以实现不完整定义的回调。事实上，虽然 <code>Action0</code> 和 <code>Action1</code> 在 API 中使用最广泛，但 RxJava 是提供了多个 <code>ActionX</code> 形式的接口 (例如 <code>Action2</code>, <code>Action3</code>) 的，它们可以被用以包装不同的无返回值的方法。</p><blockquote><p>注：正如前面所提到的，<code>Observer</code> 和 <code>Subscriber</code> 具有相同的角色，而且 <code>Observer</code> 在 <code>subscribe()</code> 过程中最终会被转换成 <code>Subscriber</code> 对象，因此，从这里开始，后面的描述我将用 <code>Subscriber</code> 来代替 <code>Observer</code> ，这样更加严谨。</p></blockquote><h5 id="4-场景示例"><a href="#4-场景示例" class="headerlink" title="4) 场景示例"></a>4) 场景示例</h5><p>下面举两个例子：</p><blockquote><p>为了把原理用更清晰的方式表述出来，本文中挑选的都是功能尽可能简单的例子，以至于有些示例代码看起来会有『画蛇添足』『明明不用 RxJava 可以更简便地解决问题』的感觉。当你看到这种情况，不要觉得是因为 RxJava 太啰嗦，而是因为在过早的时候举出真实场景的例子并不利于原理的解析，因此我刻意挑选了简单的情景。</p></blockquote><h6 id="a-打印字符串数组"><a href="#a-打印字符串数组" class="headerlink" title="a. 打印字符串数组"></a>a. 打印字符串数组</h6><p>将字符串数组 <code>names</code> 中的所有字符串依次打印出来：</p><figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br></pre></td><td class="code"><pre><span class="line">String[] names = ...;</span><br><span class="line">Observable.from(names)</span><br><span class="line">    .subscribe(new Action1&lt;String&gt;() &#123;</span><br><span class="line">        @Override</span><br><span class="line">        public void call(String name) &#123;</span><br><span class="line">            Log.d(tag, name);</span><br><span class="line">        &#125;</span><br><span class="line">    &#125;);</span><br></pre></td></tr></table></figure><h6 id="b-由-id-取得图片并显示"><a href="#b-由-id-取得图片并显示" class="headerlink" title="b. 由 id 取得图片并显示"></a>b. 由 id 取得图片并显示</h6><p>由指定的一个 drawable 文件 id <code>drawableRes</code> 取得图片，并显示在 <code>ImageView</code> 中，并在出现异常的时候打印 Toast 报错：</p><figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br></pre></td><td class="code"><pre><span class="line">int drawableRes = ...;</span><br><span class="line">ImageView imageView = ...;</span><br><span class="line">Observable.create(new OnSubscribe&lt;Drawable&gt;() &#123;</span><br><span class="line">    @Override</span><br><span class="line">    public void call(Subscriber&lt;? super Drawable&gt; subscriber) &#123;</span><br><span class="line">        Drawable drawable = getTheme().getDrawable(drawableRes));</span><br><span class="line">        subscriber.onNext(drawable);</span><br><span class="line">        subscriber.onCompleted();</span><br><span class="line">    &#125;</span><br><span class="line">&#125;).subscribe(new Observer&lt;Drawable&gt;() &#123;</span><br><span class="line">    @Override</span><br><span class="line">    public void onNext(Drawable drawable) &#123;</span><br><span class="line">        imageView.setImageDrawable(drawable);</span><br><span class="line">    &#125;</span><br><span class="line"></span><br><span class="line">    @Override</span><br><span class="line">    public void onCompleted() &#123;</span><br><span class="line">    &#125;</span><br><span class="line"></span><br><span class="line">    @Override</span><br><span class="line">    public void onError(Throwable e) &#123;</span><br><span class="line">        Toast.makeText(activity, &quot;Error!&quot;, Toast.LENGTH_SHORT).show();</span><br><span class="line">    &#125;</span><br><span class="line">&#125;);</span><br></pre></td></tr></table></figure><p>正如上面两个例子这样，创建出 <code>Observable</code> 和 <code>Subscriber</code> ，再用 <code>subscribe()</code> 将它们串起来，一次 RxJava 的基本使用就完成了。非常简单。</p><p>然而，</p><p><img src="http://ww3.sinaimg.cn/mw1024/52eb2279jw1f2rx4ddcncj2046053gll.jpg" alt="这并没有什么diao用"></p><p>在 RxJava 的默认规则中，事件的发出和消费都是在同一个线程的。也就是说，如果只用上面的方法，实现出来的只是一个同步的观察者模式。观察者模式本身的目的就是『后台处理，前台回调』的异步机制，因此异步对于 RxJava 是至关重要的。而要实现异步，则需要用到 RxJava 的另一个概念： <code>Scheduler</code> 。</p><h4 id="3-线程控制-——-Scheduler-一"><a href="#3-线程控制-——-Scheduler-一" class="headerlink" title="3. 线程控制 —— Scheduler (一)"></a>3. 线程控制 —— Scheduler (一)</h4><p>在不指定线程的情况下， RxJava 遵循的是线程不变的原则，即：在哪个线程调用 <code>subscribe()</code>，就在哪个线程生产事件；在哪个线程生产事件，就在哪个线程消费事件。如果需要切换线程，就需要用到 <code>Scheduler</code> （调度器）。</p><h5 id="1-Scheduler-的-API-一"><a href="#1-Scheduler-的-API-一" class="headerlink" title="1) Scheduler 的 API (一)"></a>1) Scheduler 的 API (一)</h5><p>在RxJava 中，<code>Scheduler</code> ——调度器，相当于线程控制器，RxJava 通过它来指定每一段代码应该运行在什么样的线程。RxJava 已经内置了几个 <code>Scheduler</code> ，它们已经适合大多数的使用场景：</p><ul><li><code>Schedulers.immediate()</code>: 直接在当前线程运行，相当于不指定线程。这是默认的 <code>Scheduler</code>。</li><li><code>Schedulers.newThread()</code>: 总是启用新线程，并在新线程执行操作。</li><li><code>Schedulers.io()</code>: I/O 操作（读写文件、读写数据库、网络信息交互等）所使用的 <code>Scheduler</code>。行为模式和 <code>newThread()</code> 差不多，区别在于 <code>io()</code> 的内部实现是是用一个无数量上限的线程池，可以重用空闲的线程，因此多数情况下 <code>io()</code> 比 <code>newThread()</code> 更有效率。不要把计算工作放在 <code>io()</code> 中，可以避免创建不必要的线程。</li><li><code>Schedulers.computation()</code>: 计算所使用的 <code>Scheduler</code>。这个计算指的是 CPU 密集型计算，即不会被 I/O 等操作限制性能的操作，例如图形的计算。这个 <code>Scheduler</code> 使用的固定的线程池，大小为 CPU 核数。不要把 I/O 操作放在 <code>computation()</code> 中，否则 I/O 操作的等待时间会浪费 CPU。</li><li>另外， Android 还有一个专用的 <code>AndroidSchedulers.mainThread()</code>，它指定的操作将在 Android 主线程运行。</li></ul><p>有了这几个 <code>Scheduler</code> ，就可以使用 <code>subscribeOn()</code> 和 <code>observeOn()</code> 两个方法来对线程进行控制了。 <em> <code>subscribeOn()</code>: 指定 <code>subscribe()</code> 所发生的线程，即 <code>Observable.OnSubscribe</code> 被激活时所处的线程。或者叫做事件产生的线程。 </em> <code>observeOn()</code>: 指定 <code>Subscriber</code> 所运行在的线程。或者叫做事件消费的线程。</p><p>文字叙述总归难理解，上代码：</p><figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br></pre></td><td class="code"><pre><span class="line">Observable.just(1, 2, 3, 4)</span><br><span class="line">    .subscribeOn(Schedulers.io()) // 指定 subscribe() 发生在 IO 线程</span><br><span class="line">    .observeOn(AndroidSchedulers.mainThread()) // 指定 Subscriber 的回调发生在主线程</span><br><span class="line">    .subscribe(new Action1&lt;Integer&gt;() &#123;</span><br><span class="line">        @Override</span><br><span class="line">        public void call(Integer number) &#123;</span><br><span class="line">            Log.d(tag, &quot;number:&quot; + number);</span><br><span class="line">        &#125;</span><br><span class="line">    &#125;);</span><br></pre></td></tr></table></figure><p>上面这段代码中，由于 <code>subscribeOn(Schedulers.io())</code> 的指定，被创建的事件的内容 <code>1</code>、<code>2</code>、<code>3</code>、<code>4</code> 将会在 IO 线程发出；而由于 <code>observeOn(AndroidScheculers.mainThread()</code>) 的指定，因此 <code>subscriber</code> 数字的打印将发生在主线程 。事实上，这种在 <code>subscribe()</code> 之前写上两句 <code>subscribeOn(Scheduler.io())</code> 和 <code>observeOn(AndroidSchedulers.mainThread())</code> 的使用方式非常常见，它适用于多数的 『后台线程取数据，主线程显示』的程序策略。</p><p>而前面提到的由图片 id 取得图片并显示的例子，如果也加上这两句：</p><figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br></pre></td><td class="code"><pre><span class="line">int drawableRes = ...;</span><br><span class="line">ImageView imageView = ...;</span><br><span class="line">Observable.create(new OnSubscribe&lt;Drawable&gt;() &#123;</span><br><span class="line">    @Override</span><br><span class="line">    public void call(Subscriber&lt;? super Drawable&gt; subscriber) &#123;</span><br><span class="line">        Drawable drawable = getTheme().getDrawable(drawableRes));</span><br><span class="line">        subscriber.onNext(drawable);</span><br><span class="line">        subscriber.onCompleted();</span><br><span class="line">    &#125;</span><br><span class="line">&#125;)</span><br><span class="line">.subscribeOn(Schedulers.io()) // 指定 subscribe() 发生在 IO 线程</span><br><span class="line">.observeOn(AndroidSchedulers.mainThread()) // 指定 Subscriber 的回调发生在主线程</span><br><span class="line">.subscribe(new Observer&lt;Drawable&gt;() &#123;</span><br><span class="line">    @Override</span><br><span class="line">    public void onNext(Drawable drawable) &#123;</span><br><span class="line">        imageView.setImageDrawable(drawable);</span><br><span class="line">    &#125;</span><br><span class="line"></span><br><span class="line">    @Override</span><br><span class="line">    public void onCompleted() &#123;</span><br><span class="line">    &#125;</span><br><span class="line"></span><br><span class="line">    @Override</span><br><span class="line">    public void onError(Throwable e) &#123;</span><br><span class="line">        Toast.makeText(activity, &quot;Error!&quot;, Toast.LENGTH_SHORT).show();</span><br><span class="line">    &#125;</span><br><span class="line">&#125;);</span><br></pre></td></tr></table></figure><p>那么，加载图片将会发生在 IO 线程，而设置图片则被设定在了主线程。这就意味着，即使加载图片耗费了几十甚至几百毫秒的时间，也不会造成丝毫界面的卡顿。</p><h5 id="2-Scheduler-的原理-一"><a href="#2-Scheduler-的原理-一" class="headerlink" title="2) Scheduler 的原理 (一)"></a>2) Scheduler 的原理 (一)</h5><p>RxJava 的 Scheduler API 很方便，也很神奇（加了一句话就把线程切换了，怎么做到的？而且 <code>subscribe()</code> 不是最外层直接调用的方法吗，它竟然也能被指定线程？）。然而 Scheduler 的原理需要放在后面讲，因为它的原理是以下一节《变换》的原理作为基础的。</p><p>好吧这一节其实我屁也没说，只是为了让你安心，让你知道我不是忘了讲原理，而是把它放在了更合适的地方。</p><h4 id="4-变换"><a href="#4-变换" class="headerlink" title="4. 变换"></a>4. 变换</h4><p>终于要到牛逼的地方了，不管你激动不激动，反正我是激动了。</p><p>RxJava 提供了对事件序列进行变换的支持，这是它的核心功能之一，也是大多数人说『RxJava 真是太好用了』的最大原因。<strong>所谓变换，就是将事件序列中的对象或整个序列进行加工处理，转换成不同的事件或事件序列。</strong>概念说着总是模糊难懂的，来看 API。</p><h5 id="1-API"><a href="#1-API" class="headerlink" title="1) API"></a>1) API</h5><p>首先看一个 <code>map()</code> 的例子：</p><figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br></pre></td><td class="code"><pre><span class="line">Observable.just(&quot;images/logo.png&quot;) // 输入类型 String</span><br><span class="line">    .map(new Func1&lt;String, Bitmap&gt;() &#123;</span><br><span class="line">        @Override</span><br><span class="line">        public Bitmap call(String filePath) &#123; // 参数类型 String</span><br><span class="line">            return getBitmapFromPath(filePath); // 返回类型 Bitmap</span><br><span class="line">        &#125;</span><br><span class="line">    &#125;)</span><br><span class="line">    .subscribe(new Action1&lt;Bitmap&gt;() &#123;</span><br><span class="line">        @Override</span><br><span class="line">        public void call(Bitmap bitmap) &#123; // 参数类型 Bitmap</span><br><span class="line">            showBitmap(bitmap);</span><br><span class="line">        &#125;</span><br><span class="line">    &#125;);</span><br></pre></td></tr></table></figure><p>这里出现了一个叫做 <code>Func1</code> 的类。它和 <code>Action1</code> 非常相似，也是 RxJava 的一个接口，用于包装含有一个参数的方法。 <code>Func1</code> 和 <code>Action</code>的区别在于， <code>Func1</code> 包装的是有返回值的方法。另外，和 <code>ActionX</code> 一样， <code>FuncX</code> 也有多个，用于不同参数个数的方法。<code>FuncX</code> 和 <code>ActionX</code> 的区别在 <code>FuncX</code> 包装的是有返回值的方法。</p><p>可以看到，<code>map()</code> 方法将参数中的 <code>String</code> 对象转换成一个 <code>Bitmap</code> 对象后返回，而在经过 <code>map()</code> 方法后，事件的参数类型也由 <code>String</code>转为了 <code>Bitmap</code>。这种直接变换对象并返回的，是最常见的也最容易理解的变换。不过 RxJava 的变换远不止这样，它不仅可以针对事件对象，还可以针对整个事件队列，这使得 RxJava 变得非常灵活。我列举几个常用的变换：</p><ul><li><code>map()</code>: 事件对象的直接变换，具体功能上面已经介绍过。它是 RxJava 最常用的变换。 <code>map()</code> 的示意图：<img src="http://ww1.sinaimg.cn/mw1024/52eb2279jw1f2rx4fitvfj20hw0ea0tg.jpg" alt="map() 示意图"></li><li><code>flatMap()</code>: 这是一个很有用但<strong>非常难理解</strong>的变换，因此我决定花多些篇幅来介绍它。 首先假设这么一种需求：假设有一个数据结构『学生』，现在需要打印出一组学生的名字。实现方式很简单：</li></ul><figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br></pre></td><td class="code"><pre><span class="line">Student[] students = ...;</span><br><span class="line">Subscriber&lt;String&gt; subscriber = new Subscriber&lt;String&gt;() &#123;</span><br><span class="line">    @Override</span><br><span class="line">    public void onNext(String name) &#123;</span><br><span class="line">        Log.d(tag, name);</span><br><span class="line">    &#125;</span><br><span class="line">    ...</span><br><span class="line">&#125;;</span><br><span class="line">Observable.from(students)</span><br><span class="line">    .map(new Func1&lt;Student, String&gt;() &#123;</span><br><span class="line">        @Override</span><br><span class="line">        public String call(Student student) &#123;</span><br><span class="line">            return student.getName();</span><br><span class="line">        &#125;</span><br><span class="line">    &#125;)</span><br><span class="line">    .subscribe(subscriber);</span><br></pre></td></tr></table></figure><p>很简单。那么再假设：如果要打印出每个学生所需要修的所有课程的名称呢？（需求的区别在于，每个学生只有一个名字，但却有多个课程。）首先可以这样实现：</p><figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br></pre></td><td class="code"><pre><span class="line">Student[] students = ...;</span><br><span class="line">Subscriber&lt;Student&gt; subscriber = new Subscriber&lt;Student&gt;() &#123;</span><br><span class="line">    @Override</span><br><span class="line">    public void onNext(Student student) &#123;</span><br><span class="line">        List&lt;Course&gt; courses = student.getCourses();</span><br><span class="line">        for (int i = 0; i &lt; courses.size(); i++) &#123;</span><br><span class="line">            Course course = courses.get(i);</span><br><span class="line">            Log.d(tag, course.getName());</span><br><span class="line">        &#125;</span><br><span class="line">    &#125;</span><br><span class="line">    ...</span><br><span class="line">&#125;;</span><br><span class="line">Observable.from(students)</span><br><span class="line">    .subscribe(subscriber);</span><br></pre></td></tr></table></figure><p>依然很简单。那么如果我不想在 <code>Subscriber</code> 中使用 for 循环，而是希望 <code>Subscriber</code> 中直接传入单个的 <code>Course</code> 对象呢（这对于代码复用很重要）？用 <code>map()</code> 显然是不行的，因为 <code>map()</code> 是一对一的转化，而我现在的要求是一对多的转化。那怎么才能把一个 Student 转化成多个 Course 呢？</p><p>这个时候，就需要用 <code>flatMap()</code> 了：</p><figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br></pre></td><td class="code"><pre><span class="line">Student[] students = ...;</span><br><span class="line">Subscriber&lt;Course&gt; subscriber = new Subscriber&lt;Course&gt;() &#123;</span><br><span class="line">    @Override</span><br><span class="line">    public void onNext(Course course) &#123;</span><br><span class="line">        Log.d(tag, course.getName());</span><br><span class="line">    &#125;</span><br><span class="line">    ...</span><br><span class="line">&#125;;</span><br><span class="line">Observable.from(students)</span><br><span class="line">    .flatMap(new Func1&lt;Student, Observable&lt;Course&gt;&gt;() &#123;</span><br><span class="line">        @Override</span><br><span class="line">        public Observable&lt;Course&gt; call(Student student) &#123;</span><br><span class="line">            return Observable.from(student.getCourses());</span><br><span class="line">        &#125;</span><br><span class="line">    &#125;)</span><br><span class="line">    .subscribe(subscriber);</span><br></pre></td></tr></table></figure><p>从上面的代码可以看出， <code>flatMap()</code> 和 <code>map()</code> 有一个相同点：它也是把传入的参数转化之后返回另一个对象。但需要注意，和 <code>map()</code> 不同的是， <code>flatMap()</code> 中返回的是个 <code>Observable</code> 对象，并且这个 <code>Observable</code> 对象并不是被直接发送到了 <code>Subscriber</code> 的回调方法中。 <code>flatMap()</code> 的原理是这样的：1. 使用传入的事件对象创建一个 <code>Observable</code> 对象；2. 并不发送这个 <code>Observable</code>, 而是将它激活，于是它开始发送事件；3. 每一个创建出来的 <code>Observable</code> 发送的事件，都被汇入同一个 <code>Observable</code> ，而这个 <code>Observable</code> 负责将这些事件统一交给 <code>Subscriber</code> 的回调方法。这三个步骤，把事件拆成了两级，通过一组新创建的 <code>Observable</code> 将初始的对象『铺平』之后通过统一路径分发了下去。而这个『铺平』就是 <code>flatMap()</code> 所谓的 flat。</p><p><code>flatMap()</code> 示意图：</p><p><img src="http://ww1.sinaimg.cn/mw1024/52eb2279jw1f2rx4i8da2j20hg0dydgx.jpg" alt="flatMap() 示意图"></p><p>扩展：由于可以在嵌套的 <code>Observable</code> 中添加异步代码， <code>flatMap()</code> 也常用于嵌套的异步操作，例如嵌套的网络请求。示例代码（Retrofit + RxJava）：</p><figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br></pre></td><td class="code"><pre><span class="line">networkClient.token() // 返回 Observable&lt;String&gt;，在订阅时请求 token，并在响应后发送 token</span><br><span class="line">    .flatMap(new Func1&lt;String, Observable&lt;Messages&gt;&gt;() &#123;</span><br><span class="line">        @Override</span><br><span class="line">        public Observable&lt;Messages&gt; call(String token) &#123;</span><br><span class="line">            // 返回 Observable&lt;Messages&gt;，在订阅时请求消息列表，并在响应后发送请求到的消息列表</span><br><span class="line">            return networkClient.messages();</span><br><span class="line">        &#125;</span><br><span class="line">    &#125;)</span><br><span class="line">    .subscribe(new Action1&lt;Messages&gt;() &#123;</span><br><span class="line">        @Override</span><br><span class="line">        public void call(Messages messages) &#123;</span><br><span class="line">            // 处理显示消息列表</span><br><span class="line">            showMessages(messages);</span><br><span class="line">        &#125;</span><br><span class="line">    &#125;);</span><br></pre></td></tr></table></figure><p>传统的嵌套请求需要使用嵌套的 Callback 来实现。而通过 <code>flatMap()</code> ，可以把嵌套的请求写在一条链中，从而保持程序逻辑的清晰。</p><ul><li><code>throttleFirst()</code>: 在每次事件触发后的一定时间间隔内丢弃新的事件。常用作去抖动过滤，例如按钮的点击监听器：<code>RxView.clickEvents(button) // RxBinding 代码，后面的文章有解释 .throttleFirst(500, TimeUnit.MILLISECONDS) // 设置防抖间隔为 500ms .subscribe(subscriber);</code>妈妈再也不怕我的用户手抖点开两个重复的界面啦。</li></ul><p>此外， RxJava 还提供很多便捷的方法来实现事件序列的变换，这里就不一一举例了。</p><h5 id="2-变换的原理：lift"><a href="#2-变换的原理：lift" class="headerlink" title="2) 变换的原理：lift()"></a>2) 变换的原理：lift()</h5><p>这些变换虽然功能各有不同，但实质上都是<strong>针对事件序列的处理和再发送</strong>。而在 RxJava 的内部，它们是基于同一个基础的变换方法： <code>lift(Operator)</code>。首先看一下 <code>lift()</code> 的内部实现（仅核心代码）：</p><figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br></pre></td><td class="code"><pre><span class="line">// 注意：这不是 lift() 的源码，而是将源码中与性能、兼容性、扩展性有关的代码剔除后的核心代码。</span><br><span class="line">// 如果需要看源码，可以去 RxJava 的 GitHub 仓库下载。</span><br><span class="line">public &lt;R&gt; Observable&lt;R&gt; lift(Operator&lt;? extends R, ? super T&gt; operator) &#123;</span><br><span class="line">    return Observable.create(new OnSubscribe&lt;R&gt;() &#123;</span><br><span class="line">        @Override</span><br><span class="line">        public void call(Subscriber subscriber) &#123;</span><br><span class="line">            Subscriber newSubscriber = operator.call(subscriber);</span><br><span class="line">            newSubscriber.onStart();</span><br><span class="line">            onSubscribe.call(newSubscriber);</span><br><span class="line">        &#125;</span><br><span class="line">    &#125;);</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure><p>这段代码很有意思：它生成了一个新的 <code>Observable</code> 并返回，而且创建新 <code>Observable</code> 所用的参数 <code>OnSubscribe</code> 的回调方法 <code>call()</code> 中的实现竟然看起来和前面讲过的 <code>Observable.subscribe()</code> 一样！然而它们并不一样哟~不一样的地方关键就在于第二行 <code>onSubscribe.call(subscriber)</code> 中的 <strong>onSubscribe 所指代的对象不同</strong>（高能预警：接下来的几句话可能会导致身体的严重不适）——</p><ul><li><code>subscribe()</code> 中这句话的 <code>onSubscribe</code> 指的是 <code>Observable</code> 中的 <code>onSubscribe</code> 对象，这个没有问题，但是 <code>lift()</code> 之后的情况就复杂了点。</li><li>当含有 <code>lift()</code> 时：<br>1.<code>lift()</code> 创建了一个 <code>Observable</code> 后，加上之前的原始 <code>Observable</code>，已经有两个 <code>Observable</code> 了；<br>2.而同样地，新 <code>Observable</code> 里的新 <code>OnSubscribe</code> 加上之前的原始 <code>Observable</code> 中的原始 <code>OnSubscribe</code>，也就有了两个 <code>OnSubscribe</code>；<br>3.当用户调用经过 <code>lift()</code> 后的 <code>Observable</code> 的 <code>subscribe()</code> 的时候，使用的是 <code>lift()</code> 所返回的新的 <code>Observable</code> ，于是它所触发的 <code>onSubscribe.call(subscriber)</code>，也是用的新 <code>Observable</code> 中的新 <code>OnSubscribe</code>，即在 <code>lift()</code> 中生成的那个 <code>OnSubscribe</code>；<br>4.而这个新 <code>OnSubscribe</code> 的 <code>call()</code> 方法中的 <code>onSubscribe</code> ，就是指的原始 <code>Observable</code> 中的原始 <code>OnSubscribe</code> ，在这个 <code>call()</code> 方法里，新 <code>OnSubscribe</code> 利用 <code>operator.call(subscriber)</code> 生成了一个新的 <code>Subscriber</code>（<code>Operator</code> 就是在这里，通过自己的 <code>call()</code> 方法将新 <code>Subscriber</code> 和原始 <code>Subscriber</code> 进行关联，并插入自己的『变换』代码以实现变换），然后利用这个新 <code>Subscriber</code> 向原始 <code>Observable</code> 进行订阅。<br>这样就实现了 <code>lift()</code> 过程，有点<strong>像一种代理机制，通过事件拦截和处理实现事件序列的变换。</strong></li></ul><p>精简掉细节的话，也可以这么说：在 <code>Observable</code> 执行了 <code>lift(Operator)</code> 方法之后，会返回一个新的 <code>Observable</code>，这个新的 <code>Observable</code> 会像一个代理一样，负责接收原始的 <code>Observable</code> 发出的事件，并在处理后发送给 <code>Subscriber</code>。</p><p>如果你更喜欢具象思维，可以看图：</p><p><img src="http://ww1.sinaimg.cn/mw1024/52eb2279jw1f2rxcrna27j20h40d1q4f.jpg" alt="lift() 原理图"></p><p>或者可以看动图：</p><p><img src="http://ww4.sinaimg.cn/mw1024/52eb2279jw1f2rxcu9f46g20go0cz4qp.gif" alt="lift 原理动图"></p><p>两次和多次的 <code>lift()</code> 同理，如下图：</p><p><img src="http://ww1.sinaimg.cn/mw1024/52eb2279jw1f2rxcvophmj20h30hl0v3.jpg" alt="两次 lift"></p><p>举一个具体的 <code>Operator</code> 的实现。下面这是一个将事件中的 <code>Integer</code> 对象转换成 <code>String</code> 的例子，仅供参考：</p><figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br></pre></td><td class="code"><pre><span class="line">observable.lift(new Observable.Operator&lt;String, Integer&gt;() &#123;</span><br><span class="line">    @Override</span><br><span class="line">    public Subscriber&lt;? super Integer&gt; call(final Subscriber&lt;? super String&gt; subscriber) &#123;</span><br><span class="line">        // 将事件序列中的 Integer 对象转换为 String 对象</span><br><span class="line">        return new Subscriber&lt;Integer&gt;() &#123;</span><br><span class="line">            @Override</span><br><span class="line">            public void onNext(Integer integer) &#123;</span><br><span class="line">                subscriber.onNext(&quot;&quot; + integer);</span><br><span class="line">            &#125;</span><br><span class="line"></span><br><span class="line">            @Override</span><br><span class="line">            public void onCompleted() &#123;</span><br><span class="line">                subscriber.onCompleted();</span><br><span class="line">            &#125;</span><br><span class="line"></span><br><span class="line">            @Override</span><br><span class="line">            public void onError(Throwable e) &#123;</span><br><span class="line">                subscriber.onError(e);</span><br><span class="line">            &#125;</span><br><span class="line">        &#125;;</span><br><span class="line">    &#125;</span><br><span class="line">&#125;);</span><br></pre></td></tr></table></figure><blockquote><p>讲述 <code>lift()</code> 的原理只是为了让你更好地了解 RxJava ，从而可以更好地使用它。然而不管你是否理解了 <code>lift()</code> 的原理，RxJava 都不建议开发者自定义 <code>Operator</code> 来直接使用 <code>lift()</code>，而是建议尽量使用已有的 <code>lift()</code> 包装方法（如 <code>map()</code> <code>flatMap()</code> 等）进行组合来实现需求，因为直接使用 lift() 非常容易发生一些难以发现的错误。</p></blockquote><h5 id="3-compose-对-Observable-整体的变换"><a href="#3-compose-对-Observable-整体的变换" class="headerlink" title="3) compose: 对 Observable 整体的变换"></a>3) compose: 对 Observable 整体的变换</h5><p>除了 <code>lift()</code> 之外， <code>Observable</code> 还有一个变换方法叫做 <code>compose(Transformer)</code>。它和 <code>lift()</code> 的区别在于， <strong>lift() 是针对事件项和事件序列的，而 compose() 是针对 Observable 自身进行变换。</strong>举个例子，假设在程序中有多个 <code>Observable</code> ，并且他们都需要应用一组相同的 <code>lift()</code> 变换。你可以这么写：</p><figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br></pre></td><td class="code"><pre><span class="line">observable1</span><br><span class="line">    .lift1()</span><br><span class="line">    .lift2()</span><br><span class="line">    .lift3()</span><br><span class="line">    .lift4()</span><br><span class="line">    .subscribe(subscriber1);</span><br><span class="line">observable2</span><br><span class="line">    .lift1()</span><br><span class="line">    .lift2()</span><br><span class="line">    .lift3()</span><br><span class="line">    .lift4()</span><br><span class="line">    .subscribe(subscriber2);</span><br><span class="line">observable3</span><br><span class="line">    .lift1()</span><br><span class="line">    .lift2()</span><br><span class="line">    .lift3()</span><br><span class="line">    .lift4()</span><br><span class="line">    .subscribe(subscriber3);</span><br><span class="line">observable4</span><br><span class="line">    .lift1()</span><br><span class="line">    .lift2()</span><br><span class="line">    .lift3()</span><br><span class="line">    .lift4()</span><br><span class="line">    .subscribe(subscriber1);</span><br></pre></td></tr></table></figure><p>你觉得这样太不软件工程了，于是你改成了这样：</p><figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br></pre></td><td class="code"><pre><span class="line">private Observable liftAll(Observable observable) &#123;</span><br><span class="line">    return observable</span><br><span class="line">        .lift1()</span><br><span class="line">        .lift2()</span><br><span class="line">        .lift3()</span><br><span class="line">        .lift4();</span><br><span class="line">&#125;</span><br><span class="line">...</span><br><span class="line">liftAll(observable1).subscribe(subscriber1);</span><br><span class="line">liftAll(observable2).subscribe(subscriber2);</span><br><span class="line">liftAll(observable3).subscribe(subscriber3);</span><br><span class="line">liftAll(observable4).subscribe(subscriber4);</span><br></pre></td></tr></table></figure><p>可读性、可维护性都提高了。可是 <code>Observable</code> 被一个方法包起来，这种方式对于 <code>Observale</code> 的灵活性似乎还是增添了那么点限制。怎么办？这个时候，就应该用 <code>compose()</code> 来解决了：</p><figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br></pre></td><td class="code"><pre><span class="line">public class LiftAllTransformer implements Observable.Transformer&lt;Integer, String&gt; &#123;</span><br><span class="line">    @Override</span><br><span class="line">    public Observable&lt;String&gt; call(Observable&lt;Integer&gt; observable) &#123;</span><br><span class="line">        return observable</span><br><span class="line">            .lift1()</span><br><span class="line">            .lift2()</span><br><span class="line">            .lift3()</span><br><span class="line">            .lift4();</span><br><span class="line">    &#125;</span><br><span class="line">&#125;</span><br><span class="line">...</span><br><span class="line">Transformer liftAll = new LiftAllTransformer();</span><br><span class="line">observable1.compose(liftAll).subscribe(subscriber1);</span><br><span class="line">observable2.compose(liftAll).subscribe(subscriber2);</span><br><span class="line">observable3.compose(liftAll).subscribe(subscriber3);</span><br><span class="line">observable4.compose(liftAll).subscribe(subscriber4);</span><br></pre></td></tr></table></figure><p>像上面这样，使用 <code>compose()</code> 方法，<code>Observable</code> 可以利用传入的 <code>Transformer</code> 对象的 <code>call</code> 方法直接对自身进行处理，也就不必被包在方法的里面了。</p><p><code>compose()</code> 的原理比较简单，不附图喽。</p><h4 id="5-线程控制：Scheduler-二"><a href="#5-线程控制：Scheduler-二" class="headerlink" title="5. 线程控制：Scheduler (二)"></a>5. 线程控制：Scheduler (二)</h4><p>除了灵活的变换，RxJava 另一个牛逼的地方，就是线程的自由控制。</p><h5 id="1-Scheduler-的-API-二"><a href="#1-Scheduler-的-API-二" class="headerlink" title="1) Scheduler 的 API (二)"></a>1) Scheduler 的 API (二)</h5><p>前面讲到了，可以利用 <code>subscribeOn()</code> 结合 <code>observeOn()</code> 来实现线程控制，让事件的产生和消费发生在不同的线程。可是在了解了 <code>map()</code> <code>flatMap()</code> 等变换方法后，有些好事的（其实就是当初刚接触 RxJava 时的我）就问了：能不能多切换几次线程？</p><p>答案是：能。因为 <code>observeOn()</code> 指定的是 <code>Subscriber</code> 的线程，而这个 <code>Subscriber</code> 并不是（严格说应该为『不一定是』，但这里不妨理解为『不是』）<code>subscribe()</code> 参数中的 <code>Subscriber</code> ，而是 <code>observeOn()</code> 执行时的当前 <code>Observable</code> 所对应的 <code>Subscriber</code> ，即它的直接下级 <code>Subscriber</code> 。换句话说，<code>observeOn()</code> 指定的是它之后的操作所在的线程。因此如果有多次切换线程的需求，只要在每个想要切换线程的位置调用一次 <code>observeOn()</code> 即可。上代码：</p><figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br></pre></td><td class="code"><pre><span class="line">Observable.just(1, 2, 3, 4) // IO 线程，由 subscribeOn() 指定</span><br><span class="line">    .subscribeOn(Schedulers.io())</span><br><span class="line">    .observeOn(Schedulers.newThread())</span><br><span class="line">    .map(mapOperator) // 新线程，由 observeOn() 指定</span><br><span class="line">    .observeOn(Schedulers.io())</span><br><span class="line">    .map(mapOperator2) // IO 线程，由 observeOn() 指定</span><br><span class="line">    .observeOn(AndroidSchedulers.mainThread) </span><br><span class="line">    .subscribe(subscriber);  // Android 主线程，由 observeOn() 指定</span><br></pre></td></tr></table></figure><p>如上，通过 <code>observeOn()</code> 的多次调用，程序实现了线程的多次切换。</p><p>不过，不同于 <code>observeOn()</code> ， <code>subscribeOn()</code> 的位置放在哪里都可以，但它是只能调用一次的。</p><p>又有好事的（其实还是当初的我）问了：如果我非要调用多次 <code>subscribeOn()</code> 呢？会有什么效果？</p><p>这个问题先放着，我们还是从 RxJava 线程控制的原理说起吧。</p><h5 id="2-Scheduler-的原理（二）"><a href="#2-Scheduler-的原理（二）" class="headerlink" title="2) Scheduler 的原理（二）"></a>2) Scheduler 的原理（二）</h5><p>其实， <code>subscribeOn()</code> 和 <code>observeOn()</code> 的内部实现，也是用的 <code>lift()</code>。具体看图（不同颜色的箭头表示不同的线程）：</p><p><code>subscribeOn()</code> 原理图：</p><p><img src="http://ww4.sinaimg.cn/mw1024/52eb2279jw1f2rxcynbsuj20ha0d7wg2.jpg" alt="subscribeOn() 原理"></p><p><code>observeOn()</code> 原理图：</p><p><img src="http://ww4.sinaimg.cn/mw1024/52eb2279jw1f2rxd05lttj20hj0cyabl.jpg" alt="observeOn() 原理"></p><p>从图中可以看出，<code>subscribeOn()</code> 和 <code>observeOn()</code> 都做了线程切换的工作（图中的 “schedule…” 部位）。不同的是， <code>subscribeOn()</code> 的线程切换发生在 <code>OnSubscribe</code> 中，即在它通知上一级 <code>OnSubscribe</code> 时，这时事件还没有开始发送，因此 <code>subscribeOn()</code> 的线程控制可以从事件发出的开端就造成影响；而 <code>observeOn()</code> 的线程切换则发生在它内建的 <code>Subscriber</code> 中，即发生在它即将给下一级 <code>Subscriber</code> 发送事件时，因此 <code>observeOn()</code> 控制的是它后面的线程。</p><p>最后，我用一张图来解释当多个 <code>subscribeOn()</code> 和 <code>observeOn()</code> 混合使用时，线程调度是怎么发生的（由于图中对象较多，相对于上面的图对结构做了一些简化调整）：</p><p><img src="http://ww1.sinaimg.cn/mw1024/52eb2279jw1f2rxd1vl7xj20hd0hzq6e.jpg" alt="线程控制综合调用"></p><p>图中共有 5 处含有对事件的操作。由图中可以看出，①和②两处受第一个 <code>subscribeOn()</code> 影响，运行在红色线程；③和④处受第一个 <code>observeOn()</code> 的影响，运行在绿色线程；⑤处受第二个 <code>onserveOn()</code> 影响，运行在紫色线程；而第二个 <code>subscribeOn()</code> ，由于在通知过程中线程就被第一个 <code>subscribeOn()</code> 截断，因此对整个流程并没有任何影响。这里也就回答了前面的问题：当使用了多个 <code>subscribeOn()</code> 的时候，只有第一个 <code>subscribeOn()</code> 起作用。</p><h5 id="3-延伸：doOnSubscribe"><a href="#3-延伸：doOnSubscribe" class="headerlink" title="3) 延伸：doOnSubscribe()"></a>3) 延伸：doOnSubscribe()</h5><p>然而，虽然超过一个的 <code>subscribeOn()</code> 对事件处理的流程没有影响，但在流程之前却是可以利用的。</p><p>在前面讲 <code>Subscriber</code> 的时候，提到过 <code>Subscriber</code> 的 <code>onStart()</code> 可以用作流程开始前的初始化。然而 <code>onStart()</code> 由于在 <code>subscribe()</code> 发生时就被调用了，因此不能指定线程，而是只能执行在 <code>subscribe()</code> 被调用时的线程。这就导致如果 <code>onStart()</code> 中含有对线程有要求的代码（例如在界面上显示一个 ProgressBar，这必须在主线程执行），将会有线程非法的风险，因为有时你无法预测 <code>subscribe()</code> 将会在什么线程执行。</p><p>而与 <code>Subscriber.onStart()</code> 相对应的，有一个方法 <code>Observable.doOnSubscribe()</code> 。它和 <code>Subscriber.onStart()</code> 同样是在 <code>subscribe()</code>调用后而且在事件发送前执行，但区别在于它可以指定线程。默认情况下， <code>doOnSubscribe()</code> 执行在 <code>subscribe()</code> 发生的线程；而如果在 <code>doOnSubscribe()</code> 之后有 <code>subscribeOn()</code> 的话，它将执行在离它最近的 <code>subscribeOn()</code> 所指定的线程。</p><p>示例代码：</p><figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br></pre></td><td class="code"><pre><span class="line">Observable.create(onSubscribe)</span><br><span class="line">    .subscribeOn(Schedulers.io())</span><br><span class="line">    .doOnSubscribe(new Action0() &#123;</span><br><span class="line">        @Override</span><br><span class="line">        public void call() &#123;</span><br><span class="line">            progressBar.setVisibility(View.VISIBLE); // 需要在主线程执行</span><br><span class="line">        &#125;</span><br><span class="line">    &#125;)</span><br><span class="line">    .subscribeOn(AndroidSchedulers.mainThread()) // 指定主线程</span><br><span class="line">    .observeOn(AndroidSchedulers.mainThread())</span><br><span class="line">    .subscribe(subscriber);</span><br></pre></td></tr></table></figure><p>如上，在 <code>doOnSubscribe()</code>的后面跟一个 <code>subscribeOn()</code> ，就能指定准备工作的线程了。</p><h3 id="RxJava-的适用场景和使用方式"><a href="#RxJava-的适用场景和使用方式" class="headerlink" title="RxJava 的适用场景和使用方式"></a>RxJava 的适用场景和使用方式</h3><h4 id="1-与-Retrofit-的结合"><a href="#1-与-Retrofit-的结合" class="headerlink" title="1. 与 Retrofit 的结合"></a>1. 与 Retrofit 的结合</h4><blockquote><p>Retrofit 是 Square 的一个著名的网络请求库。没有用过 Retrofit 的可以选择跳过这一小节也没关系，我举的每种场景都只是个例子，而且例子之间并无前后关联，只是个抛砖引玉的作用，所以你跳过这里看别的场景也可以的。</p></blockquote><p>Retrofit 除了提供了传统的 <code>Callback</code> 形式的 API，还有 RxJava 版本的 <code>Observable</code> 形式 API。下面我用对比的方式来介绍 Retrofit 的 RxJava 版 API 和传统版本的区别。</p><p>以获取一个 <code>User</code> 对象的接口作为例子。使用Retrofit 的传统 API，你可以用这样的方式来定义请求：</p><figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br></pre></td><td class="code"><pre><span class="line">@GET(&quot;/user&quot;)</span><br><span class="line">public void getUser(@Query(&quot;userId&quot;) String userId, Callback&lt;User&gt; callback);</span><br></pre></td></tr></table></figure><p>在程序的构建过程中， Retrofit 会把自动把方法实现并生成代码，然后开发者就可以利用下面的方法来获取特定用户并处理响应：</p><figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br></pre></td><td class="code"><pre><span class="line">getUser(userId, new Callback&lt;User&gt;() &#123;</span><br><span class="line">    @Override</span><br><span class="line">    public void success(User user) &#123;</span><br><span class="line">        userView.setUser(user);</span><br><span class="line">    &#125;</span><br><span class="line"></span><br><span class="line">    @Override</span><br><span class="line">    public void failure(RetrofitError error) &#123;</span><br><span class="line">        // Error handling</span><br><span class="line">        ...</span><br><span class="line">    &#125;</span><br><span class="line">&#125;;</span><br></pre></td></tr></table></figure><p>而使用 RxJava 形式的 API，定义同样的请求是这样的：</p><figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br></pre></td><td class="code"><pre><span class="line">@GET(&quot;/user&quot;)</span><br><span class="line">public Observable&lt;User&gt; getUser(@Query(&quot;userId&quot;) String userId);</span><br></pre></td></tr></table></figure><p>使用的时候是这样的：</p><figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br></pre></td><td class="code"><pre><span class="line">getUser(userId)</span><br><span class="line">    .observeOn(AndroidSchedulers.mainThread())</span><br><span class="line">    .subscribe(new Observer&lt;User&gt;() &#123;</span><br><span class="line">        @Override</span><br><span class="line">        public void onNext(User user) &#123;</span><br><span class="line">            userView.setUser(user);</span><br><span class="line">        &#125;</span><br><span class="line"></span><br><span class="line">        @Override</span><br><span class="line">        public void onCompleted() &#123;</span><br><span class="line">        &#125;</span><br><span class="line"></span><br><span class="line">        @Override</span><br><span class="line">        public void onError(Throwable error) &#123;</span><br><span class="line">            // Error handling</span><br><span class="line">            ...</span><br><span class="line">        &#125;</span><br><span class="line">    &#125;);</span><br></pre></td></tr></table></figure><p>看到区别了吗？</p><p>当 RxJava 形式的时候，Retrofit 把请求封装进 <code>Observable</code> ，在请求结束后调用 <code>onNext()</code> 或在请求失败后调用 <code>onError()</code>。</p><p>对比来看， <code>Callback</code> 形式和 <code>Observable</code> 形式长得不太一样，但本质都差不多，而且在细节上 <code>Observable</code> 形式似乎还比 <code>Callback</code> 形式要差点。那 Retrofit 为什么还要提供 RxJava 的支持呢？</p><p>因为它好用啊！从这个例子看不出来是因为这只是最简单的情况。而一旦情景复杂起来， <code>Callback</code> 形式马上就会开始让人头疼。比如：</p><p>假设这么一种情况：你的程序取到的 <code>User</code> 并不应该直接显示，而是需要先与数据库中的数据进行比对和修正后再显示。使用 <code>Callback</code>方式大概可以这么写：</p><figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br></pre></td><td class="code"><pre><span class="line">getUser(userId, new Callback&lt;User&gt;() &#123;</span><br><span class="line">    @Override</span><br><span class="line">    public void success(User user) &#123;</span><br><span class="line">        processUser(user); // 尝试修正 User 数据</span><br><span class="line">        userView.setUser(user);</span><br><span class="line">    &#125;</span><br><span class="line"></span><br><span class="line">    @Override</span><br><span class="line">    public void failure(RetrofitError error) &#123;</span><br><span class="line">        // Error handling</span><br><span class="line">        ...</span><br><span class="line">    &#125;</span><br><span class="line">&#125;;</span><br></pre></td></tr></table></figure><p>有问题吗？</p><p>很简便，但不要这样做。为什么？因为这样做会影响性能。数据库的操作很重，一次读写操作花费 10~20ms 是很常见的，这样的耗时很容易造成界面的卡顿。所以通常情况下，如果可以的话一定要避免在主线程中处理数据库。所以为了提升性能，这段代码可以优化一下：</p><figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br></pre></td><td class="code"><pre><span class="line">getUser(userId, new Callback&lt;User&gt;() &#123;</span><br><span class="line">    @Override</span><br><span class="line">    public void success(User user) &#123;</span><br><span class="line">        new Thread() &#123;</span><br><span class="line">            @Override</span><br><span class="line">            public void run() &#123;</span><br><span class="line">                processUser(user); // 尝试修正 User 数据</span><br><span class="line">                runOnUiThread(new Runnable() &#123; // 切回 UI 线程</span><br><span class="line">                    @Override</span><br><span class="line">                    public void run() &#123;</span><br><span class="line">                        userView.setUser(user);</span><br><span class="line">                    &#125;</span><br><span class="line">                &#125;);</span><br><span class="line">            &#125;).start();</span><br><span class="line">    &#125;</span><br><span class="line"></span><br><span class="line">    @Override</span><br><span class="line">    public void failure(RetrofitError error) &#123;</span><br><span class="line">        // Error handling</span><br><span class="line">        ...</span><br><span class="line">    &#125;</span><br><span class="line">&#125;;</span><br></pre></td></tr></table></figure><p>性能问题解决，但……这代码实在是太乱了，迷之缩进啊！杂乱的代码往往不仅仅是美观问题，因为代码越乱往往就越难读懂，而如果项目中充斥着杂乱的代码，无疑会降低代码的可读性，造成团队开发效率的降低和出错率的升高。</p><p>这时候，如果用 RxJava 的形式，就好办多了。 RxJava 形式的代码是这样的：</p><figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br></pre></td><td class="code"><pre><span class="line">getUser(userId)</span><br><span class="line">    .doOnNext(new Action1&lt;User&gt;() &#123;</span><br><span class="line">        @Override</span><br><span class="line">        public void call(User user) &#123;</span><br><span class="line">            processUser(user);</span><br><span class="line">        &#125;)</span><br><span class="line">    .observeOn(AndroidSchedulers.mainThread())</span><br><span class="line">    .subscribe(new Observer&lt;User&gt;() &#123;</span><br><span class="line">        @Override</span><br><span class="line">        public void onNext(User user) &#123;</span><br><span class="line">            userView.setUser(user);</span><br><span class="line">        &#125;</span><br><span class="line"></span><br><span class="line">        @Override</span><br><span class="line">        public void onCompleted() &#123;</span><br><span class="line">        &#125;</span><br><span class="line"></span><br><span class="line">        @Override</span><br><span class="line">        public void onError(Throwable error) &#123;</span><br><span class="line">            // Error handling</span><br><span class="line">            ...</span><br><span class="line">        &#125;</span><br><span class="line">    &#125;);</span><br></pre></td></tr></table></figure><p>后台代码和前台代码全都写在一条链中，明显清晰了很多。</p><p>再举一个例子：假设 <code>/user</code> 接口并不能直接访问，而需要填入一个在线获取的 <code>token</code> ，代码应该怎么写？</p><p><code>Callback</code> 方式，可以使用嵌套的 <code>Callback</code>：</p><figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br><span class="line">28</span><br><span class="line">29</span><br><span class="line">30</span><br><span class="line">31</span><br></pre></td><td class="code"><pre><span class="line">@GET(&quot;/token&quot;)</span><br><span class="line">public void getToken(Callback&lt;String&gt; callback);</span><br><span class="line"></span><br><span class="line">@GET(&quot;/user&quot;)</span><br><span class="line">public void getUser(@Query(&quot;token&quot;) String token, @Query(&quot;userId&quot;) String userId, Callback&lt;User&gt; callback);</span><br><span class="line"></span><br><span class="line">...</span><br><span class="line"></span><br><span class="line">getToken(new Callback&lt;String&gt;() &#123;</span><br><span class="line">    @Override</span><br><span class="line">    public void success(String token) &#123;</span><br><span class="line">        getUser(token, userId, new Callback&lt;User&gt;() &#123;</span><br><span class="line">            @Override</span><br><span class="line">            public void success(User user) &#123;</span><br><span class="line">                userView.setUser(user);</span><br><span class="line">            &#125;</span><br><span class="line"></span><br><span class="line">            @Override</span><br><span class="line">            public void failure(RetrofitError error) &#123;</span><br><span class="line">                // Error handling</span><br><span class="line">                ...</span><br><span class="line">            &#125;</span><br><span class="line">        &#125;;</span><br><span class="line">    &#125;</span><br><span class="line"></span><br><span class="line">    @Override</span><br><span class="line">    public void failure(RetrofitError error) &#123;</span><br><span class="line">        // Error handling</span><br><span class="line">        ...</span><br><span class="line">    &#125;</span><br><span class="line">&#125;);</span><br></pre></td></tr></table></figure><p>倒是没有什么性能问题，可是迷之缩进毁一生，你懂我也懂，做过大项目的人应该更懂。</p><p>而使用 RxJava 的话，代码是这样的：</p><figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br><span class="line">28</span><br><span class="line">29</span><br><span class="line">30</span><br><span class="line">31</span><br></pre></td><td class="code"><pre><span class="line">@GET(&quot;/token&quot;)</span><br><span class="line">public Observable&lt;String&gt; getToken();</span><br><span class="line"></span><br><span class="line">@GET(&quot;/user&quot;)</span><br><span class="line">public Observable&lt;User&gt; getUser(@Query(&quot;token&quot;) String token, @Query(&quot;userId&quot;) String userId);</span><br><span class="line"></span><br><span class="line">...</span><br><span class="line"></span><br><span class="line">getToken()</span><br><span class="line">    .flatMap(new Func1&lt;String, Observable&lt;User&gt;&gt;() &#123;</span><br><span class="line">        @Override</span><br><span class="line">        public Observable&lt;User&gt; onNext(String token) &#123;</span><br><span class="line">            return getUser(token, userId);</span><br><span class="line">        &#125;)</span><br><span class="line">    .observeOn(AndroidSchedulers.mainThread())</span><br><span class="line">    .subscribe(new Observer&lt;User&gt;() &#123;</span><br><span class="line">        @Override</span><br><span class="line">        public void onNext(User user) &#123;</span><br><span class="line">            userView.setUser(user);</span><br><span class="line">        &#125;</span><br><span class="line"></span><br><span class="line">        @Override</span><br><span class="line">        public void onCompleted() &#123;</span><br><span class="line">        &#125;</span><br><span class="line"></span><br><span class="line">        @Override</span><br><span class="line">        public void onError(Throwable error) &#123;</span><br><span class="line">            // Error handling</span><br><span class="line">            ...</span><br><span class="line">        &#125;</span><br><span class="line">    &#125;);</span><br></pre></td></tr></table></figure><p>用一个 <code>flatMap()</code> 就搞定了逻辑，依然是一条链。看着就很爽，是吧？</p><p>2016/03/31 更新，加上我写的一个 Sample 项目：<br><a href="https://github.com/rengwuxian/RxJavaSamples" target="_blank" rel="noopener">rengwuxian RxJava Samples</a></p><p>好，Retrofit 部分就到这里。</p><h4 id="2-RxBinding"><a href="#2-RxBinding" class="headerlink" title="2. RxBinding"></a>2. RxBinding</h4><p><a href="https://github.com/JakeWharton/RxBinding" target="_blank" rel="noopener">RxBinding</a> 是 Jake Wharton 的一个开源库，它提供了一套在 Android 平台上的基于 RxJava 的 Binding API。所谓 Binding，就是类似设置 <code>OnClickListener</code> 、设置 <code>TextWatcher</code> 这样的注册绑定对象的 API。</p><p>举个设置点击监听的例子。使用 <code>RxBinding</code> ，可以把事件监听用这样的方法来设置：</p><figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br></pre></td><td class="code"><pre><span class="line">Button button = ...;</span><br><span class="line">RxView.clickEvents(button) // 以 Observable 形式来反馈点击事件</span><br><span class="line">    .subscribe(new Action1&lt;ViewClickEvent&gt;() &#123;</span><br><span class="line">        @Override</span><br><span class="line">        public void call(ViewClickEvent event) &#123;</span><br><span class="line">            // Click handling</span><br><span class="line">        &#125;</span><br><span class="line">    &#125;);</span><br></pre></td></tr></table></figure><p>看起来除了形式变了没什么区别，实质上也是这样。甚至如果你看一下它的源码，你会发现它连实现都没什么惊喜：它的内部是直接用一个包裹着的 <code>setOnClickListener()</code> 来实现的。然而，仅仅这一个形式的改变，却恰好就是 <code>RxBinding</code> 的目的：扩展性。通过 <code>RxBinding</code>把点击监听转换成 <code>Observable</code> 之后，就有了对它进行扩展的可能。扩展的方式有很多，根据需求而定。一个例子是前面提到过的 <code>throttleFirst()</code> ，用于去抖动，也就是消除手抖导致的快速连环点击：</p><figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br></pre></td><td class="code"><pre><span class="line">RxView.clickEvents(button)</span><br><span class="line">    .throttleFirst(500, TimeUnit.MILLISECONDS)</span><br><span class="line">    .subscribe(clickAction);</span><br></pre></td></tr></table></figure><p>如果想对 <code>RxBinding</code> 有更多了解，可以去它的 <a href="https://github.com/JakeWharton/RxBinding" target="_blank" rel="noopener">GitHub 项目</a> 下面看看。</p><h4 id="3-各种异步操作"><a href="#3-各种异步操作" class="headerlink" title="3. 各种异步操作"></a>3. 各种异步操作</h4><p>前面举的 <code>Retrofit</code> 和 <code>RxBinding</code> 的例子，是两个可以提供现成的 <code>Observable</code> 的库。而如果你有某些异步操作无法用这些库来自动生成 <code>Observable</code>，也完全可以自己写。例如数据库的读写、大图片的载入、文件压缩/解压等各种需要放在后台工作的耗时操作，都可以用 RxJava 来实现，有了之前几章的例子，这里应该不用再举例了。</p><h4 id="4-RxBus"><a href="#4-RxBus" class="headerlink" title="4. RxBus"></a>4. RxBus</h4><p>RxBus 名字看起来像一个库，但它并不是一个库，而是一种模式，它的思想是使用 RxJava 来实现了 EventBus ，而让你不再需要使用 <code>Otto</code> 或者 GreenRobot 的 <code>EventBus</code>。至于什么是 RxBus，可以看<a href="http://nerds.weddingpartyapp.com/tech/2014/12/24/implementing-an-event-bus-with-rxjava-rxbus/" target="_blank" rel="noopener">这篇文章</a>。顺便说一句，Flipboard 已经用 RxBus 替换掉了 <code>Otto</code> ，目前为止没有不良反应。</p>]]></content>
    
    <summary type="html">
    
      &lt;h3 id=&quot;RxJava-到底是什么&quot;&gt;&lt;a href=&quot;#RxJava-到底是什么&quot; class=&quot;headerlink&quot; title=&quot;RxJava 到底是什么&quot;&gt;&lt;/a&gt;RxJava 到底是什么&lt;/h3&gt;&lt;p&gt;一个词：&lt;strong&gt;异步&lt;/strong&gt;。&lt;/p&gt;
&lt;p&gt;RxJava 在 GitHub 主页上的自我介绍是 “a library for composing asynchronous and event-based programs using observable sequences for the Java VM”（一个在 Java VM 上使用可观测的序列来组成异步的、基于事件的程序的库）。这就是 RxJava ，概括得非常精准。&lt;/p&gt;
&lt;p&gt;然而，对于初学者来说，这太难看懂了。因为它是一个『总结』，而初学者更需要一个『引言』。&lt;/p&gt;
&lt;p&gt;其实， RxJava 的本质可以压缩为异步这一个词。说到根上，它就是一个实现异步操作的库，而别的定语都是基于这之上的。&lt;/p&gt;
    
    </summary>
    
      <category term="android" scheme="http://yoursite.com/categories/android/"/>
    
    
  </entry>
  
  <entry>
    <title>第1章 js入门</title>
    <link href="http://yoursite.com/2017/01/23/%E7%AC%AC1%E7%AB%A0-js%E5%85%A5%E9%97%A8/"/>
    <id>http://yoursite.com/2017/01/23/第1章-js入门/</id>
    <published>2017-01-23T07:12:36.000Z</published>
    <updated>2017-03-24T02:32:30.000Z</updated>
    
    <content type="html"><![CDATA[<h1 id="第1章"><a href="#第1章" class="headerlink" title="第1章"></a>第1章</h1><h2 id="1-1-为什么学习JavaScript"><a href="#1-1-为什么学习JavaScript" class="headerlink" title="1.1  为什么学习JavaScript"></a>1.1  为什么学习JavaScript</h2><p><strong>一、你知道，为什么JavaScript非常值得我们学习吗？</strong></p><ol><li><p>目前，全世界大部分网页都使用JavaScript。</p></li><li><p>它可以让网页呈现各种动态效果。</p></li><li><p>做为一个Web开发师，如果你想提供漂亮的网页、令用户满意的上网体验，JavaScript是必不可少的工具。</p><a id="more"></a></li></ol><p>二、<strong>易学性</strong></p><p>1.学习环境无外不在，只要有文本编辑器，就能编写JavaScript程序。</p><p>2.我们可以用简单命令，完成一些基本操作。</p><p><strong>三、从哪开始学习呢？</strong></p><p>学习JavaScript的起点就是处理网页，所以我们先学习基础语法和如何使用DOM进行简单操作。</p><h2 id="1-2-如何插入js"><a href="#1-2-如何插入js" class="headerlink" title="1-2 如何插入js"></a>1-2 如何插入js</h2><p>使用<script>标签在HTML网页中插入JavaScript代码。注意， <script>标签要成对出现，并把JavaScript代码写在<code>&lt;script&gt;&lt;/script&gt;</code>之间。</p><p><img src="http://img.mukewang.com/52e31ea8000149f406440218.jpg" alt=""></p><p><code>&lt;script type=&quot;text/javascript&quot;&gt;</code>表示在<script></script>之间的是文本类型(text),javascript是为了告诉浏览器里面的文本是属于JavaScript语言。</p><h2 id="1-3引用JS外部文件"><a href="#1-3引用JS外部文件" class="headerlink" title="1.3引用JS外部文件"></a>1.3引用JS外部文件</h2><p>我们可以把HTML文件和JS代码分开,并单独创建一个JavaScript文件(简称JS文件),其文件后缀通常为.js，然后将JS代码直接写在JS文件中。</p><p><img src="http://img.mukewang.com/52898b400001d04005500266.jpg" alt=""></p><p><strong>注意:在JS文件中，不需要标签,直接编写JavaScript代码就可以了</strong></p><p>JS文件不能直接运行，需嵌入到HTML文件中执行，我们需在HTML中添加如下代码，就可将JS文件嵌入HTML文件中。</p><figure class="highlight javascript"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><span class="line">&lt;script src=<span class="string">"script.js"</span>&gt;&lt;/script&gt;</span><br></pre></td></tr></table></figure><p><img src="http://img.mukewang.com/52898b6900018aeb05540284.jpg" alt=""></p><h2 id="1-4-JS在页面中的位置"><a href="#1-4-JS在页面中的位置" class="headerlink" title="1.4 JS在页面中的位置"></a>1.4 JS在页面中的位置</h2><p>我们可以将JavaScript代码放在html文件中任何位置，但是我们一般放在网页的head或者body部分。<br><strong>放在部分</strong><br>最常用的方式是在页面中head部分放置<script>元素，浏览器解析head部分就会执行这个代码，然后才解析页面的其余部分。<br><strong>放在部分</strong><br>JavaScript代码在网页读取到该语句的时候就会执行。</p><p><img src="http://img.mukewang.com/52a6ad240001086506440600.jpg" alt=""></p><p><strong>注意: </strong>javascript作为一种脚本语言可以放在html页面中任何位置，但是浏览器解释html时是按先后顺序的，所以前面的script就先被执行。比如进行页面显示初始化的js必须放在head里面，因为初始化都要求提前进行（如给页面body设置css等）；而如果是通过事件调用执行的function那么对位置没什么要求的。</p><h2 id="1-5-JavaScript-认识语句和符号"><a href="#1-5-JavaScript-认识语句和符号" class="headerlink" title="1.5 JavaScript-认识语句和符号"></a>1.5 JavaScript-认识语句和符号</h2><p>JavaScript语句是发给浏览器的命令。这些命令的作用是告诉浏览器要做的事情。</p><p><strong>每一句JavaScript代码格式:</strong><code>语句;</code></p><p>先来看看下面代码</p><figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br></pre></td><td class="code"><pre><span class="line">&lt;script type=&quot;text/javascript&quot;&gt;</span><br><span class="line">   alert(&quot;hello!&quot;);</span><br><span class="line">&lt;/script&gt;</span><br></pre></td></tr></table></figure><p>例子中的<code>alert(&quot;hello!&quot;);</code>就是一个JavaScript语句。</p><p>一行的结束就被认定为语句的结束，通常在结尾加上一个分号<code>&quot;;&quot;</code>来表示语句的结束。</p><p>看看下面这段代码,有三条语句，每句结束后都有”;”，按顺序执行语句。</p><figure class="highlight javascript"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br></pre></td><td class="code"><pre><span class="line">&lt;script type=<span class="string">"text/javascript"</span>&gt;</span><br><span class="line">   <span class="built_in">document</span>.write(<span class="string">"I"</span>);</span><br><span class="line">   <span class="built_in">document</span>.write(<span class="string">"love"</span>);</span><br><span class="line">   <span class="built_in">document</span>.write(<span class="string">"JavaScript"</span>);</span><br><span class="line">&lt;<span class="regexp">/script&gt;</span></span><br></pre></td></tr></table></figure><h2 id="1-6-JavaScript-注释很重要"><a href="#1-6-JavaScript-注释很重要" class="headerlink" title="1.6 JavaScript-注释很重要"></a>1.6 JavaScript-注释很重要</h2><p>注释的作用是提高代码的可读性，帮助自己和别人阅读和理解你所编写的JavaScript代码，注释的内容不会在网页中显示。注释可分为单行注释与多行注释两种。</p><p>我们为了方便阅读，注释内容一般放到需要解释语句的结尾处或周围。</p><p><strong>单行注释，在注释内容前加符号 “//”。</strong></p><figure class="highlight javascript"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br></pre></td><td class="code"><pre><span class="line">&lt;script type=<span class="string">"text/javascript"</span>&gt;</span><br><span class="line">  <span class="built_in">document</span>.write(<span class="string">"单行注释使用'//'"</span>);  <span class="comment">// 我是注释，该语句功能在网页中输出内容</span></span><br><span class="line">&lt;<span class="regexp">/script&gt;</span></span><br></pre></td></tr></table></figure><p><strong>多行注释以”/*“开始，以”*/“结束。</strong></p><figure class="highlight javascript"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br></pre></td><td class="code"><pre><span class="line">&lt;script type=<span class="string">"text/javascript"</span>&gt;</span><br><span class="line">   <span class="built_in">document</span>.write(<span class="string">"多行注释使用/*注释内容*/"</span>);</span><br><span class="line">   <span class="comment">/*</span></span><br><span class="line"><span class="comment">    多行注释</span></span><br><span class="line"><span class="comment">    养成书写注释的良好习惯</span></span><br><span class="line"><span class="comment">   */</span></span><br><span class="line">&lt;<span class="regexp">/script&gt;</span></span><br></pre></td></tr></table></figure><h2 id="1-7-JavaScript-什么是变量"><a href="#1-7-JavaScript-什么是变量" class="headerlink" title="1.7 JavaScript-什么是变量"></a>1.7 JavaScript-什么是变量</h2><p>什么是变量? 从字面上看，变量是可变的量；从编程角度讲，变量是用于存储某种/某些数值的存储器。我们可以把变量看做一个盒子，为了区分盒子，可以用BOX1,BOX2等名称代表不同盒子，BOX1就是盒子的名字（也就是变量的名字）。</p><p><img src="http://img.mukewang.com/52e32dc90001140c04120228.jpg" alt=""></p><p><strong>定义变量使用关键字var,语法如下：</strong></p><figure class="highlight javascript"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">var</span> 变量名</span><br></pre></td></tr></table></figure><p><strong>变量名可以任意取名，但要遵循命名规则:</strong></p><pre><code>1.变量必须使用字母、下划线(_)或者美元符($)开始。2.然后可以使用任意多个英文字母、数字、下划线(_)或者美元符($)组成。3.不能使用JavaScript关键词与JavaScript保留字。</code></pre><p><strong>变量要先声明再赋值，如下：</strong></p><figure class="highlight javascript"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">var</span> mychar;</span><br><span class="line">mychar=<span class="string">"javascript"</span>;</span><br><span class="line"><span class="keyword">var</span> mynum = <span class="number">6</span>;</span><br></pre></td></tr></table></figure><p><strong>变量可以重复赋值，如下：</strong></p><figure class="highlight javascript"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">var</span> mychar;</span><br><span class="line">mychar=<span class="string">"javascript"</span>;</span><br><span class="line">mychar=<span class="string">"hello"</span>;</span><br></pre></td></tr></table></figure><p><strong>注意:</strong></p><ol><li>在JS中区分大小写，如变量mychar与myChar是不一样的，表示是两个变量。</li><li>变量虽然也可以不声明，直接使用，但不规范，需要先声明，后使用。</li></ol><h2 id="1-8-JavaScript-判断语句（if…else）"><a href="#1-8-JavaScript-判断语句（if…else）" class="headerlink" title="1.8 JavaScript-判断语句（if…else）"></a>1.8 JavaScript-判断语句（if…else）</h2><p>if…else语句是在指定的条件成立时执行代码，在条件不成立时执行else后的代码。</p><p><strong>语法:</strong></p><figure class="highlight javascript"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">if</span>(条件)</span><br><span class="line">&#123; 条件成立时执行的代码 &#125;</span><br><span class="line"><span class="keyword">else</span></span><br><span class="line">&#123; 条件不成立时执行的代码 &#125;</span><br></pre></td></tr></table></figure><p>假设我们通过年龄来判断是否为成年人，如年龄大于等于18岁，是成年人，否则不是成年人。<strong>代码表示如下**</strong>:**</p><figure class="highlight javascript"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br></pre></td><td class="code"><pre><span class="line">&lt;script type=<span class="string">"text/javascript"</span>&gt;</span><br><span class="line">   <span class="keyword">var</span> myage = <span class="number">18</span>;</span><br><span class="line">   <span class="keyword">if</span>(myage&gt;=<span class="number">18</span>)  <span class="comment">//myage&gt;=18是判断条件</span></span><br><span class="line">   &#123; <span class="built_in">document</span>.write(<span class="string">"你是成年人。"</span>);&#125;</span><br><span class="line">   <span class="keyword">else</span>  <span class="comment">//否则年龄小于18</span></span><br><span class="line">   &#123; <span class="built_in">document</span>.write(<span class="string">"未满18岁，你不是成年人。"</span>);&#125;</span><br><span class="line">&lt;<span class="regexp">/script&gt;</span></span><br></pre></td></tr></table></figure><h2 id="1-9-JavaScript-什么是函数"><a href="#1-9-JavaScript-什么是函数" class="headerlink" title="1.9 JavaScript-什么是函数"></a>1.9 JavaScript-什么是函数</h2><p>函数是完成某个特定功能的一组语句。如没有函数，完成任务可能需要五行、十行、甚至更多的代码。这时我们就可以把完成特定功能的代码块放到一个函数里，直接调用这个函数，就省重复输入大量代码的麻烦。</p><p><strong>如何定义一个函数呢？基本语法如下:</strong></p><figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br></pre></td><td class="code"><pre><span class="line">function 函数名()</span><br><span class="line">&#123;</span><br><span class="line">     函数代码;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure><p><strong>说明:</strong></p><ol><li>function定义函数的关键字。</li><li>“函数名”你为函数取的名字。</li><li>“函数代码”替换为完成特定功能的代码。</li></ol><p>我们来编写一个实现两数相加的简单函数,并给函数起个有意义的名字：“add2”，代码如下：</p><figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br></pre></td><td class="code"><pre><span class="line">function add2()&#123;</span><br><span class="line">   var sum = 3 + 2;</span><br><span class="line">   alert(sum);</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure><p><strong>函数调用:</strong></p><p>函数定义好后，是不能自动执行的，所以需调用它,只需直接在需要的位置写函数就ok了,<strong>代码如下:</strong></p><p><img src="http://img.mukewang.com/5419430400012de808370459.jpg" alt=""></p></script></p>]]></content>
    
    <summary type="html">
    
      &lt;h1 id=&quot;第1章&quot;&gt;&lt;a href=&quot;#第1章&quot; class=&quot;headerlink&quot; title=&quot;第1章&quot;&gt;&lt;/a&gt;第1章&lt;/h1&gt;&lt;h2 id=&quot;1-1-为什么学习JavaScript&quot;&gt;&lt;a href=&quot;#1-1-为什么学习JavaScript&quot; class=&quot;headerlink&quot; title=&quot;1.1  为什么学习JavaScript&quot;&gt;&lt;/a&gt;1.1  为什么学习JavaScript&lt;/h2&gt;&lt;p&gt;&lt;strong&gt;一、你知道，为什么JavaScript非常值得我们学习吗？&lt;/strong&gt;&lt;/p&gt;
&lt;ol&gt;
&lt;li&gt;&lt;p&gt;目前，全世界大部分网页都使用JavaScript。&lt;/p&gt;
&lt;/li&gt;
&lt;li&gt;&lt;p&gt;它可以让网页呈现各种动态效果。&lt;/p&gt;
&lt;/li&gt;
&lt;li&gt;&lt;p&gt;做为一个Web开发师，如果你想提供漂亮的网页、令用户满意的上网体验，JavaScript是必不可少的工具。&lt;/p&gt;
    
    </summary>
    
      <category term="JS" scheme="http://yoursite.com/categories/JS/"/>
    
    
  </entry>
  
</feed>
